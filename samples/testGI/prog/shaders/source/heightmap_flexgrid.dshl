include "shader_global.dshl"
include "gbuffer.dshl"
include "psh_derivate.dshl"
include "heightmap_common.dshl"
include "flexgrid_common.dshl"
include "normaldetail.dshl"

shader heightmap_flexgrid
{
  no_ablend;
  cull_mode = cw;

  bool use_tform = false;

  channel color8 pos=pos;
  channel color8 norm=norm;
  channel color8 tc[0]=tc[0];
  channel color8 tc[1]=tc[1];

  INIT_WORLD_HEIGHTMAP_VS()
  USE_HEIGHTMAP_COMMON_VS()
  (vs) {
    globtm@f44 = globtm;
    world_view_pos@f3 = world_view_pos;
    world_to_hmap_low_without_texel_offset@f4 = world_to_hmap_low;
  }

  USE_FLEXGRID_WPOS_VS()
  USE_FLEXGRID_VS_OUTPUT()

  hlsl(vs) {
    FlexGridVsOutput test_vs(FlexGridVsInput input, uint vertexId : SV_VertexID USE_INSTANCE_ID)
    {
      FlexGridVsOutput output;

      const float lod_offset = dot(input.edgeShiftMask, flexgrid_instance_data[instance_id.x].neighborLodOffset);
      const float4 patchData = flexgrid_instance_data[instance_id.x].patchData;

      input.data0.xy = decodePos(input.data0.xy);
      input.data0.zw = unpackToMinusOneZeroOne(input.data0.zw) * FLEXGRID_QUAD_SIZE;
      input.data1.x = decodePosToIndex(input.data1.x);
      input.data1.yz = unpackToMinusOneZeroOne(input.data1.yz) * FLEXGRID_QUAD_SIZE;

      input.avgShiftPrevLod.xy = unpackToMinusOneZeroOne(input.avgShiftPrevLod.xy) * FLEXGRID_PARENT_SCALE;
      input.avgShiftPrevLod.zw = unpackToMinusOneZeroOne(input.avgShiftPrevLod.zw) * FLEXGRID_GRANDPARENT_SCALE;
      input.avgShiftPrevLod *= FLEXGRID_QUAD_SIZE;

      const float2 worldPosXZ = calcWorldPosXZ(input.data0, patchData.xy, patchData.z, input.data1.x, lod_offset,
        flexgrid_instance_data[instance_id.x].neighborLodOffset, flexgrid_instance_data[instance_id.x].packedEdgesDirection,
        vertexId);
      // const float3 morphValueDirection = calcMorph(input.edgeShiftMask, flexgrid_instance_data[instance_id.x].neighborPatchMorph, input.avgShiftPrevLod,
      //       input.data1.yz, patchData.z, patchData.w, lod_offset);
      const float3 morphValueDirection = float3(0,0,1);

      const float3 worldPos = getWorldPosFlexGridSimple(worldPosXZ, morphValueDirection);

      output.pos = mul(float4(worldPos, 1), globtm);
      output.worldPos = worldPos;
      output.pToEye_Nscale.xyz = world_view_pos-worldPos;
      output.pToEye_Nscale.w = 1.0f;
      return output;
    }
  }
  //cull_mode = none;
  (ps) {
    heightmap@smp2d = tex_hmap_low;
    sizes@f4 = (tex_hmap_inv_sizes.x/world_to_hmap_low.x/heightmap_scale.x, 0, 0, 0);
    tex_hmap_inv_sizes@f4 = (tex_hmap_inv_sizes.x, tex_hmap_inv_sizes.y, 1/tex_hmap_inv_sizes.x, 1/tex_hmap_inv_sizes.y);
    world_to_hmap_low@f4 = (world_to_hmap_low.x, world_to_hmap_low.y, world_to_hmap_low.z + 0.5*tex_hmap_inv_sizes.x, world_to_hmap_low.w+0.5*tex_hmap_inv_sizes.y);
    world_view_pos@f3 = world_view_pos;
  }

  USE_PIXEL_TANGENT_SPACE()
  WRITE_GBUFFER()
  USE_NORMAL_DETAIL()

  hlsl(ps) {
    #define sizeInMeters (sizes.x)
    float getTexel(float2 p)
    {
      return h1tex2D(heightmap, p);
    }

    half3 getNormalLow(float2 pos)
    {
      float3 offset = float3(tex_hmap_inv_sizes.x, 0, tex_hmap_inv_sizes.y);
      half W = getTexel(float2(pos.xy - offset.xy));
      half E = getTexel(float2(pos.xy + offset.xy));
      half N = getTexel(float2(pos.xy - offset.yz));
      half S = getTexel(float2(pos.xy + offset.yz));
      return normalize(half3(W-E, sizeInMeters, N-S));
    }
    half3 getWorldNormal(float3 worldPos)
    {
      half3 normal;
      float2 worldPosXZ = worldPos.xz;
      float2 tc_low = worldPosXZ*world_to_hmap_low.xy + world_to_hmap_low.zw;
      normal = getNormalLow(tc_low);
      return normal;
    }

    GBUFFER_OUTPUT test_ps(FlexGridVsOutput input HW_USE_SCREEN_POS INPUT_VFACE)
    {
      float4 screenpos = GET_SCREEN_POS(input.pos);
      float3 worldPos = world_view_pos.xyz-input.pToEye_Nscale.xyz;
      float3 worldNormal = getWorldNormal(worldPos.xyz).xyz;

      UnpackedGbuffer result;
      init_gbuffer(result);
      float2 worldPosXZ = worldPos.xz;
      float2 tc_low = worldPosXZ*world_to_hmap_low.xy + world_to_hmap_low.zw;

      //texCoord = input.tc;
      half3 albedo = 0.5;//half3(0.15,0.2, 0.05);

      //init_albedo_roughness(result, albedo_roughness);
      init_ao(result, 1);
      init_albedo(result, albedo.xyz);
      init_smoothness(result, 0.01);
      init_normal(result, worldNormal);
      return encode_gbuffer(result, input.pointToEye, screenpos);
    }
  }
  compile("target_vs", "test_vs");
  compile("target_ps", "test_ps");
}