macro USE_GBUFFER_PACK_UNPACK(code)
hlsl(code) {
  //reference
  ##if !(hardware.ps4 || hardware.ps5)
  float CubeMapFaceID(float3 v)
  {
    float faceID;
    FLATTEN
    if(abs(v.z) >= abs(v.x) && abs(v.z) >= abs(v.y))
    {
      faceID = (v.z < 0.0) ? 5.0 : 4.0;
    }
    else
    {
      FLATTEN
      if (abs(v.y) >= abs(v.x))
      {
        faceID = (v.y < 0.0) ? 3.0 : 2.0;
      }
      else
      {
        faceID = (v.x < 0.0) ? 1.0 : 0.0;
      }
    }
    return faceID;
  }
  ##endif
  float2 PackNormalMajorAxisIndex(float3 inNormal, uint axisNo)
  {
    uint index = axisNo*0.5f;
    float2 normal = inNormal.xy;
    normal = index == 0 ? inNormal.yz : normal;
    normal = index == 1 ? inNormal.xz : normal;
    return normal;
  }
  float2 PackNormalMajorAxis(float3 inNormal, out uint index)
  {
    index = CubeMapFaceID(inNormal);
    return PackNormalMajorAxisIndex(inNormal, index);
  }

  float3 UnPackNormalMajorAxis(float2 enc, uint faceIndex)
  {
    float3 normal;
    normal.xy = enc;
    normal.z = sqrt(1-dot(normal.xy, normal.xy));
    normal.z = (faceIndex&1) ? -normal.z : normal.z;
    uint index = uint(faceIndex / 2);

    normal = index == 0 ? normal.zxy : normal;
    normal = index == 1 ? normal.xzy : normal;
    return normal;
  }

  //dice encoding
  half2 encodeNormal(half3 n1, out uint index)
  {
    return half2(PackNormalMajorAxis(n1, index));
  }
  float3 decodeNormal(half2 enc, uint index)
  {
    return UnPackNormalMajorAxis(enc, index);
  }

  #include <hsv_rgb_conversion.hlsl>
  #include <pixelPacking/ColorSpaceUtility.hlsl>

  ##if in_editor_assume == yes
    #define GBUFFER_IN_EDITOR 1
  ##else
    #define GBUFFER_IN_EDITOR 0
  ##endif

  #include <gbuffer_packing_inc_DNG.hlsl>
}
endmacro
