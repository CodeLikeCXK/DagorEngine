include "shader_global.dshl"
include "dynamic_simple_inc.dshl"

int bvh_process_target_offset;
int bvh_process_skinned_vertices_start;
int bvh_process_skinned_vertices_stride;
int bvh_process_skinned_vertices_count;
int bvh_process_skinned_vertices_processed_stride;
int bvh_process_skinned_vertices_position_offset;
int bvh_process_skinned_vertices_skin_indices_offset;
int bvh_process_skinned_vertices_skin_weights_offset;
int bvh_process_skinned_vertices_normal_offset;
int bvh_process_skinned_vertices_color_offset;
int bvh_process_skinned_vertices_texcoord_offset;
int bvh_process_skinned_vertices_texcoord_size;
int bvh_process_skinned_vertices_pos_format_half;

float4 bvh_process_skinned_vertices_pos_mul;
float4 bvh_process_skinned_vertices_pos_ofs;

float4x4 bvh_process_skinned_vertices_inv_wtm;

interval bvh_process_skinned_vertices_texcoord_size: zero < 1, four < 8, eight;
interval bvh_process_skinned_vertices_normal_offset: no < 1, yes;
interval bvh_process_skinned_vertices_color_offset: no < 1, yes;
interval bvh_process_skinned_vertices_pos_format_half: no < 1, yes;

int bvh_process_skinned_vertices_source_const_no = 6;
int bvh_process_skinned_vertices_output_uav_no = 0;

shader bvh_process_skinned_vertices
{
  if (compatibility_mode == compatibility_mode_on)
  {
    dont_render;
  }
  (cs) {
    target_offset@u1 = bvh_process_target_offset;
    start_vertex@i1 = bvh_process_skinned_vertices_start;
    vertex_stride@i1 = bvh_process_skinned_vertices_stride;
    vertex_count@i1 = bvh_process_skinned_vertices_count;
    processed_vertex_stride@i1 = bvh_process_skinned_vertices_processed_stride;
    position_offset@i1 = bvh_process_skinned_vertices_position_offset;
    skin_indices_offset@i1 = bvh_process_skinned_vertices_skin_indices_offset;
    skin_weights_offset@i1 = bvh_process_skinned_vertices_skin_weights_offset;
    color_offset@i1 = bvh_process_skinned_vertices_color_offset;
    normal_offset@i1 = bvh_process_skinned_vertices_normal_offset;
    texcoord_offset@i1 = bvh_process_skinned_vertices_texcoord_offset;
    texcoord_size@i1 = bvh_process_skinned_vertices_texcoord_size;
    pos_mul@f4 = bvh_process_skinned_vertices_pos_mul;
    pos_ofs@f4 = bvh_process_skinned_vertices_pos_ofs;

    inv_wtm@f44 = bvh_process_skinned_vertices_inv_wtm;
    source@buf : register(bvh_process_skinned_vertices_source_const_no) hlsl { ByteAddressBuffer source@buf; };
    output@uav : register(bvh_process_skinned_vertices_output_uav_no) hlsl { RWByteAddressBuffer output@uav; };
    matrices_stride@i1 = (matrices_stride);
  }
  DYNAMIC_SIMPLE_SHARED_DECL(cs)

  hlsl(cs) {
    struct VsInput
    {
      float4 pos;
      float4 normal;

      float4 packedBoneIndices;
      float4 boneWeights;
    };
    #define viewProjTm float4x4(0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0)
  }

  HAS_SKINNING_BASE(cs)

  ENABLE_ASSERT(cs)
  hlsl(cs) {
    #pragma wave32

    static const uint4 INPUT_ENCODING_OFFSET = uint4(16, 8, 0, 24);

    uint pack_normal4(float4 normal)
    {
      uint4 p4 = uint4((normal.xyz * .5f + .5f) * 0xff, normal.w * 0xff) << INPUT_ENCODING_OFFSET;
      return p4.x | p4.y | p4.z | p4.w;
    }

    [numthreads( 32, 1, 1 )]
    void bvh_process_skinned_vertices(uint3 dtId : SV_DispatchThreadID)
    {
      uint vertexId = dtId.x;
      if (vertexId >= vertex_count)
        return;

      VsInput input;

      int vertexStart = (start_vertex + vertexId) * vertex_stride;

      ##if bvh_process_skinned_vertices_pos_format_half == yes
        // Positions are half float
        uint2 packedPos = loadBuffer2(source, vertexStart + position_offset);

        const uint3 POS_ENCODING_OFFSET = uint3(16, 0, 16);
        int3 posI = asint(packedPos.xxy << POS_ENCODING_OFFSET) >> 16;
        input.pos = float4(posI / 32767.0, 1);
      ##else
        uint3 packedPos = loadBuffer3(source, vertexStart + position_offset);
        input.pos = float4(asfloat(packedPos), 1);
      ##endif

      // Skinning part


      uint packedNormal  = loadBuffer(source, vertexStart + normal_offset);
      uint packedIndices = loadBuffer(source, vertexStart + skin_indices_offset);
      uint packedWeights = loadBuffer(source, vertexStart + skin_weights_offset);

      input.normal            = float4((packedNormal  >> INPUT_ENCODING_OFFSET) & 255) / 255;
      input.packedBoneIndices = float4((packedIndices >> INPUT_ENCODING_OFFSET) & 255) / 255;
      input.boneWeights       = float4((packedWeights >> INPUT_ENCODING_OFFSET) & 255) / 255;

      float3 localDu = float3(1, 0, 0), localDv = float3(1, 0, 0);
      float3 eye_to_point;
      float4 output_pos; // Dummy
      float3 worldNormal;
      float3 world_du; // Dummy
      float3 world_dv; // Dummy
      instance_skinning(
        input,
        input.pos.xyz,
        input.normal.xyz,
        localDu,
        localDv,
        eye_to_point,
        output_pos,
        worldNormal,
        world_du,
        world_dv);

      float3 modelPos = mul(float4(eye_to_point, 1), inv_wtm).xyz;

      storeBuffer3(output, target_offset + vertexId * processed_vertex_stride, asuint(modelPos));

      uint offset = 12;

      ##if bvh_process_skinned_vertices_texcoord_size == four
        storeBuffer(output, target_offset + vertexId * processed_vertex_stride + offset, loadBuffer(source, vertexStart + texcoord_offset));
        offset += 4;
      ##elif bvh_process_skinned_vertices_texcoord_size == eight
        storeBuffer2(output, target_offset + vertexId * processed_vertex_stride + offset, loadBuffer2(source, vertexStart + texcoord_offset));
        offset += 8;
      ##endif

      // Seems inverse-transpose skinnedTm not used elsewhere for normals, so I assume non-uniform scaling is not an issue
      float4 modelNormal = float4(normalize(mul(worldNormal, float3x3(inv_wtm[0].xyz, inv_wtm[1].xyz, inv_wtm[2].xyz))), input.normal.w);

      storeBuffer(output, target_offset + vertexId * processed_vertex_stride + offset, pack_normal4(modelNormal));
      offset += 4;

      ##if bvh_process_skinned_vertices_color_offset == yes
        storeBuffer(output, target_offset + vertexId * processed_vertex_stride + offset, loadBuffer(source, vertexStart + color_offset));
        offset += 4;
      ##endif
    }
  }

  compile("target_cs", "bvh_process_skinned_vertices");
}
