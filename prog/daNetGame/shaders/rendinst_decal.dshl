include "rendinst_opaque_inc.dshl"
include "normaldetail.dshl"
include "decals/decal_painted_inc.dshl"
include "overlay_color_map_inc.dshl"
include "decals/decal_inc.dshl"
include "decals/blend_diffuse_decal_inc.dshl"
include "decals/modulate2x_decal_inc.dshl"
include "decals/deferred_decal_inc.dshl"

texture names_tex;

shader rendinst_blend_diffuse_decal, rendinst_modulate2x_diffuse_decal, rendinst_names_diffuse_decal, rendinst_blend_normal_decal
{
  if (shader != rendinst_names_diffuse_decal)
  {
    NO_DYNSTCODE()
  }
  assume instancing_type = tm_vb;
  if (rendinst_render_pass == rendinst_render_pass_voxelize_albedo) { dont_render;}
  if (rendinst_render_pass == rendinst_render_pass_impostor_color || rendinst_render_pass == rendinst_render_pass_impostor_shadow || rendinst_render_pass == rendinst_render_pass_to_shadow || rendinst_render_pass == rendinst_render_pass_depth)
  {
    dont_render;
  }
  render_stage imm_decal;
  if (shader != rendinst_names_diffuse_decal && shader != rendinst_blend_normal_decal)
  {
    texture tex = material.texture.diffuse;
  }
  hlsl {
    #define BLEND_GBUFFER 1
  }
  //static int atest = 0;
  //interval atest: atestOff < 1, atestOn;
  z_write = false;
  if (shader == rendinst_blend_diffuse_decal || shader == rendinst_blend_normal_decal)
  {
    texture normal = material.texture[2];
    if (normal != NULL)
    {
      USE_PIXEL_TANGENT_SPACE()
      WRITE_GBUFFER()
      (ps) { normal_tex@static = normal; }
      hlsl {
        #define HAS_NORMAL 1
      }
    }
  }

  static int draw_order = 0 no_warnings;

  channel float3 pos = pos;
  channel color8 norm = norm unsigned_pack;
  channel float2 tc[0] = tc[0];
  supports rendinst_scene;

  if (shader == rendinst_blend_diffuse_decal)
  {
    RENDINST_OVERLAY_COLOR_MAP(vs, false , get_paint_palette_row_index().x)
    INIT_DECAL_PAINTED()
  }

  ENABLE_MULTI_DRAW(false)
  RENDINST_INSTANCING()
  SETUP_CHARACTER_MICRODETAIL()
  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)

      float2 diffuseTexcoord        : TEXCOORD0;
      #if HAS_NORMAL
      float3 normal                 : TEXCOORD1;//for normal
      float3 pointToEye             : TEXCOORD2;//for normal
      #endif
      #if COLOR_NEEDED
      float3 colorMul : TEXCOORD3;
      #endif
      //float3 pointToEye             : TEXCOORD2;
      VSOUT_DRAW_ID
    };
  }


  hlsl(vs) {

    INSTANCING_BUFFERS

    struct VsInput
    {
      float3 pos                  : POSITION;
      #if HAS_NORMAL
      float3 normal               : NORMAL;
      #endif
      float2 diffuseTexcoord      : TEXCOORD0;
    };

    VsOutput simple_decal_vs(VsInput input  HW_USE_INSTANCE_ID)
    {
      VsOutput output;

      #if SET_UP_MULTIDRAW
        INIT_MULTIDRAW(output);
        SET_DRAW_CALL_ID(GET_MATERIAL_OFFSET);
      #endif

      #if HAS_NORMAL
      float3 localNormal = normalize(BGR_SWIZZLE(input.normal)*2-1);
      #else
      float3 localNormal = 1;
      #endif
      float3 localPos = input.pos;
      float opacity = 1;
      VB_PERFORM_INSTANCING

      float3 pointToEye = world_view_pos-worldPos;
      float3 dirToEye = normalize(pointToEye);
      worldPos += dirToEye.xyz * DECAL_TO_CAMERA_OFFSET;

      output.pos = mulPointTm(worldPos + camera_base_offset, globtm);
      output.diffuseTexcoord.xy = input.diffuseTexcoord;
      ##if shader == rendinst_names_diffuse_decal
        float2 uvOffset = float2(hashVal&0xFF, (hashVal>>8)&0xFF)/255.0;
        float2 uvScale = float2((hashVal>>16)&0xFF, (hashVal>>24)&0xFF)/255.0;
        if (hashVal != 0)
          output.diffuseTexcoord.xy = uvScale*input.diffuseTexcoord + uvOffset;
      ##endif
      #if HAS_NORMAL
      output.pointToEye = pointToEye;
      output.normal = worldNormal;
      #endif
      #if COLOR_NEEDED
        output.colorMul = 1;
        #if HAS_PAINT_DETAILS
          output.colorMul = getColorMul(hashVal);
        #endif
        #if HAS_OVERLAY_MAP_COLOR
          if (need_overlay_map_color())
            output.colorMul = get_overlay_map_color(worldPos);
        #endif
      #endif
      //output.pointToEye = pointToEye;
      return output;
    }
  }

  if (shader == rendinst_blend_diffuse_decal)
  {
    (ps) { diffuse_tex@static = tex; }
  } else if (shader == rendinst_blend_normal_decal)
  {
    static int writemask = 1904;//(7<<4)|(7<<8) - normal and material properties
    color_write = static writemask;
  } else if (shader == rendinst_names_diffuse_decal)
  {
    (ps) { diffuse_tex@smp2d = names_tex; }
  }

  if (shader == rendinst_modulate2x_diffuse_decal)
  {
    MODULATE_2X_DECAL_PS(false)
  } else if (shader == rendinst_blend_diffuse_decal)
  {
    BLEND_DIFFUSE_DECAL_PS(false)
  } else
  {
    blend_src = sa; blend_dst = isa;
  }
  if (shader == rendinst_blend_normal_decal)
  {
    USE_CHARACTER_MICRODETAIL()
  }
  ENABLE_ASSERT(ps)
  blend_asrc = 0; blend_adst = 1;
  hlsl(ps) {
    ##if (shader == rendinst_blend_normal_decal)
      #if HAS_NORMAL
        GBUFFER_OUTPUT simple_decal_ps(VsOutput input HW_USE_SCREEN_POS)
        {
          #if SET_UP_MULTIDRAW
            SET_DRAW_CALL_ID(GET_MATERIAL_OFFSET(input));
          #endif
          float4 screen = GET_SCREEN_POS(input.pos);
          half4 packedNormalMap = tex2DBindless(get_normal_tex(), input.diffuseTexcoord.xy);
          half3 albedo = 0;
          half alpha = saturate(abs(packedNormalMap.g - 0.5) * 2 * 10);
          half smoothness = packedNormalMap.r;
          half metalness = packedNormalMap.b;
          half3 normalMap = unpack_ag_normal(packedNormalMap);
          half3 vertexNormal = normalize(input.normal);
          half3 worldNormal = perturb_normal_precise(normalMap, vertexNormal, input.pointToEye.xyz, input.diffuseTexcoord.xy );
          BRANCH
          if (character_micro_detail_layer >= 0)
          {
            half reflectance = 0.5;
            apply_character_micro_detail(
              sample_character_micro_detail(input.diffuseTexcoord.xy*get_character_micro_detail_scale().xy, character_micro_detail_layer),
              albedo.rgb, worldNormal, reflectance, smoothness);
          }
          UnpackedGbuffer result;
          init_gbuffer(result);
          init_albedo(result, albedo.rgb);
          init_smoothness(result, smoothness);//
          init_normal(result, worldNormal);
          init_metalness(result, metalness);
          return encode_gbuffer_alpha(result, alpha, input.pointToEye, GET_SCREEN_POS(input.pos));
        }
      #else
        float4 simple_decal_ps(VsOutput input):SV_Target0
        {
          //THROW ERROR: Normal decal without normals tex
          return 0;
        }
      #endif
    ##elif (shader == rendinst_names_diffuse_decal)
      float4 simple_decal_ps(VsOutput input) : SV_Target0
      {
        return MOBILE_PS_OUTPUT_WRAPPER(h4tex2D(diffuse_tex, input.diffuseTexcoord.xy));
      }
    ##endif
  }

  compile("target_vs", "simple_decal_vs");
  if (shader != rendinst_blend_diffuse_decal && shader != rendinst_modulate2x_diffuse_decal)
  {
    compile("target_ps", "simple_decal_ps");
  }
}

shader rendinst_deferred_decal, rendinst_deferred_modulate2x_decal, rendinst_deferred_normal_decal
{
  if (instancing_type != tm_vb)
  {
    dont_render;
  }
  render_stage decal;
  hlsl {
    #define BLEND_GBUFFER 1
  }

  if (shader != rendinst_deferred_normal_decal)
  {
  texture tex = material.texture.diffuse;
  }
  if (shader == rendinst_deferred_decal || shader == rendinst_deferred_normal_decal)
  {
    texture normal = material.texture[2];
    if (shader == rendinst_deferred_decal)
    {
      static int atest = 0;
      interval atest: atestOff < 1, atestOn;
    }
    if (normal != NULL)
    {
      USE_PIXEL_TANGENT_SPACE()
      REDUCE_GBUFFER_MRT_MOBILE()
      WRITE_GBUFFER()
      (ps) { normal_tex@static = normal; }
      hlsl {
        #define HAS_NORMAL 1
      }
    } else if (compatibility_mode == compatibility_mode_on)
    {
      WRITE_GBUFFER()
      hlsl {
        #undef HAS_NORMAL
        #define HAS_NORMAL 1
      }
    }
  }

  z_write = false;

  static int draw_order = 0 no_warnings;

  channel float3 pos = pos;
  channel color8 norm = norm unsigned_pack;
  channel float2 tc[0] = tc[0];
  supports rendinst_scene;
  if (shader == rendinst_deferred_decal)
  {
    RENDINST_OVERLAY_COLOR_MAP(vs, false, get_paint_palette_row_index().x)
    INIT_DECAL_PAINTED()
  }

  ENABLE_MULTI_DRAW(false)
  RENDINST_INSTANCING()
  SETUP_CHARACTER_MICRODETAIL()
  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)

      float3 diffuseTexcoord        : TEXCOORD0;
      #if HAS_NORMAL
      float3 normal                 : TEXCOORD1;//for normal
      float3 pointToEye             : TEXCOORD2;//for normal
      #endif
      #if COLOR_NEEDED
      float3 colorMul : TEXCOORD3;
      #endif
      VSOUT_DRAW_ID
    };
  }


  hlsl(vs) {

    INSTANCING_BUFFERS

    struct VsInput
    {
      float3 pos                  : POSITION;
      float3 normal               : NORMAL;
      float2 diffuseTexcoord      : TEXCOORD0;
    };

    VsOutput deferred_decal_vs(VsInput input  HW_USE_INSTANCE_ID)
    {
      VsOutput output;

      #if SET_UP_MULTIDRAW
        INIT_MULTIDRAW(output);
        SET_DRAW_CALL_ID(GET_MATERIAL_OFFSET);
      #endif

      float3 localNormal = normalize(BGR_SWIZZLE(input.normal)*2-1);
      float3 localPos = input.pos;
      float opacity = 1;
      VB_PERFORM_INSTANCING

      float3 pointToEye = world_view_pos-worldPos;
      float3 dirToEye = normalize(pointToEye);
      worldPos += dirToEye.xyz * DECAL_TO_CAMERA_OFFSET;

      output.pos = mulPointTm(worldPos + camera_base_offset, globtm);
      output.diffuseTexcoord.xy = input.diffuseTexcoord;
      output.diffuseTexcoord.z = output.pos.w;
      #if HAS_NORMAL
      output.pointToEye = pointToEye;
      output.normal = worldNormal;
      #endif
      #if COLOR_NEEDED
        output.colorMul = 1;
        #if HAS_PAINT_DETAILS
          output.colorMul = getColorMul(hashVal);
        #endif
        #if HAS_OVERLAY_MAP_COLOR
          if (need_overlay_map_color())
            output.colorMul = get_overlay_map_color(worldPos);
        #endif
      #endif

      return output;
    }
  }
  if (shader == rendinst_deferred_decal)
  {
    (ps) { diffuse_tex@static = tex; }
  }
  else if (shader == rendinst_deferred_normal_decal)
  {
    static int writemask = 1904;//(7<<4)|(7<<8) - normal and material properties
    color_write = static writemask;
  }

  blend_asrc = 0; blend_adst = 1;

  if (shader == rendinst_deferred_normal_decal)
  {
    USE_CHARACTER_MICRODETAIL()
  }
  ENABLE_ASSERT(ps)

  if (shader == rendinst_deferred_decal)
  {
    BLEND_DIFFUSE_DECAL_PS(true)
  }
  else if (shader == rendinst_deferred_modulate2x_decal)
  {
    MODULATE_2X_DECAL_PS(true)
  }

  if (shader == rendinst_deferred_normal_decal)
  {
    DEFERRED_DECAL_DEPTH()
    blend_src = sa; blend_dst = isa;

    static float4 nm_met_sm_gamma = (1,1,0,0); //x for normal, y for metalness and smoothness
    (ps) { nm_met_sm_gamma@f2 = nm_met_sm_gamma; }
    if (compatibility_mode == compatibility_mode_on)
    {
      dont_render;//we don't support normal only decals in compatibility
    }

    hlsl(ps) {
      #if HAS_NORMAL
        GBUFFER_OUTPUT deferred_decal_ps(VsOutput input HW_USE_SCREEN_POS)
        {
          #if SET_UP_MULTIDRAW
            SET_DRAW_CALL_ID(GET_MATERIAL_OFFSET(input));
          #endif
          float4 screen = GET_SCREEN_POS(input.pos);
          half4 packedNormalMap = tex2DBindless(get_normal_tex(), input.diffuseTexcoord.xy);

          half smoothness = packedNormalMap.r;
          half metalness = packedNormalMap.b;

          half3 albedo = saturate(abs(packedNormalMap.g - 0.5) * 2 * 10);
          half alpha = 0;
          half3 normalMap = unpack_ag_normal(packedNormalMap);
          half3 vertexNormal = normalize(input.normal);
          half3 worldNormal = perturb_normal_precise(normalMap, vertexNormal, input.pointToEye.xyz, input.diffuseTexcoord.xy );
          BRANCH
          if (character_micro_detail_layer >= 0)
          {
            half reflectance = 0.5;
            apply_character_micro_detail(
              sample_character_micro_detail(input.diffuseTexcoord.xy*get_character_micro_detail_scale().xy, character_micro_detail_layer),
              albedo.rgb, worldNormal, reflectance, smoothness);
          }
          UnpackedGbuffer result;
          init_gbuffer(result);
          init_albedo(result, albedo.rgb);
          init_smoothness(result, smoothness);//
          init_normal(result, worldNormal);
          init_metalness(result, metalness);

          half3 alpha_mask = half3(alpha, get_nm_met_sm_gamma().x < 10 ? pow(alpha, get_nm_met_sm_gamma().x) : 0,
                                          get_nm_met_sm_gamma().y < 10 ? pow(alpha, get_nm_met_sm_gamma().y) : 0);

          alpha_mask *= read_depth_mask(screen.xy, input.diffuseTexcoord.z);
          return encode_gbuffer_alpha3(result, alpha_mask, input.pointToEye, GET_SCREEN_POS(input.pos));
        }
      #else
        float4 deferred_decal_ps(VsOutput input HW_USE_SCREEN_POS):SV_Target0
        {
          return 0;
        }
      #endif
    }
    compile("target_ps", "deferred_decal_ps");
  }

  compile("target_vs", "deferred_decal_vs");
}
