include "sky_shader_global.dshl"
include "pbr.dshl"
include "gbuffer.dshl"
include "monteCarlo.dshl"
include "roughToMip.dshl"
include "ssao_use.dshl"

include "ssr_use.dshl"

include "normaldetail.dshl"
include "viewVecVS.dshl"
include "invGlobTm.dshl"
include "clouds_vars.dshl"
include "sq_clouds_shadow.dshl"
include "static_shadow.dshl"
include "fom_shadows.dshl"
include "use_prefiltered_gf.dshl"
include "contact_shadows.dshl"
include "dagi_quality.dshl"
include "depth_above.dshl"
include "gi_demo.dshl"
include "sparkles.dshl"
include "use_tiled_lights.dshl"
include "vr_reprojection.dshl"
include "gbuffer_resolve_modifier.dshl"
include "ssss/ssss_transmittance_profile.dshl"
include "clustered/simple_point_light.dshl"
include "envi_cover_inc.dshl"
include "water_heightmap.dshl"
include "use_gi.dshl"
include "night_light.dshl"
include "rtao_use.dshl"
include "rtr_use.dshl"
include "rt/rt_underwater_fade_inc.dshl"
include "screen_gi_encoding.dshl"
include "apply_shadow_modifications.dshl"
include "ptgi_use.dshl"

float4 stereo_params = (0, 0, 0, 0);

float4 globtm_no_ofs_psf_0;
float4 globtm_no_ofs_psf_1;
float4 globtm_no_ofs_psf_2;
float4 globtm_no_ofs_psf_3;
texture combined_shadows;
float4 blood_ss_profile = (0.95,0.3,0.25,0);
float4 leaves_ss_profile = (1.0,0.8,0.5,0);
texture specular_tex;
float grass_ambient_ss_shadow = 0.25;

///////////////////////////////////////////////////////////////

texture current_ambient;
texture water_heightmap_lowres;
texture noise_128_tex_hash;

float4 sheen_color = float4(1.0, 1.0, 1.0, 1.0);
float4 lightning_scene_illumination_color = (0.8, 0.8, 0.8, 0);
float4 lightning_scene_illumination_dir = (1.0, 1.0, 1.0, 1.0);
int lightning_scene_illumination = 0;

float4 depth_bounds = float4(0, 1, 0, 0);
int combined_shadows_has_caustics;

float4 tank_cockpit__bsphere = float4(0., 0., 0., 0.);
float tank_cockpit_fake_ambient_light_strength = 0.25;
texture dynamic_lighting_texture;
int has_any_dynamic_lights = 0;
float4 hero_cockpit_vec = (0, 0, 0, 0);
int bvh_usable = 0;

macro COMMON_RESOLVE_SIMPLE(code)
  (code) {
    leaves_ss_profile_gamb@f4 = (leaves_ss_profile.x, leaves_ss_profile.y, leaves_ss_profile.z, grass_ambient_ss_shadow);
    blood_ss_profile@f3 = blood_ss_profile;
    water_heightmap_lowres@smp2d = water_heightmap_lowres;
    water_heightmap_lowres_exists@i1 = exists_tex(water_heightmap_lowres);
    water_level_ocean@f1 = water_level;
    sheen_color@f3 = sheen_color;
    shadow_frame@f1 = shadow_frame;
  }
  INIT_WORLD_TO_WATER_HEIGHTMAP(code)
  hlsl(code) {
    #define leaves_ss_profile (leaves_ss_profile_gamb.xyz)
    #define grass_ambient_ss_shadow (leaves_ss_profile_gamb.w)
    #define sheen_ss_profile (sheen_color.rgb)
    #undef BLOOD_SSS_FACTOR
    #undef LEAVES_SSS_FACTOR
    #undef SHEEN_SSS_FACTOR
    #define BLOOD_SSS_FACTOR blood_ss_profile
    #define LEAVES_SSS_FACTOR leaves_ss_profile
    #define SHEEN_SSS_FACTOR sheen_ss_profile
  }

  INIT_HDR(code)
  USE_HDR(code)
  SHEEN_BRDF_SHADING(code)
  STANDARD_BRDF_SHADING_BASE(code)

  USE_ROUGH_TO_MIP()
  INIT_SKYLIGHT_PARAMS(code)
  USE_SKYLIGHT_PARAMS(code)
  INIT_SKY_DIFFUSE_BASE(code)
  USE_SKY_DIFFUSE_BASE(code)
  INIT_BRUNETON_FOG(code)
  BASE_USE_BRUNETON_FOG(code)
  INIT_ZNZFAR_STAGE(code)
  INIT_AND_USE_NIGHT_LIGHT(code)
endmacro

define_macro_if_not_defined INIT_GBUFFER_MODIFIER(code)
endmacro

define_macro_if_not_defined USE_GBUFFER_MODIFIER(code)
  hlsl(code) {
    void patch_gbuffer(inout ProcessedGbuffer gbuffer, float3 world_pos, float ao) {}
  }
endmacro

macro COMMON_RESOLVE_EXTENDED(code)
  COMMON_RESOLVE_SIMPLE(code)

  GI_DEMO(code)
  INIT_UPSCALE_SAMPLING_BASE(code)
  USE_UPSCALE_SAMPLING_BASE(code)
  INIT_SSAO_BASE(code)
  USE_SSAO_UPSCALE_BASE_WITH_SMP(code, ssao_tex_samplerstate)
  USING_RTAO(code, 3)
  USING_RTR(code)
  INIT_BVH_WATER_FADE_RTR_MATH(code)
  USE_BVH_WATER_FADE_RTR_MATH(code)
  USING_PTGI(code)
  (code) {
    hero_cockpit_vec@f4 = hero_cockpit_vec;
    bvh_usable@i1 = bvh_usable;
  }

  hlsl(code) {
    #define SSR_UPSCALE_MODE SSR_UPSCALE_MISS_HIT_AWARE
    #define getSSAO getSSAOUpscale
  }
  USING_SSR_BASE(code)
  if (gi_quality != off)
  {
    (code) {
      current_ambient@smp2d = current_ambient;
      specular_tex@tex2d = specular_tex;
    }
  } else
  {
    INIT_VR_REPROJECTION(code)
    USE_VR_REPROJECTION(code)
    INIT_LOCAL_SPECULAR_BASE(code)
    USE_SKY_SPECULAR_BASE(code)
  }

  if (dynamic_lights_count != lights_off)
  {
    (code) {
      viewProjectionMatrixNoOfs@f44 = { globtm_no_ofs_psf_0, globtm_no_ofs_psf_1, globtm_no_ofs_psf_2, globtm_no_ofs_psf_3 };
      screen_size@f4 = (1. / screen_pos_to_texcoord.x, 1. / screen_pos_to_texcoord.y, screen_pos_to_texcoord.x, screen_pos_to_texcoord.y);
    }
  }
  (code) {
    combined_shadows@smp2d = combined_shadows;
    combined_shadows_has_caustics@i1 = combined_shadows_has_caustics;
    downsampled_far_depth_tex@smp2d = downsampled_far_depth_tex;
    tank_cockpit_fake_ambient_light_strength@f1 = tank_cockpit_fake_ambient_light_strength;
    tank_cockpit__bsphere@f4 = tank_cockpit__bsphere;
  }

  USE_VOLFOG_DITHERING_NOISE(code)
  CUSTOM_FOG(code)

  INIT_PREINTEGRATED_GF(code)
  BASE_USE_PREINTEGRATED_GF(code)

  hlsl(code) {
    #define OMNI_CONTACT_SHADOWS 1
    #define SPOT_CONTACT_SHADOWS 1
  }
  CONTACT_SHADOWS_BASE(code)

  if (gi_quality == off)
  {
    INIT_ENVI_SPECULAR_SAMPLE(code)
    USE_ENVI_SPECULAR_SAMPLE(code)
  }
  PACK_UNPACK_GBUFFER_BASE(code)

  USE_SSSS_TRANSMITTANCE_PROFILE(code)
  USE_SSSS_TRANSMITTANCE_DECODE(code)

  if (in_editor_assume == no)
  {
    if (dynamic_lighting_texture == NULL)
    {
      INIT_AND_USE_TILED_LIGHTS(code)
    }
    else
    {
      if (dynamic_lights_count != lights_off) {dont_render;}
      (code){
        has_any_dynamic_lights@i1 = has_any_dynamic_lights;
        dynamic_lighting_texture@tex2d = dynamic_lighting_texture;
      }
    }
  }
  else
  {
    INIT_AND_USE_SIMPLE_POINT_LIGHT(code)
  }

  if (gi_quality != off)
  {
    if (gi_quality == only_ao)
    {
      DAGI_SKY_VIS_SAMPLE(code)
      DAGI_NO_SCREEN_ENCODING(code)
    } else if (gi_quality == colored)
    {
      hlsl {
        #define DAGI_IRRADIANCE_GRID_TYPE DAGI_IRRADIANCE_GRID_TYPE_IRRADIANCE
      }
      DAGI_IRRADIANCE_GRID_SAMPLE(code)
      DAGI_NO_SCREEN_ENCODING(code)
    } else
    {
      SAMPLE_IRRADIANCE_SP(code)
      DAGI_GAMMA2_SCREEN_ENCODING(code)
    }
  }

  (code) {
    underwater_fade@f3 = underwater_fade;
    lightning_color@f3 = (lightning_scene_illumination_color);
    lightning_dir@f3 = (lightning_scene_illumination_dir);
    lightning_scene_illumination@i1 = (lightning_scene_illumination);
  }
  INIT_GBUFFER_MODIFIER(code)
  USE_GBUFFER_MODIFIER(code)
endmacro

macro SPECIAL_RESOLVE_EXTENDED(code)
  COMMON_RESOLVE_SIMPLE(code)

  if (dynamic_lights_count != lights_off)
  {
    (code) {
      viewProjectionMatrixNoOfs@f44 = { globtm_no_ofs_psf_0, globtm_no_ofs_psf_1, globtm_no_ofs_psf_2, globtm_no_ofs_psf_3 };
      screen_size@f4 = (1. / screen_pos_to_texcoord.x, 1. / screen_pos_to_texcoord.y, screen_pos_to_texcoord.x, screen_pos_to_texcoord.y);
    }
  }
  PACK_UNPACK_GBUFFER_BASE(code)

  if (in_editor_assume == no)
  {
    INIT_AND_USE_TILED_LIGHTS(code)
  }
  else
  {
    INIT_AND_USE_SIMPLE_POINT_LIGHT(code)
  }
endmacro

macro USE_DEFERRED_SHADOW_PER_SAMPLE(code)
  assume_if_not_assumed use_contact_shadows = use_shadows;

  USE_SHADOW_MODIFICATIONS(code)
  hlsl(code) {
    #define __XBOX_WAVESIM_ITERATION 1
    #define __XBOX_IMPROVE_MAD 1

    #include "noise/Perlin3D.hlsl"

    half3 MultiBounce(half AO, half3 Albedo)
    {
      half3 A = 2 * Albedo - 0.33;
      half3 B = -4.8 * Albedo + 0.64;
      half3 C = 2.75 * Albedo + 0.69;
      return max(AO, ((AO * A + B) * AO + C) * AO);
    }

    void get_combined_shadows_sample(float2 uv, out float csmShadow, out float ssssTransmittance, out float base_caustics, out float cloudShadow)
    {
      ##if (combined_shadows == NULL) && (in_editor_assume == yes)
        csmShadow = 1;
        ssssTransmittance = base_caustics = cloudShadow = 0;
      ##else
        float4 sampledValues = tex2Dlod(combined_shadows, float4(uv, 0, 0));
        csmShadow = sampledValues.x;
        ##if use_ssss != off
          ssssTransmittance = decode_ssss_transmittance(sampledValues.y);
        ##else
          ssssTransmittance = 0;
        ##endif
        base_caustics = combined_shadows_has_caustics ? sampledValues.z : 0;
        cloudShadow = combined_shadows_has_caustics ? sampledValues.w : 0;
      ##endif
    }

    float2 resolve_caustics(float base_caustics, float3 worldPos, float water_level)
    {
      base_caustics = pow2(base_caustics);
      half2 caustics=half2(1, 0); // underwater and upperwater components
      float causticScale=saturate(water_level-worldPos.y-0.3);
      caustics.x=lerp(1, 0.2+base_caustics*3.8, causticScale); // underwater multiplier
      causticScale=saturate(2*(water_level-worldPos.y+0.5));
      caustics.y=lerp(base_caustics*2, 0, causticScale);  // additive
      return caustics;
    }

    half4 deferred_shadow_per_sample(float2 screenpos, float3 viewVect, float2 curViewTc, float3 pointToEye, float4 worldPos, float w,
                                     ProcessedGbuffer gbuffer, float rawDepth)
    {
      float distSq = dot(pointToEye,pointToEye);
      float invRsqrt = rsqrt(distSq);
      float3 view  = pointToEye*invRsqrt;
      float dist = rcp(invRsqrt);

      // Translucency is used to store SSS eye fake shadow mask, so we must assume SSS eye material to have 0 translucency.
      half sssEyeFakeShadowMask = gbuffer.translucency;

      float4 weights = sampleCloseUpscaleWeight(screenpos);
      SSAO_TYPE ssao = getSSAOUpscaleWeighted(weights, screenpos);
      half4 ssrReflections = getSSRWeighted(gbuffer.linearRoughness, curViewTc, screenpos, weights);

      half cockpitFade = half(saturate(dot(float4(worldPos.xyz, 1), hero_cockpit_vec)));

      if (isRTAOEnabled()  && bvh_usable)
      {
        float rtao = getRTAO(uint2(screenpos));
        if (gbuffer.isHeroCockpit)
        {
          ssao.x = lerp(rtao, 1, cockpitFade);
          ssao.y = lerp(ssao. CONTACT_SHADOWS_ATTR, 1, cockpitFade);
        }
        else
          ssao.x = rtao;
      }

      patch_gbuffer(gbuffer, worldPos.xyz, ssao.x);

      float geometryFactor = 1;

      half translucencyStrength = isTranslucentProfileValid(gbuffer.sss_profile) ? gbuffer.translucency : 0;

      // zero and disabled if not subsurface and sss profile is not cloth, see processGbuffer
      float sheenStrength = gbuffer.sheen;
      float3 sheenColor = gbuffer.translucencyColor;

      float NdotV = dot(gbuffer.normal, view);
      float saturated_NdotV = saturate(NdotV);
      float3 reflectionVec = 2 * NdotV * gbuffer.normal - view;
      float NoV = abs( NdotV ) + 1e-5;
      float ggx_alpha = gbuffer.ggx_alpha;

      half enviAO = gbuffer.ao*ssao.x;//we still modulate by albedo color, so we don't need micro AO

      half specularAOcclusion = computeSpecOcclusion(saturate(NdotV), enviAO, ggx_alpha);// dice spec occlusion
      half3 specularColor = gbuffer.specularColor*specularAOcclusion;
      //SUN
      float3 lightDir = -from_sun_direction.xyz;
      half3 lightColor = sun_color_0.rgb;

      float3 verticalUnderwaterMul = float3(1.0, 1.0, 1.0);
      float water_level = water_level_ocean;
      if (water_heightmap_lowres_exists)
      {
        float2 water_heightmap_lowres_uv = worldPos.xz * world_to_water_heightmap.zw + world_to_water_heightmap.xy;
        water_level = tex2Dlod(water_heightmap_lowres, float4(water_heightmap_lowres_uv, 0, 0)).r;
      }
      FLATTEN
      if (water_level > worldPos.y)
      {
        float3 fadeExponent = underwater_fade * (worldPos.y - water_level);
        lightColor *= exp(fadeExponent / max(0.001, lightDir.y));
        verticalUnderwaterMul = exp(fadeExponent);
      }

      float NoL = dot(gbuffer.normal, lightDir);
      half3 result = 0;
      bool isValidSubsurface = isSubSurfaceShader(gbuffer.material) && isTranslucentProfileValid(gbuffer.sss_profile);

      float csmShadow, ssssTransmittance, base_caustics, cloudShadow;
      get_combined_shadows_sample(curViewTc, csmShadow, ssssTransmittance, base_caustics, cloudShadow);

      FLATTEN
      if (!isValidSubsurface)
        gbuffer.shadow *= calc_micro_shadow(NoL, gbuffer.ao);
      csmShadow = min(csmShadow, gbuffer.shadow);
      half SSSshadow = csmShadow;

      ##if ssao_contact_shadows
      half contactShadows = ssao. CONTACT_SHADOWS_ATTR;
      csmShadow *= lerp(contactShadows*contactShadows, contactShadows, translucencyStrength);
      SSSshadow *= lerp(contactShadows, contactShadows*0.75 + 0.25, translucencyStrength);
      ##endif

      half shadow = apply_shadow_modifications(csmShadow, NoL);
      //if ssr disabled, envi probe reflection should be dimmed when objects are in shadow
      ##if ssr_target == NULL
        #define MIN_ENVI_SSR 0.25
        half enviSSR = MIN_ENVI_SSR + shadow * (1 - MIN_ENVI_SSR);
      ##else
        half enviSSR = (1-ssrReflections.a);
      ##endif

      float2 caustics = resolve_caustics(base_caustics, worldPos.xyz, water_level);

      //SUN
      BRANCH
      if (shadow > 0)
      {
        result = standardBRDF( NoV, NoL, gbuffer.diffuseColor, ggx_alpha, gbuffer.linearRoughness, gbuffer.specularColor, gbuffer.extracted_albedo_ao, lightDir, view, gbuffer.normal, sheenColor, sheenStrength)*(shadow)*lightColor*caustics.x;
        float lightningNoL = dot(gbuffer.normal, lightning_dir);
        BRANCH
        if (lightning_scene_illumination && lightningNoL > 0)
        {
          result += standardBRDF( NoV, lightningNoL, gbuffer.diffuseColor, ggx_alpha, gbuffer.linearRoughness, gbuffer.specularColor, gbuffer.extracted_albedo_ao, lightning_dir, view, gbuffer.normal, sheenColor, sheenStrength)*(shadow)*lightning_color;
        }
      }
      ##if dynamic_lighting_texture == NULL || in_editor_assume == yes
        result += get_dynamic_lighting(gbuffer, worldPos.xyz, -viewVect, w, screenpos, NoV, specularColor, curViewTc, enviAO);
      ##else
        if (has_any_dynamic_lights)
          result += texelFetch(dynamic_lighting_texture, screenpos, 0).rgb;
      ##endif
      result += gbuffer.diffuseColor*caustics.y*lightColor*cloudShadow*pow3(saturate(enviAO*1.3));
      //SUN-

      //envi
      float3 lightProbeReflectionVec = reflectionVec;
      half3 AB = getEnviBRDF_AB_LinearRoughness(gbuffer.linearRoughness, NoV);
      half3 enviBRDF = gbuffer.specularColor * AB.x + saturate( 50 * gbuffer.specularColor.g ) * AB.y;

      float3 enviLightingNormal = normalize(getDiffuseDominantDir(gbuffer.normal, view, saturated_NdotV, ggx_alpha ));
      float fake_light_strength = 0.25;
      ##if (gi_quality != off)
        half3 enviLight, giSpecular;
        decode_gi_colors(texelFetch(current_ambient, screenpos, 0). GI_ENCODED_ATTR, texelFetch(specular_tex, screenpos, 0). GI_ENCODED_ATTR, enviLight, giSpecular);
        enviLight = unpack_hdr(enviLight);
        giSpecular = unpack_hdr(giSpecular);
      ##endif
      ##if (gi_quality == off)
        half3 enviLight = GetSkySHDiffuse(enviLightingNormal);
      ##endif

      float distToTankCockpitSq = dot(tank_cockpit__bsphere.xyz - worldPos.xyz, tank_cockpit__bsphere.xyz - worldPos.xyz);
      float fragmentNotInCockpit = float(distToTankCockpitSq >= tank_cockpit__bsphere.w);
      enviLight *= fragmentNotInCockpit;
      fake_light_strength *= fragmentNotInCockpit;
      fake_light_strength += tank_cockpit_fake_ambient_light_strength * (1. - fragmentNotInCockpit);

      enviLight *= enviAO;
      if (isPTGIEnabled() && bvh_usable)
      {
        half3 ptgi = half3(getPTGI(curViewTc, w));
        if (gbuffer.isHeroCockpit)
          enviLight = lerp(ptgi, enviLight, cockpitFade);
        else {
          // PTGI does not need additional AO
          enviLight = ptgi;
        }
      }

      half3 environmentAmbientLighting =  enviLight * gbuffer.diffuseColor;
      //use albedo instead of diffuseColor, so fake light affects metal
      environmentAmbientLighting += enviAO * fakeNightLight(gbuffer.albedo, fake_light_strength*(1-gbuffer.metalness*(1-gbuffer.linearRoughness)), saturated_NdotV, distSq);

      //from GTAO paper. Result doesn't seem to be correct (too bright).
      // If we square ssao, result is also incorrect (dark places become too dark)
      //use SSGI instead.
      //half3 environmentAmbientLighting = (geometryFactor*gbuffer.ao) * MultiBounce(ssao.x, gbuffer.diffuseColor)*environmentAmbientUnoccludedLighting;
      environmentAmbientLighting = (AB.z * geometryFactor)*environmentAmbientLighting;
      ##if (gi_quality != off)
        half3 totalReflection = (giSpecular*(specularAOcclusion*enviSSR) + ssrReflections.rgb)*enviBRDF;
      ##else
        float3 roughR = getRoughReflectionVec(lightProbeReflectionVec.xyz, gbuffer.normal, ggx_alpha);
        float roughMip = ComputeReflectionCaptureMipFromRoughness(gbuffer.linearRoughness);
        half3 environmentAmbientReflection = sample_envi_probe(float4(roughR, roughMip)).rgb;
        half3 totalReflection = (environmentAmbientReflection*enviSSR*specularAOcclusion + ssrReflections.rgb)*enviBRDF;//enviBRDF
      ##endif

      if (isRTREnabled() && bvh_usable)
      {
        half3 rtr = getRTRFiltered(uint2(screenpos)) * enviBRDF;
        half underwaterComponent = calc_underwater_fade_rtr(worldPos.y - water_level);
        half cockpit = gbuffer.isHeroCockpit ? 1-cockpitFade : 1;
        half s = cockpit * underwaterComponent;
        totalReflection = lerp(totalReflection, rtr, s);
      }


      bool isTranslucent =
        (isFoliageShader(gbuffer.material) || (isSubSurfaceShader(gbuffer.material) && gbuffer.sss_profile == SSS_PROFILE_NEUTRAL_TRANSLUCENT)) &&
        translucencyStrength > 1.0/255;

      BRANCH
      if (gbuffer.material == SHADING_SUBSURFACE && isSubSurfaceProfileValid(gbuffer.sss_profile))
      {
        ##if use_ssss != off
          result += gbuffer.diffuseColor * lightColor * ssss_get_profiled_transmittance(gbuffer.normal, lightDir, ssssTransmittance);
        ##endif
      }
      else if (isTranslucent)
      {
        if ((SSSshadow > 0))
        {
          result += (gbuffer.ao * foliageSSS(NoL, view, lightDir) * SSSshadow) * lightColor * gbuffer.translucencyColor;
        }
        half3 backAmbientLight = GetSkySHDiffuse(-gbuffer.normal);
        half3 giBackAmbient = backAmbientLight;
        half giAmount = 1;
        ##if (gi_quality == screen_probes)
          sample_bilinear_irradiance_envi_normal(-gbuffer.normal, w, worldPos.xyz, gbuffer.normal, screenpos, giBackAmbient);
        ##elif (gi_quality == colored)
          float ofs = max(dist*0.04, 0.25*dagi_irrad_grid_probe_size(0));
          float3 filteredWorldPos = worldPos.xyz + view*ofs;
          giAmount = dagi_irrad_grid_diffuse_biased_smooth(world_view_pos.xyz, filteredWorldPos, -gbuffer.normal, view, max(0, dist-ofs), gbuffer.normal, 0, giBackAmbient);
          //ambient = volumetric_gi_calc_diffuse_uvw(input.texcoord.xy, 0.95*w, enviLightingNormal);
        ##elif (gi_quality == only_ao)
          float ofs = max(dist*0.04, 0.25*dagi_sky_vis_probe_size(0));
          float3 filteredWorldPos = worldPos.xyz + view*ofs;
          float4 sh1 = dagi_get_sky_visibility_smooth_sh1(world_view_pos.xyz, filteredWorldPos, view, max(0, dist-ofs), gbuffer.normal, 0 );
          giAmount = 0;
          if (all(sh1 != 1))
          {
            giBackAmbient = GetSHFunctionValueSimple(enviLightingNormal, enviSPH0*sh1.wyzx, enviSPH1*sh1.wyzx, enviSPH2*sh1.wyzx);
            giAmount = 1;
          }
        ##endif
        backAmbientLight = giBackAmbient * skylight_gi_weight_atten;
        environmentAmbientLighting += enviAO*backAmbientLight*gbuffer.translucencyColor;
      }

      //half3 reflection = totalReflection+environmentAmbientLighting;//correct
      half3 reflection = (environmentAmbientLighting + totalReflection) * verticalUnderwaterMul;//*enviAO - tri-ace formula
      //return reflection.rgbr;
      //half3 reflection = totalReflection+environmentAmbientLighting;//correct
      result += reflection;

      // We apply additional ao for a final color (except emission and fog) for eyes.
      // This approach is not physically correct.
      // It makes an image more realistic and eyes don't look too bright.
      // It also could be done with additional contact shadows pass, but it is more difficult way.
      // This effect has to be reduced at some distance, otherwise, AO due to objects at the front can make eyes appear to be black.
      // The effect reduction happens linearly to avoid sudden change in eyes appearance.
      // Also, to avoid sharp changes with emissive eye material (eg. for caustics), its effect is masked where the material changes.
      if (gbuffer.sss_profile == SSS_PROFILE_EYES)
      {
        // PTGI forces low SSAO qulity so that it is better to hack it with a constant.
        half effectiveEyeSsao = 0.25f;
        if (!isPTGIEnabled())
          effectiveEyeSsao = lerp(pow2(ssao.x), ssao.x, saturate(w - 0.5));
        result *= lerp(effectiveEyeSsao, 1, sssEyeFakeShadowMask);
      }

      result += gbuffer.emissionColor;

      //envi-

      float2 jitteredVolfogTc = get_volfog_dithered_screen_tc(screenpos.xy, curViewTc);
      apply_volfog_with_scattering(result.rgb, curViewTc, jitteredVolfogTc, view, dist, w);
      return half4(pack_hdr(result),1);
    }
  }
endmacro
