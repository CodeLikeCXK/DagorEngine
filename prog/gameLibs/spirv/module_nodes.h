// Copyright (C) Gaijin Games KFT.  All rights reserved.

// auto generated, do not modify!
#pragma once
#include "../publicInclude/spirv/traits_table.h"
namespace spirv
{ // some in memory node declarations
enum class NodeKind
{
  Action,
  BinaryAction,
  BinaryOperation,
  Block,
  BlockEnd,
  Branch,
  Constant,
  ConstantComposite,
  ConstantSampler,
  Exit,
  Function,
  FunctionCall,
  GroupedAction,
  GroupedOperation,
  Id,
  ImageAction,
  ImageOperation,
  MultinaryAction,
  MultinaryOperation,
  Node,
  Operation,
  Phi,
  Return,
  ScopedAction,
  ScopedOperation,
  SpecConstant,
  SpecConstantComposite,
  SpecConstantOperation,
  Switch,
  TrinaryAction,
  TrinaryOperation,
  Typedef,
  UnaryAction,
  UnaryOperation,
  Variable
};
struct NodeAction;
struct NodeBinaryAction;
struct NodeBinaryOperation;
struct NodeBlock;
struct NodeBlockEnd;
struct NodeBranch;
struct NodeConstant;
struct NodeConstantComposite;
struct NodeConstantSampler;
struct NodeExit;
struct NodeFunction;
struct NodeFunctionCall;
struct NodeGroupedAction;
struct NodeGroupedOperation;
struct NodeId;
struct NodeImageAction;
struct NodeImageOperation;
struct NodeMultinaryAction;
struct NodeMultinaryOperation;
struct Node;
struct NodeOperation;
struct NodePhi;
struct NodeReturn;
struct NodeScopedAction;
struct NodeScopedOperation;
struct NodeSpecConstant;
struct NodeSpecConstantComposite;
struct NodeSpecConstantOperation;
struct NodeSwitch;
struct NodeTrinaryAction;
struct NodeTrinaryOperation;
struct NodeTypedef;
struct NodeUnaryAction;
struct NodeUnaryOperation;
struct NodeVariable;
struct NodePairIdRefIdRef
{
  NodePointer<NodeId> first;
  NodePointer<NodeId> second;
};
struct NodePairIdRefLiteralInteger
{
  NodePointer<NodeId> first;
  LiteralInteger second;
};
struct NodePairLiteralIntegerIdRef
{
  LiteralInteger first;
  NodePointer<NodeId> second;
};
// node properties
struct Property
{
  Decoration type;
  template <typename T>
  static constexpr bool is(T *)
  {
    return true;
  }
};
// Debug names are stored as a property
constexpr Decoration DecorationName = static_cast<Decoration>(0x7FFFFFFF);
struct PropertyName
{
  const Decoration type = DecorationName;
  eastl::optional<Id> memberIndex;
  eastl::string name;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == DecorationName;
  }
  template <typename N, typename T>
  void write(N node, T &target) const;
  CastableUniquePointer<PropertyName> clone() const
  {
    CastableUniquePointer<PropertyName> result{new PropertyName};
    result->memberIndex = memberIndex;
    result->name = name;
    return result;
  }
  auto cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    auto v = clone();
    v->memberIndex = i.value;
    return v;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
// This property marks a pointer type that requires a forward declaration to break type declaration cycles
constexpr Decoration DecorationForwardDeclaration = static_cast<Decoration>(0x7FFFFFFE);
struct PropertyForwardDeclaration
{
  const Decoration type = DecorationForwardDeclaration;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == DecorationForwardDeclaration;
  }
  template <typename N, typename T>
  void write(N node, T &target) const;
  CastableUniquePointer<PropertyForwardDeclaration> clone() const
  {
    CastableUniquePointer<PropertyForwardDeclaration> result{new PropertyForwardDeclaration};
    return result;
  }
  auto cloneWithMemberIndexOverride(LiteralInteger) const { return clone(); }
  template <typename T>
  void visitRefs(T)
  {}
};
// This property marks conditional branches and switches with their merge block
constexpr Decoration DecorationSelectionMerge = static_cast<Decoration>(0x7FFFFFFD);
struct PropertySelectionMerge
{
  const Decoration type = DecorationSelectionMerge;
  NodePointer<NodeBlock> mergeBlock;
  SelectionControlMask controlMask;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == DecorationSelectionMerge;
  }
  template <typename N, typename T>
  void write(N, T &target) const;
  CastableUniquePointer<PropertySelectionMerge> clone() const
  {
    CastableUniquePointer<PropertySelectionMerge> result{new PropertySelectionMerge};
    result->mergeBlock = mergeBlock;
    result->controlMask = controlMask;
    return result;
  }
  auto cloneWithMemberIndexOverride(LiteralInteger) const { return clone(); }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(mergeBlock);
  }
};
// This property marks the initial branch of a loop with its merge and continue block
constexpr Decoration DecorationLoopMerge = static_cast<Decoration>(0x7FFFFFFC);
struct PorpertyLoopMerge
{
  const Decoration type = DecorationLoopMerge;
  NodePointer<NodeBlock> mergeBlock;
  NodePointer<NodeBlock> continueBlock;
  LoopControlMask controlMask;
  LiteralInteger dependencyLength;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == DecorationLoopMerge;
  }
  template <typename N, typename T>
  void write(N, T &target) const;
  CastableUniquePointer<PorpertyLoopMerge> clone() const
  {
    CastableUniquePointer<PorpertyLoopMerge> result{new PorpertyLoopMerge};
    result->mergeBlock = mergeBlock;
    result->continueBlock = continueBlock;
    result->controlMask = controlMask;
    result->dependencyLength = dependencyLength;
    return result;
  }
  auto cloneWithMemberIndexOverride(LiteralInteger) const { return clone(); }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(continueBlock);
    visitor(mergeBlock);
  }
};
struct PropertyRelaxedPrecision
{
  const Decoration type = Decoration::RelaxedPrecision;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::RelaxedPrecision;
  }
  CastableUniquePointer<PropertyRelaxedPrecision> clone() const
  {
    CastableUniquePointer<PropertyRelaxedPrecision> result //
      {new PropertyRelaxedPrecision};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRelaxedPrecision> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRelaxedPrecision> result //
      {new PropertyRelaxedPrecision};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySpecId
{
  const Decoration type = Decoration::SpecId;
  eastl::optional<Id> memberIndex;
  LiteralInteger specializationConstantId;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SpecId;
  }
  CastableUniquePointer<PropertySpecId> clone() const
  {
    CastableUniquePointer<PropertySpecId> result //
      {new PropertySpecId};
    result->memberIndex = memberIndex;
    result->specializationConstantId = specializationConstantId;
    return result;
  }
  CastableUniquePointer<PropertySpecId> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySpecId> result //
      {new PropertySpecId};
    result->memberIndex = i.value;
    result->specializationConstantId = specializationConstantId;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBlock
{
  const Decoration type = Decoration::Block;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Block;
  }
  CastableUniquePointer<PropertyBlock> clone() const
  {
    CastableUniquePointer<PropertyBlock> result //
      {new PropertyBlock};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBlock> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBlock> result //
      {new PropertyBlock};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBufferBlock
{
  const Decoration type = Decoration::BufferBlock;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BufferBlock;
  }
  CastableUniquePointer<PropertyBufferBlock> clone() const
  {
    CastableUniquePointer<PropertyBufferBlock> result //
      {new PropertyBufferBlock};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBufferBlock> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBufferBlock> result //
      {new PropertyBufferBlock};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyRowMajor
{
  const Decoration type = Decoration::RowMajor;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::RowMajor;
  }
  CastableUniquePointer<PropertyRowMajor> clone() const
  {
    CastableUniquePointer<PropertyRowMajor> result //
      {new PropertyRowMajor};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRowMajor> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRowMajor> result //
      {new PropertyRowMajor};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyColMajor
{
  const Decoration type = Decoration::ColMajor;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ColMajor;
  }
  CastableUniquePointer<PropertyColMajor> clone() const
  {
    CastableUniquePointer<PropertyColMajor> result //
      {new PropertyColMajor};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyColMajor> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyColMajor> result //
      {new PropertyColMajor};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyArrayStride
{
  const Decoration type = Decoration::ArrayStride;
  eastl::optional<Id> memberIndex;
  LiteralInteger arrayStride;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ArrayStride;
  }
  CastableUniquePointer<PropertyArrayStride> clone() const
  {
    CastableUniquePointer<PropertyArrayStride> result //
      {new PropertyArrayStride};
    result->memberIndex = memberIndex;
    result->arrayStride = arrayStride;
    return result;
  }
  CastableUniquePointer<PropertyArrayStride> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyArrayStride> result //
      {new PropertyArrayStride};
    result->memberIndex = i.value;
    result->arrayStride = arrayStride;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMatrixStride
{
  const Decoration type = Decoration::MatrixStride;
  eastl::optional<Id> memberIndex;
  LiteralInteger matrixStride;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MatrixStride;
  }
  CastableUniquePointer<PropertyMatrixStride> clone() const
  {
    CastableUniquePointer<PropertyMatrixStride> result //
      {new PropertyMatrixStride};
    result->memberIndex = memberIndex;
    result->matrixStride = matrixStride;
    return result;
  }
  CastableUniquePointer<PropertyMatrixStride> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMatrixStride> result //
      {new PropertyMatrixStride};
    result->memberIndex = i.value;
    result->matrixStride = matrixStride;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyGLSLShared
{
  const Decoration type = Decoration::GLSLShared;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::GLSLShared;
  }
  CastableUniquePointer<PropertyGLSLShared> clone() const
  {
    CastableUniquePointer<PropertyGLSLShared> result //
      {new PropertyGLSLShared};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyGLSLShared> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyGLSLShared> result //
      {new PropertyGLSLShared};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyGLSLPacked
{
  const Decoration type = Decoration::GLSLPacked;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::GLSLPacked;
  }
  CastableUniquePointer<PropertyGLSLPacked> clone() const
  {
    CastableUniquePointer<PropertyGLSLPacked> result //
      {new PropertyGLSLPacked};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyGLSLPacked> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyGLSLPacked> result //
      {new PropertyGLSLPacked};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCPacked
{
  const Decoration type = Decoration::CPacked;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::CPacked;
  }
  CastableUniquePointer<PropertyCPacked> clone() const
  {
    CastableUniquePointer<PropertyCPacked> result //
      {new PropertyCPacked};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyCPacked> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCPacked> result //
      {new PropertyCPacked};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBuiltIn
{
  const Decoration type = Decoration::BuiltIn;
  eastl::optional<Id> memberIndex;
  BuiltIn builtIn;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BuiltIn;
  }
  CastableUniquePointer<PropertyBuiltIn> clone() const
  {
    CastableUniquePointer<PropertyBuiltIn> result //
      {new PropertyBuiltIn};
    result->memberIndex = memberIndex;
    result->builtIn = builtIn;
    return result;
  }
  CastableUniquePointer<PropertyBuiltIn> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBuiltIn> result //
      {new PropertyBuiltIn};
    result->memberIndex = i.value;
    result->builtIn = builtIn;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNoPerspective
{
  const Decoration type = Decoration::NoPerspective;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NoPerspective;
  }
  CastableUniquePointer<PropertyNoPerspective> clone() const
  {
    CastableUniquePointer<PropertyNoPerspective> result //
      {new PropertyNoPerspective};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNoPerspective> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNoPerspective> result //
      {new PropertyNoPerspective};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFlat
{
  const Decoration type = Decoration::Flat;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Flat;
  }
  CastableUniquePointer<PropertyFlat> clone() const
  {
    CastableUniquePointer<PropertyFlat> result //
      {new PropertyFlat};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyFlat> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFlat> result //
      {new PropertyFlat};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPatch
{
  const Decoration type = Decoration::Patch;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Patch;
  }
  CastableUniquePointer<PropertyPatch> clone() const
  {
    CastableUniquePointer<PropertyPatch> result //
      {new PropertyPatch};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPatch> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPatch> result //
      {new PropertyPatch};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCentroid
{
  const Decoration type = Decoration::Centroid;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Centroid;
  }
  CastableUniquePointer<PropertyCentroid> clone() const
  {
    CastableUniquePointer<PropertyCentroid> result //
      {new PropertyCentroid};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyCentroid> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCentroid> result //
      {new PropertyCentroid};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySample
{
  const Decoration type = Decoration::Sample;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Sample;
  }
  CastableUniquePointer<PropertySample> clone() const
  {
    CastableUniquePointer<PropertySample> result //
      {new PropertySample};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySample> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySample> result //
      {new PropertySample};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyInvariant
{
  const Decoration type = Decoration::Invariant;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Invariant;
  }
  CastableUniquePointer<PropertyInvariant> clone() const
  {
    CastableUniquePointer<PropertyInvariant> result //
      {new PropertyInvariant};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyInvariant> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyInvariant> result //
      {new PropertyInvariant};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyRestrict
{
  const Decoration type = Decoration::Restrict;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Restrict;
  }
  CastableUniquePointer<PropertyRestrict> clone() const
  {
    CastableUniquePointer<PropertyRestrict> result //
      {new PropertyRestrict};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRestrict> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRestrict> result //
      {new PropertyRestrict};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyAliased
{
  const Decoration type = Decoration::Aliased;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Aliased;
  }
  CastableUniquePointer<PropertyAliased> clone() const
  {
    CastableUniquePointer<PropertyAliased> result //
      {new PropertyAliased};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyAliased> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyAliased> result //
      {new PropertyAliased};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyVolatile
{
  const Decoration type = Decoration::Volatile;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Volatile;
  }
  CastableUniquePointer<PropertyVolatile> clone() const
  {
    CastableUniquePointer<PropertyVolatile> result //
      {new PropertyVolatile};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyVolatile> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyVolatile> result //
      {new PropertyVolatile};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyConstant
{
  const Decoration type = Decoration::Constant;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Constant;
  }
  CastableUniquePointer<PropertyConstant> clone() const
  {
    CastableUniquePointer<PropertyConstant> result //
      {new PropertyConstant};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyConstant> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyConstant> result //
      {new PropertyConstant};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCoherent
{
  const Decoration type = Decoration::Coherent;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Coherent;
  }
  CastableUniquePointer<PropertyCoherent> clone() const
  {
    CastableUniquePointer<PropertyCoherent> result //
      {new PropertyCoherent};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyCoherent> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCoherent> result //
      {new PropertyCoherent};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNonWritable
{
  const Decoration type = Decoration::NonWritable;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NonWritable;
  }
  CastableUniquePointer<PropertyNonWritable> clone() const
  {
    CastableUniquePointer<PropertyNonWritable> result //
      {new PropertyNonWritable};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNonWritable> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNonWritable> result //
      {new PropertyNonWritable};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNonReadable
{
  const Decoration type = Decoration::NonReadable;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NonReadable;
  }
  CastableUniquePointer<PropertyNonReadable> clone() const
  {
    CastableUniquePointer<PropertyNonReadable> result //
      {new PropertyNonReadable};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNonReadable> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNonReadable> result //
      {new PropertyNonReadable};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyUniform
{
  const Decoration type = Decoration::Uniform;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Uniform;
  }
  CastableUniquePointer<PropertyUniform> clone() const
  {
    CastableUniquePointer<PropertyUniform> result //
      {new PropertyUniform};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyUniform> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyUniform> result //
      {new PropertyUniform};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyUniformId
{
  const Decoration type = Decoration::UniformId;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeOperation> execution;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::UniformId;
  }
  CastableUniquePointer<PropertyUniformId> clone() const
  {
    CastableUniquePointer<PropertyUniformId> result //
      {new PropertyUniformId};
    result->memberIndex = memberIndex;
    result->execution = execution;
    return result;
  }
  CastableUniquePointer<PropertyUniformId> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyUniformId> result //
      {new PropertyUniformId};
    result->memberIndex = i.value;
    result->execution = execution;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
  }
};
struct PropertySaturatedConversion
{
  const Decoration type = Decoration::SaturatedConversion;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SaturatedConversion;
  }
  CastableUniquePointer<PropertySaturatedConversion> clone() const
  {
    CastableUniquePointer<PropertySaturatedConversion> result //
      {new PropertySaturatedConversion};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySaturatedConversion> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySaturatedConversion> result //
      {new PropertySaturatedConversion};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStream
{
  const Decoration type = Decoration::Stream;
  eastl::optional<Id> memberIndex;
  LiteralInteger streamNumber;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Stream;
  }
  CastableUniquePointer<PropertyStream> clone() const
  {
    CastableUniquePointer<PropertyStream> result //
      {new PropertyStream};
    result->memberIndex = memberIndex;
    result->streamNumber = streamNumber;
    return result;
  }
  CastableUniquePointer<PropertyStream> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStream> result //
      {new PropertyStream};
    result->memberIndex = i.value;
    result->streamNumber = streamNumber;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyLocation
{
  const Decoration type = Decoration::Location;
  eastl::optional<Id> memberIndex;
  LiteralInteger location;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Location;
  }
  CastableUniquePointer<PropertyLocation> clone() const
  {
    CastableUniquePointer<PropertyLocation> result //
      {new PropertyLocation};
    result->memberIndex = memberIndex;
    result->location = location;
    return result;
  }
  CastableUniquePointer<PropertyLocation> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyLocation> result //
      {new PropertyLocation};
    result->memberIndex = i.value;
    result->location = location;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyComponent
{
  const Decoration type = Decoration::Component;
  eastl::optional<Id> memberIndex;
  LiteralInteger component;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Component;
  }
  CastableUniquePointer<PropertyComponent> clone() const
  {
    CastableUniquePointer<PropertyComponent> result //
      {new PropertyComponent};
    result->memberIndex = memberIndex;
    result->component = component;
    return result;
  }
  CastableUniquePointer<PropertyComponent> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyComponent> result //
      {new PropertyComponent};
    result->memberIndex = i.value;
    result->component = component;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyIndex
{
  const Decoration type = Decoration::Index;
  eastl::optional<Id> memberIndex;
  LiteralInteger index;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Index;
  }
  CastableUniquePointer<PropertyIndex> clone() const
  {
    CastableUniquePointer<PropertyIndex> result //
      {new PropertyIndex};
    result->memberIndex = memberIndex;
    result->index = index;
    return result;
  }
  CastableUniquePointer<PropertyIndex> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyIndex> result //
      {new PropertyIndex};
    result->memberIndex = i.value;
    result->index = index;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBinding
{
  const Decoration type = Decoration::Binding;
  eastl::optional<Id> memberIndex;
  LiteralInteger bindingPoint;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Binding;
  }
  CastableUniquePointer<PropertyBinding> clone() const
  {
    CastableUniquePointer<PropertyBinding> result //
      {new PropertyBinding};
    result->memberIndex = memberIndex;
    result->bindingPoint = bindingPoint;
    return result;
  }
  CastableUniquePointer<PropertyBinding> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBinding> result //
      {new PropertyBinding};
    result->memberIndex = i.value;
    result->bindingPoint = bindingPoint;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyDescriptorSet
{
  const Decoration type = Decoration::DescriptorSet;
  eastl::optional<Id> memberIndex;
  LiteralInteger descriptorSet;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::DescriptorSet;
  }
  CastableUniquePointer<PropertyDescriptorSet> clone() const
  {
    CastableUniquePointer<PropertyDescriptorSet> result //
      {new PropertyDescriptorSet};
    result->memberIndex = memberIndex;
    result->descriptorSet = descriptorSet;
    return result;
  }
  CastableUniquePointer<PropertyDescriptorSet> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyDescriptorSet> result //
      {new PropertyDescriptorSet};
    result->memberIndex = i.value;
    result->descriptorSet = descriptorSet;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyOffset
{
  const Decoration type = Decoration::Offset;
  eastl::optional<Id> memberIndex;
  LiteralInteger byteOffset;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Offset;
  }
  CastableUniquePointer<PropertyOffset> clone() const
  {
    CastableUniquePointer<PropertyOffset> result //
      {new PropertyOffset};
    result->memberIndex = memberIndex;
    result->byteOffset = byteOffset;
    return result;
  }
  CastableUniquePointer<PropertyOffset> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyOffset> result //
      {new PropertyOffset};
    result->memberIndex = i.value;
    result->byteOffset = byteOffset;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyXfbBuffer
{
  const Decoration type = Decoration::XfbBuffer;
  eastl::optional<Id> memberIndex;
  LiteralInteger xfbBufferNumber;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::XfbBuffer;
  }
  CastableUniquePointer<PropertyXfbBuffer> clone() const
  {
    CastableUniquePointer<PropertyXfbBuffer> result //
      {new PropertyXfbBuffer};
    result->memberIndex = memberIndex;
    result->xfbBufferNumber = xfbBufferNumber;
    return result;
  }
  CastableUniquePointer<PropertyXfbBuffer> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyXfbBuffer> result //
      {new PropertyXfbBuffer};
    result->memberIndex = i.value;
    result->xfbBufferNumber = xfbBufferNumber;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyXfbStride
{
  const Decoration type = Decoration::XfbStride;
  eastl::optional<Id> memberIndex;
  LiteralInteger xfbStride;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::XfbStride;
  }
  CastableUniquePointer<PropertyXfbStride> clone() const
  {
    CastableUniquePointer<PropertyXfbStride> result //
      {new PropertyXfbStride};
    result->memberIndex = memberIndex;
    result->xfbStride = xfbStride;
    return result;
  }
  CastableUniquePointer<PropertyXfbStride> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyXfbStride> result //
      {new PropertyXfbStride};
    result->memberIndex = i.value;
    result->xfbStride = xfbStride;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFuncParamAttr
{
  const Decoration type = Decoration::FuncParamAttr;
  eastl::optional<Id> memberIndex;
  FunctionParameterAttribute functionParameterAttribute;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FuncParamAttr;
  }
  CastableUniquePointer<PropertyFuncParamAttr> clone() const
  {
    CastableUniquePointer<PropertyFuncParamAttr> result //
      {new PropertyFuncParamAttr};
    result->memberIndex = memberIndex;
    result->functionParameterAttribute = functionParameterAttribute;
    return result;
  }
  CastableUniquePointer<PropertyFuncParamAttr> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFuncParamAttr> result //
      {new PropertyFuncParamAttr};
    result->memberIndex = i.value;
    result->functionParameterAttribute = functionParameterAttribute;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFPRoundingMode
{
  const Decoration type = Decoration::FPRoundingMode;
  eastl::optional<Id> memberIndex;
  FPRoundingMode floatingPointRoundingMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FPRoundingMode;
  }
  CastableUniquePointer<PropertyFPRoundingMode> clone() const
  {
    CastableUniquePointer<PropertyFPRoundingMode> result //
      {new PropertyFPRoundingMode};
    result->memberIndex = memberIndex;
    result->floatingPointRoundingMode = floatingPointRoundingMode;
    return result;
  }
  CastableUniquePointer<PropertyFPRoundingMode> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFPRoundingMode> result //
      {new PropertyFPRoundingMode};
    result->memberIndex = i.value;
    result->floatingPointRoundingMode = floatingPointRoundingMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFPFastMathMode
{
  const Decoration type = Decoration::FPFastMathMode;
  eastl::optional<Id> memberIndex;
  FPFastMathModeMask fastMathMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FPFastMathMode;
  }
  CastableUniquePointer<PropertyFPFastMathMode> clone() const
  {
    CastableUniquePointer<PropertyFPFastMathMode> result //
      {new PropertyFPFastMathMode};
    result->memberIndex = memberIndex;
    result->fastMathMode = fastMathMode;
    return result;
  }
  CastableUniquePointer<PropertyFPFastMathMode> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFPFastMathMode> result //
      {new PropertyFPFastMathMode};
    result->memberIndex = i.value;
    result->fastMathMode = fastMathMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyLinkageAttributes
{
  const Decoration type = Decoration::LinkageAttributes;
  eastl::optional<Id> memberIndex;
  eastl::string name;
  LinkageType linkageType;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::LinkageAttributes;
  }
  CastableUniquePointer<PropertyLinkageAttributes> clone() const
  {
    CastableUniquePointer<PropertyLinkageAttributes> result //
      {new PropertyLinkageAttributes};
    result->memberIndex = memberIndex;
    result->name = name;
    result->linkageType = linkageType;
    return result;
  }
  CastableUniquePointer<PropertyLinkageAttributes> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyLinkageAttributes> result //
      {new PropertyLinkageAttributes};
    result->memberIndex = i.value;
    result->name = name;
    result->linkageType = linkageType;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNoContraction
{
  const Decoration type = Decoration::NoContraction;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NoContraction;
  }
  CastableUniquePointer<PropertyNoContraction> clone() const
  {
    CastableUniquePointer<PropertyNoContraction> result //
      {new PropertyNoContraction};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNoContraction> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNoContraction> result //
      {new PropertyNoContraction};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyInputAttachmentIndex
{
  const Decoration type = Decoration::InputAttachmentIndex;
  eastl::optional<Id> memberIndex;
  LiteralInteger attachmentIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::InputAttachmentIndex;
  }
  CastableUniquePointer<PropertyInputAttachmentIndex> clone() const
  {
    CastableUniquePointer<PropertyInputAttachmentIndex> result //
      {new PropertyInputAttachmentIndex};
    result->memberIndex = memberIndex;
    result->attachmentIndex = attachmentIndex;
    return result;
  }
  CastableUniquePointer<PropertyInputAttachmentIndex> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyInputAttachmentIndex> result //
      {new PropertyInputAttachmentIndex};
    result->memberIndex = i.value;
    result->attachmentIndex = attachmentIndex;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyAlignment
{
  const Decoration type = Decoration::Alignment;
  eastl::optional<Id> memberIndex;
  LiteralInteger alignment;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::Alignment;
  }
  CastableUniquePointer<PropertyAlignment> clone() const
  {
    CastableUniquePointer<PropertyAlignment> result //
      {new PropertyAlignment};
    result->memberIndex = memberIndex;
    result->alignment = alignment;
    return result;
  }
  CastableUniquePointer<PropertyAlignment> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyAlignment> result //
      {new PropertyAlignment};
    result->memberIndex = i.value;
    result->alignment = alignment;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMaxByteOffset
{
  const Decoration type = Decoration::MaxByteOffset;
  eastl::optional<Id> memberIndex;
  LiteralInteger maxByteOffset;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MaxByteOffset;
  }
  CastableUniquePointer<PropertyMaxByteOffset> clone() const
  {
    CastableUniquePointer<PropertyMaxByteOffset> result //
      {new PropertyMaxByteOffset};
    result->memberIndex = memberIndex;
    result->maxByteOffset = maxByteOffset;
    return result;
  }
  CastableUniquePointer<PropertyMaxByteOffset> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMaxByteOffset> result //
      {new PropertyMaxByteOffset};
    result->memberIndex = i.value;
    result->maxByteOffset = maxByteOffset;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyAlignmentId
{
  const Decoration type = Decoration::AlignmentId;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> alignment;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::AlignmentId;
  }
  CastableUniquePointer<PropertyAlignmentId> clone() const
  {
    CastableUniquePointer<PropertyAlignmentId> result //
      {new PropertyAlignmentId};
    result->memberIndex = memberIndex;
    result->alignment = alignment;
    return result;
  }
  CastableUniquePointer<PropertyAlignmentId> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyAlignmentId> result //
      {new PropertyAlignmentId};
    result->memberIndex = i.value;
    result->alignment = alignment;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(alignment);
  }
};
struct PropertyMaxByteOffsetId
{
  const Decoration type = Decoration::MaxByteOffsetId;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> maxByteOffset;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MaxByteOffsetId;
  }
  CastableUniquePointer<PropertyMaxByteOffsetId> clone() const
  {
    CastableUniquePointer<PropertyMaxByteOffsetId> result //
      {new PropertyMaxByteOffsetId};
    result->memberIndex = memberIndex;
    result->maxByteOffset = maxByteOffset;
    return result;
  }
  CastableUniquePointer<PropertyMaxByteOffsetId> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMaxByteOffsetId> result //
      {new PropertyMaxByteOffsetId};
    result->memberIndex = i.value;
    result->maxByteOffset = maxByteOffset;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(maxByteOffset);
  }
};
struct PropertyNoSignedWrap
{
  const Decoration type = Decoration::NoSignedWrap;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NoSignedWrap;
  }
  CastableUniquePointer<PropertyNoSignedWrap> clone() const
  {
    CastableUniquePointer<PropertyNoSignedWrap> result //
      {new PropertyNoSignedWrap};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNoSignedWrap> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNoSignedWrap> result //
      {new PropertyNoSignedWrap};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNoUnsignedWrap
{
  const Decoration type = Decoration::NoUnsignedWrap;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NoUnsignedWrap;
  }
  CastableUniquePointer<PropertyNoUnsignedWrap> clone() const
  {
    CastableUniquePointer<PropertyNoUnsignedWrap> result //
      {new PropertyNoUnsignedWrap};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNoUnsignedWrap> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNoUnsignedWrap> result //
      {new PropertyNoUnsignedWrap};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyWeightTextureQCOM
{
  const Decoration type = Decoration::WeightTextureQCOM;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::WeightTextureQCOM;
  }
  CastableUniquePointer<PropertyWeightTextureQCOM> clone() const
  {
    CastableUniquePointer<PropertyWeightTextureQCOM> result //
      {new PropertyWeightTextureQCOM};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyWeightTextureQCOM> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyWeightTextureQCOM> result //
      {new PropertyWeightTextureQCOM};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBlockMatchTextureQCOM
{
  const Decoration type = Decoration::BlockMatchTextureQCOM;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BlockMatchTextureQCOM;
  }
  CastableUniquePointer<PropertyBlockMatchTextureQCOM> clone() const
  {
    CastableUniquePointer<PropertyBlockMatchTextureQCOM> result //
      {new PropertyBlockMatchTextureQCOM};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBlockMatchTextureQCOM> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBlockMatchTextureQCOM> result //
      {new PropertyBlockMatchTextureQCOM};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBlockMatchSamplerQCOM
{
  const Decoration type = Decoration::BlockMatchSamplerQCOM;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BlockMatchSamplerQCOM;
  }
  CastableUniquePointer<PropertyBlockMatchSamplerQCOM> clone() const
  {
    CastableUniquePointer<PropertyBlockMatchSamplerQCOM> result //
      {new PropertyBlockMatchSamplerQCOM};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBlockMatchSamplerQCOM> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBlockMatchSamplerQCOM> result //
      {new PropertyBlockMatchSamplerQCOM};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyExplicitInterpAMD
{
  const Decoration type = Decoration::ExplicitInterpAMD;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ExplicitInterpAMD;
  }
  CastableUniquePointer<PropertyExplicitInterpAMD> clone() const
  {
    CastableUniquePointer<PropertyExplicitInterpAMD> result //
      {new PropertyExplicitInterpAMD};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyExplicitInterpAMD> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyExplicitInterpAMD> result //
      {new PropertyExplicitInterpAMD};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNodeSharesPayloadLimitsWithAMDX
{
  const Decoration type = Decoration::NodeSharesPayloadLimitsWithAMDX;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> payloadArray;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NodeSharesPayloadLimitsWithAMDX;
  }
  CastableUniquePointer<PropertyNodeSharesPayloadLimitsWithAMDX> clone() const
  {
    CastableUniquePointer<PropertyNodeSharesPayloadLimitsWithAMDX> result //
      {new PropertyNodeSharesPayloadLimitsWithAMDX};
    result->memberIndex = memberIndex;
    result->payloadArray = payloadArray;
    return result;
  }
  CastableUniquePointer<PropertyNodeSharesPayloadLimitsWithAMDX> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNodeSharesPayloadLimitsWithAMDX> result //
      {new PropertyNodeSharesPayloadLimitsWithAMDX};
    result->memberIndex = i.value;
    result->payloadArray = payloadArray;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(payloadArray);
  }
};
struct PropertyNodeMaxPayloadsAMDX
{
  const Decoration type = Decoration::NodeMaxPayloadsAMDX;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> maxNumberOfPayloads;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NodeMaxPayloadsAMDX;
  }
  CastableUniquePointer<PropertyNodeMaxPayloadsAMDX> clone() const
  {
    CastableUniquePointer<PropertyNodeMaxPayloadsAMDX> result //
      {new PropertyNodeMaxPayloadsAMDX};
    result->memberIndex = memberIndex;
    result->maxNumberOfPayloads = maxNumberOfPayloads;
    return result;
  }
  CastableUniquePointer<PropertyNodeMaxPayloadsAMDX> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNodeMaxPayloadsAMDX> result //
      {new PropertyNodeMaxPayloadsAMDX};
    result->memberIndex = i.value;
    result->maxNumberOfPayloads = maxNumberOfPayloads;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(maxNumberOfPayloads);
  }
};
struct PropertyTrackFinishWritingAMDX
{
  const Decoration type = Decoration::TrackFinishWritingAMDX;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::TrackFinishWritingAMDX;
  }
  CastableUniquePointer<PropertyTrackFinishWritingAMDX> clone() const
  {
    CastableUniquePointer<PropertyTrackFinishWritingAMDX> result //
      {new PropertyTrackFinishWritingAMDX};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyTrackFinishWritingAMDX> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyTrackFinishWritingAMDX> result //
      {new PropertyTrackFinishWritingAMDX};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPayloadNodeNameAMDX
{
  const Decoration type = Decoration::PayloadNodeNameAMDX;
  eastl::optional<Id> memberIndex;
  eastl::string nodeName;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PayloadNodeNameAMDX;
  }
  CastableUniquePointer<PropertyPayloadNodeNameAMDX> clone() const
  {
    CastableUniquePointer<PropertyPayloadNodeNameAMDX> result //
      {new PropertyPayloadNodeNameAMDX};
    result->memberIndex = memberIndex;
    result->nodeName = nodeName;
    return result;
  }
  CastableUniquePointer<PropertyPayloadNodeNameAMDX> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPayloadNodeNameAMDX> result //
      {new PropertyPayloadNodeNameAMDX};
    result->memberIndex = i.value;
    result->nodeName = nodeName;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyOverrideCoverageNV
{
  const Decoration type = Decoration::OverrideCoverageNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::OverrideCoverageNV;
  }
  CastableUniquePointer<PropertyOverrideCoverageNV> clone() const
  {
    CastableUniquePointer<PropertyOverrideCoverageNV> result //
      {new PropertyOverrideCoverageNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyOverrideCoverageNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyOverrideCoverageNV> result //
      {new PropertyOverrideCoverageNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPassthroughNV
{
  const Decoration type = Decoration::PassthroughNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PassthroughNV;
  }
  CastableUniquePointer<PropertyPassthroughNV> clone() const
  {
    CastableUniquePointer<PropertyPassthroughNV> result //
      {new PropertyPassthroughNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPassthroughNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPassthroughNV> result //
      {new PropertyPassthroughNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyViewportRelativeNV
{
  const Decoration type = Decoration::ViewportRelativeNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ViewportRelativeNV;
  }
  CastableUniquePointer<PropertyViewportRelativeNV> clone() const
  {
    CastableUniquePointer<PropertyViewportRelativeNV> result //
      {new PropertyViewportRelativeNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyViewportRelativeNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyViewportRelativeNV> result //
      {new PropertyViewportRelativeNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySecondaryViewportRelativeNV
{
  const Decoration type = Decoration::SecondaryViewportRelativeNV;
  eastl::optional<Id> memberIndex;
  LiteralInteger offset;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SecondaryViewportRelativeNV;
  }
  CastableUniquePointer<PropertySecondaryViewportRelativeNV> clone() const
  {
    CastableUniquePointer<PropertySecondaryViewportRelativeNV> result //
      {new PropertySecondaryViewportRelativeNV};
    result->memberIndex = memberIndex;
    result->offset = offset;
    return result;
  }
  CastableUniquePointer<PropertySecondaryViewportRelativeNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySecondaryViewportRelativeNV> result //
      {new PropertySecondaryViewportRelativeNV};
    result->memberIndex = i.value;
    result->offset = offset;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPerPrimitiveEXT
{
  const Decoration type = Decoration::PerPrimitiveEXT;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PerPrimitiveEXT;
  }
  CastableUniquePointer<PropertyPerPrimitiveEXT> clone() const
  {
    CastableUniquePointer<PropertyPerPrimitiveEXT> result //
      {new PropertyPerPrimitiveEXT};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPerPrimitiveEXT> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPerPrimitiveEXT> result //
      {new PropertyPerPrimitiveEXT};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyPerPrimitiveEXT PropertyPerPrimitiveNV;
struct PropertyPerViewNV
{
  const Decoration type = Decoration::PerViewNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PerViewNV;
  }
  CastableUniquePointer<PropertyPerViewNV> clone() const
  {
    CastableUniquePointer<PropertyPerViewNV> result //
      {new PropertyPerViewNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPerViewNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPerViewNV> result //
      {new PropertyPerViewNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPerTaskNV
{
  const Decoration type = Decoration::PerTaskNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PerTaskNV;
  }
  CastableUniquePointer<PropertyPerTaskNV> clone() const
  {
    CastableUniquePointer<PropertyPerTaskNV> result //
      {new PropertyPerTaskNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPerTaskNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPerTaskNV> result //
      {new PropertyPerTaskNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPerVertexKHR
{
  const Decoration type = Decoration::PerVertexKHR;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PerVertexKHR;
  }
  CastableUniquePointer<PropertyPerVertexKHR> clone() const
  {
    CastableUniquePointer<PropertyPerVertexKHR> result //
      {new PropertyPerVertexKHR};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyPerVertexKHR> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPerVertexKHR> result //
      {new PropertyPerVertexKHR};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyPerVertexKHR PropertyPerVertexNV;
struct PropertyNonUniform
{
  const Decoration type = Decoration::NonUniform;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NonUniform;
  }
  CastableUniquePointer<PropertyNonUniform> clone() const
  {
    CastableUniquePointer<PropertyNonUniform> result //
      {new PropertyNonUniform};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyNonUniform> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNonUniform> result //
      {new PropertyNonUniform};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyNonUniform PropertyNonUniformEXT;
struct PropertyRestrictPointer
{
  const Decoration type = Decoration::RestrictPointer;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::RestrictPointer;
  }
  CastableUniquePointer<PropertyRestrictPointer> clone() const
  {
    CastableUniquePointer<PropertyRestrictPointer> result //
      {new PropertyRestrictPointer};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRestrictPointer> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRestrictPointer> result //
      {new PropertyRestrictPointer};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyRestrictPointer PropertyRestrictPointerEXT;
struct PropertyAliasedPointer
{
  const Decoration type = Decoration::AliasedPointer;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::AliasedPointer;
  }
  CastableUniquePointer<PropertyAliasedPointer> clone() const
  {
    CastableUniquePointer<PropertyAliasedPointer> result //
      {new PropertyAliasedPointer};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyAliasedPointer> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyAliasedPointer> result //
      {new PropertyAliasedPointer};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyAliasedPointer PropertyAliasedPointerEXT;
struct PropertyHitObjectShaderRecordBufferNV
{
  const Decoration type = Decoration::HitObjectShaderRecordBufferNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::HitObjectShaderRecordBufferNV;
  }
  CastableUniquePointer<PropertyHitObjectShaderRecordBufferNV> clone() const
  {
    CastableUniquePointer<PropertyHitObjectShaderRecordBufferNV> result //
      {new PropertyHitObjectShaderRecordBufferNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyHitObjectShaderRecordBufferNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyHitObjectShaderRecordBufferNV> result //
      {new PropertyHitObjectShaderRecordBufferNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBindlessSamplerNV
{
  const Decoration type = Decoration::BindlessSamplerNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BindlessSamplerNV;
  }
  CastableUniquePointer<PropertyBindlessSamplerNV> clone() const
  {
    CastableUniquePointer<PropertyBindlessSamplerNV> result //
      {new PropertyBindlessSamplerNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBindlessSamplerNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBindlessSamplerNV> result //
      {new PropertyBindlessSamplerNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBindlessImageNV
{
  const Decoration type = Decoration::BindlessImageNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BindlessImageNV;
  }
  CastableUniquePointer<PropertyBindlessImageNV> clone() const
  {
    CastableUniquePointer<PropertyBindlessImageNV> result //
      {new PropertyBindlessImageNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBindlessImageNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBindlessImageNV> result //
      {new PropertyBindlessImageNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBoundSamplerNV
{
  const Decoration type = Decoration::BoundSamplerNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BoundSamplerNV;
  }
  CastableUniquePointer<PropertyBoundSamplerNV> clone() const
  {
    CastableUniquePointer<PropertyBoundSamplerNV> result //
      {new PropertyBoundSamplerNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBoundSamplerNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBoundSamplerNV> result //
      {new PropertyBoundSamplerNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBoundImageNV
{
  const Decoration type = Decoration::BoundImageNV;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BoundImageNV;
  }
  CastableUniquePointer<PropertyBoundImageNV> clone() const
  {
    CastableUniquePointer<PropertyBoundImageNV> result //
      {new PropertyBoundImageNV};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBoundImageNV> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBoundImageNV> result //
      {new PropertyBoundImageNV};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySIMTCallINTEL
{
  const Decoration type = Decoration::SIMTCallINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger n;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SIMTCallINTEL;
  }
  CastableUniquePointer<PropertySIMTCallINTEL> clone() const
  {
    CastableUniquePointer<PropertySIMTCallINTEL> result //
      {new PropertySIMTCallINTEL};
    result->memberIndex = memberIndex;
    result->n = n;
    return result;
  }
  CastableUniquePointer<PropertySIMTCallINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySIMTCallINTEL> result //
      {new PropertySIMTCallINTEL};
    result->memberIndex = i.value;
    result->n = n;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyReferencedIndirectlyINTEL
{
  const Decoration type = Decoration::ReferencedIndirectlyINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ReferencedIndirectlyINTEL;
  }
  CastableUniquePointer<PropertyReferencedIndirectlyINTEL> clone() const
  {
    CastableUniquePointer<PropertyReferencedIndirectlyINTEL> result //
      {new PropertyReferencedIndirectlyINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyReferencedIndirectlyINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyReferencedIndirectlyINTEL> result //
      {new PropertyReferencedIndirectlyINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyClobberINTEL
{
  const Decoration type = Decoration::ClobberINTEL;
  eastl::optional<Id> memberIndex;
  eastl::string _register;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ClobberINTEL;
  }
  CastableUniquePointer<PropertyClobberINTEL> clone() const
  {
    CastableUniquePointer<PropertyClobberINTEL> result //
      {new PropertyClobberINTEL};
    result->memberIndex = memberIndex;
    result->_register = _register;
    return result;
  }
  CastableUniquePointer<PropertyClobberINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyClobberINTEL> result //
      {new PropertyClobberINTEL};
    result->memberIndex = i.value;
    result->_register = _register;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySideEffectsINTEL
{
  const Decoration type = Decoration::SideEffectsINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SideEffectsINTEL;
  }
  CastableUniquePointer<PropertySideEffectsINTEL> clone() const
  {
    CastableUniquePointer<PropertySideEffectsINTEL> result //
      {new PropertySideEffectsINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySideEffectsINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySideEffectsINTEL> result //
      {new PropertySideEffectsINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyVectorComputeVariableINTEL
{
  const Decoration type = Decoration::VectorComputeVariableINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::VectorComputeVariableINTEL;
  }
  CastableUniquePointer<PropertyVectorComputeVariableINTEL> clone() const
  {
    CastableUniquePointer<PropertyVectorComputeVariableINTEL> result //
      {new PropertyVectorComputeVariableINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyVectorComputeVariableINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyVectorComputeVariableINTEL> result //
      {new PropertyVectorComputeVariableINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFuncParamIOKindINTEL
{
  const Decoration type = Decoration::FuncParamIOKindINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger kind;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FuncParamIOKindINTEL;
  }
  CastableUniquePointer<PropertyFuncParamIOKindINTEL> clone() const
  {
    CastableUniquePointer<PropertyFuncParamIOKindINTEL> result //
      {new PropertyFuncParamIOKindINTEL};
    result->memberIndex = memberIndex;
    result->kind = kind;
    return result;
  }
  CastableUniquePointer<PropertyFuncParamIOKindINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFuncParamIOKindINTEL> result //
      {new PropertyFuncParamIOKindINTEL};
    result->memberIndex = i.value;
    result->kind = kind;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyVectorComputeFunctionINTEL
{
  const Decoration type = Decoration::VectorComputeFunctionINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::VectorComputeFunctionINTEL;
  }
  CastableUniquePointer<PropertyVectorComputeFunctionINTEL> clone() const
  {
    CastableUniquePointer<PropertyVectorComputeFunctionINTEL> result //
      {new PropertyVectorComputeFunctionINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyVectorComputeFunctionINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyVectorComputeFunctionINTEL> result //
      {new PropertyVectorComputeFunctionINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStackCallINTEL
{
  const Decoration type = Decoration::StackCallINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::StackCallINTEL;
  }
  CastableUniquePointer<PropertyStackCallINTEL> clone() const
  {
    CastableUniquePointer<PropertyStackCallINTEL> result //
      {new PropertyStackCallINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyStackCallINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStackCallINTEL> result //
      {new PropertyStackCallINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyGlobalVariableOffsetINTEL
{
  const Decoration type = Decoration::GlobalVariableOffsetINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger offset;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::GlobalVariableOffsetINTEL;
  }
  CastableUniquePointer<PropertyGlobalVariableOffsetINTEL> clone() const
  {
    CastableUniquePointer<PropertyGlobalVariableOffsetINTEL> result //
      {new PropertyGlobalVariableOffsetINTEL};
    result->memberIndex = memberIndex;
    result->offset = offset;
    return result;
  }
  CastableUniquePointer<PropertyGlobalVariableOffsetINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyGlobalVariableOffsetINTEL> result //
      {new PropertyGlobalVariableOffsetINTEL};
    result->memberIndex = i.value;
    result->offset = offset;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCounterBuffer
{
  const Decoration type = Decoration::CounterBuffer;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> counterBuffer;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::CounterBuffer;
  }
  CastableUniquePointer<PropertyCounterBuffer> clone() const
  {
    CastableUniquePointer<PropertyCounterBuffer> result //
      {new PropertyCounterBuffer};
    result->memberIndex = memberIndex;
    result->counterBuffer = counterBuffer;
    return result;
  }
  CastableUniquePointer<PropertyCounterBuffer> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCounterBuffer> result //
      {new PropertyCounterBuffer};
    result->memberIndex = i.value;
    result->counterBuffer = counterBuffer;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(counterBuffer);
  }
};
typedef PropertyCounterBuffer PropertyHlslCounterBufferGOOGLE;
struct PropertyUserSemantic
{
  const Decoration type = Decoration::UserSemantic;
  eastl::optional<Id> memberIndex;
  eastl::string semantic;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::UserSemantic;
  }
  CastableUniquePointer<PropertyUserSemantic> clone() const
  {
    CastableUniquePointer<PropertyUserSemantic> result //
      {new PropertyUserSemantic};
    result->memberIndex = memberIndex;
    result->semantic = semantic;
    return result;
  }
  CastableUniquePointer<PropertyUserSemantic> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyUserSemantic> result //
      {new PropertyUserSemantic};
    result->memberIndex = i.value;
    result->semantic = semantic;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
typedef PropertyUserSemantic PropertyHlslSemanticGOOGLE;
struct PropertyUserTypeGOOGLE
{
  const Decoration type = Decoration::UserTypeGOOGLE;
  eastl::optional<Id> memberIndex;
  eastl::string userType;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::UserTypeGOOGLE;
  }
  CastableUniquePointer<PropertyUserTypeGOOGLE> clone() const
  {
    CastableUniquePointer<PropertyUserTypeGOOGLE> result //
      {new PropertyUserTypeGOOGLE};
    result->memberIndex = memberIndex;
    result->userType = userType;
    return result;
  }
  CastableUniquePointer<PropertyUserTypeGOOGLE> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyUserTypeGOOGLE> result //
      {new PropertyUserTypeGOOGLE};
    result->memberIndex = i.value;
    result->userType = userType;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFunctionRoundingModeINTEL
{
  const Decoration type = Decoration::FunctionRoundingModeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger targetWidth;
  FPRoundingMode fpRoundingMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FunctionRoundingModeINTEL;
  }
  CastableUniquePointer<PropertyFunctionRoundingModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyFunctionRoundingModeINTEL> result //
      {new PropertyFunctionRoundingModeINTEL};
    result->memberIndex = memberIndex;
    result->targetWidth = targetWidth;
    result->fpRoundingMode = fpRoundingMode;
    return result;
  }
  CastableUniquePointer<PropertyFunctionRoundingModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFunctionRoundingModeINTEL> result //
      {new PropertyFunctionRoundingModeINTEL};
    result->memberIndex = i.value;
    result->targetWidth = targetWidth;
    result->fpRoundingMode = fpRoundingMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFunctionDenormModeINTEL
{
  const Decoration type = Decoration::FunctionDenormModeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger targetWidth;
  FPDenormMode fpDenormMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FunctionDenormModeINTEL;
  }
  CastableUniquePointer<PropertyFunctionDenormModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyFunctionDenormModeINTEL> result //
      {new PropertyFunctionDenormModeINTEL};
    result->memberIndex = memberIndex;
    result->targetWidth = targetWidth;
    result->fpDenormMode = fpDenormMode;
    return result;
  }
  CastableUniquePointer<PropertyFunctionDenormModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFunctionDenormModeINTEL> result //
      {new PropertyFunctionDenormModeINTEL};
    result->memberIndex = i.value;
    result->targetWidth = targetWidth;
    result->fpDenormMode = fpDenormMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyRegisterINTEL
{
  const Decoration type = Decoration::RegisterINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::RegisterINTEL;
  }
  CastableUniquePointer<PropertyRegisterINTEL> clone() const
  {
    CastableUniquePointer<PropertyRegisterINTEL> result //
      {new PropertyRegisterINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRegisterINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRegisterINTEL> result //
      {new PropertyRegisterINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMemoryINTEL
{
  const Decoration type = Decoration::MemoryINTEL;
  eastl::optional<Id> memberIndex;
  eastl::string memoryType;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MemoryINTEL;
  }
  CastableUniquePointer<PropertyMemoryINTEL> clone() const
  {
    CastableUniquePointer<PropertyMemoryINTEL> result //
      {new PropertyMemoryINTEL};
    result->memberIndex = memberIndex;
    result->memoryType = memoryType;
    return result;
  }
  CastableUniquePointer<PropertyMemoryINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMemoryINTEL> result //
      {new PropertyMemoryINTEL};
    result->memberIndex = i.value;
    result->memoryType = memoryType;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyNumbanksINTEL
{
  const Decoration type = Decoration::NumbanksINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger banks;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NumbanksINTEL;
  }
  CastableUniquePointer<PropertyNumbanksINTEL> clone() const
  {
    CastableUniquePointer<PropertyNumbanksINTEL> result //
      {new PropertyNumbanksINTEL};
    result->memberIndex = memberIndex;
    result->banks = banks;
    return result;
  }
  CastableUniquePointer<PropertyNumbanksINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNumbanksINTEL> result //
      {new PropertyNumbanksINTEL};
    result->memberIndex = i.value;
    result->banks = banks;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBankwidthINTEL
{
  const Decoration type = Decoration::BankwidthINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger bankWidth;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BankwidthINTEL;
  }
  CastableUniquePointer<PropertyBankwidthINTEL> clone() const
  {
    CastableUniquePointer<PropertyBankwidthINTEL> result //
      {new PropertyBankwidthINTEL};
    result->memberIndex = memberIndex;
    result->bankWidth = bankWidth;
    return result;
  }
  CastableUniquePointer<PropertyBankwidthINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBankwidthINTEL> result //
      {new PropertyBankwidthINTEL};
    result->memberIndex = i.value;
    result->bankWidth = bankWidth;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMaxPrivateCopiesINTEL
{
  const Decoration type = Decoration::MaxPrivateCopiesINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger maximumCopies;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MaxPrivateCopiesINTEL;
  }
  CastableUniquePointer<PropertyMaxPrivateCopiesINTEL> clone() const
  {
    CastableUniquePointer<PropertyMaxPrivateCopiesINTEL> result //
      {new PropertyMaxPrivateCopiesINTEL};
    result->memberIndex = memberIndex;
    result->maximumCopies = maximumCopies;
    return result;
  }
  CastableUniquePointer<PropertyMaxPrivateCopiesINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMaxPrivateCopiesINTEL> result //
      {new PropertyMaxPrivateCopiesINTEL};
    result->memberIndex = i.value;
    result->maximumCopies = maximumCopies;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySinglepumpINTEL
{
  const Decoration type = Decoration::SinglepumpINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SinglepumpINTEL;
  }
  CastableUniquePointer<PropertySinglepumpINTEL> clone() const
  {
    CastableUniquePointer<PropertySinglepumpINTEL> result //
      {new PropertySinglepumpINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySinglepumpINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySinglepumpINTEL> result //
      {new PropertySinglepumpINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyDoublepumpINTEL
{
  const Decoration type = Decoration::DoublepumpINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::DoublepumpINTEL;
  }
  CastableUniquePointer<PropertyDoublepumpINTEL> clone() const
  {
    CastableUniquePointer<PropertyDoublepumpINTEL> result //
      {new PropertyDoublepumpINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyDoublepumpINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyDoublepumpINTEL> result //
      {new PropertyDoublepumpINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMaxReplicatesINTEL
{
  const Decoration type = Decoration::MaxReplicatesINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger maximumReplicates;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MaxReplicatesINTEL;
  }
  CastableUniquePointer<PropertyMaxReplicatesINTEL> clone() const
  {
    CastableUniquePointer<PropertyMaxReplicatesINTEL> result //
      {new PropertyMaxReplicatesINTEL};
    result->memberIndex = memberIndex;
    result->maximumReplicates = maximumReplicates;
    return result;
  }
  CastableUniquePointer<PropertyMaxReplicatesINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMaxReplicatesINTEL> result //
      {new PropertyMaxReplicatesINTEL};
    result->memberIndex = i.value;
    result->maximumReplicates = maximumReplicates;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySimpleDualPortINTEL
{
  const Decoration type = Decoration::SimpleDualPortINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SimpleDualPortINTEL;
  }
  CastableUniquePointer<PropertySimpleDualPortINTEL> clone() const
  {
    CastableUniquePointer<PropertySimpleDualPortINTEL> result //
      {new PropertySimpleDualPortINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySimpleDualPortINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySimpleDualPortINTEL> result //
      {new PropertySimpleDualPortINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMergeINTEL
{
  const Decoration type = Decoration::MergeINTEL;
  eastl::optional<Id> memberIndex;
  eastl::string mergeKey;
  eastl::string mergeType;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MergeINTEL;
  }
  CastableUniquePointer<PropertyMergeINTEL> clone() const
  {
    CastableUniquePointer<PropertyMergeINTEL> result //
      {new PropertyMergeINTEL};
    result->memberIndex = memberIndex;
    result->mergeKey = mergeKey;
    result->mergeType = mergeType;
    return result;
  }
  CastableUniquePointer<PropertyMergeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMergeINTEL> result //
      {new PropertyMergeINTEL};
    result->memberIndex = i.value;
    result->mergeKey = mergeKey;
    result->mergeType = mergeType;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBankBitsINTEL
{
  const Decoration type = Decoration::BankBitsINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger bankBits;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BankBitsINTEL;
  }
  CastableUniquePointer<PropertyBankBitsINTEL> clone() const
  {
    CastableUniquePointer<PropertyBankBitsINTEL> result //
      {new PropertyBankBitsINTEL};
    result->memberIndex = memberIndex;
    result->bankBits = bankBits;
    return result;
  }
  CastableUniquePointer<PropertyBankBitsINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBankBitsINTEL> result //
      {new PropertyBankBitsINTEL};
    result->memberIndex = i.value;
    result->bankBits = bankBits;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyForcePow2DepthINTEL
{
  const Decoration type = Decoration::ForcePow2DepthINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger forceKey;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ForcePow2DepthINTEL;
  }
  CastableUniquePointer<PropertyForcePow2DepthINTEL> clone() const
  {
    CastableUniquePointer<PropertyForcePow2DepthINTEL> result //
      {new PropertyForcePow2DepthINTEL};
    result->memberIndex = memberIndex;
    result->forceKey = forceKey;
    return result;
  }
  CastableUniquePointer<PropertyForcePow2DepthINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyForcePow2DepthINTEL> result //
      {new PropertyForcePow2DepthINTEL};
    result->memberIndex = i.value;
    result->forceKey = forceKey;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStridesizeINTEL
{
  const Decoration type = Decoration::StridesizeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger strideSize;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::StridesizeINTEL;
  }
  CastableUniquePointer<PropertyStridesizeINTEL> clone() const
  {
    CastableUniquePointer<PropertyStridesizeINTEL> result //
      {new PropertyStridesizeINTEL};
    result->memberIndex = memberIndex;
    result->strideSize = strideSize;
    return result;
  }
  CastableUniquePointer<PropertyStridesizeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStridesizeINTEL> result //
      {new PropertyStridesizeINTEL};
    result->memberIndex = i.value;
    result->strideSize = strideSize;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyWordsizeINTEL
{
  const Decoration type = Decoration::WordsizeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger wordSize;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::WordsizeINTEL;
  }
  CastableUniquePointer<PropertyWordsizeINTEL> clone() const
  {
    CastableUniquePointer<PropertyWordsizeINTEL> result //
      {new PropertyWordsizeINTEL};
    result->memberIndex = memberIndex;
    result->wordSize = wordSize;
    return result;
  }
  CastableUniquePointer<PropertyWordsizeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyWordsizeINTEL> result //
      {new PropertyWordsizeINTEL};
    result->memberIndex = i.value;
    result->wordSize = wordSize;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyTrueDualPortINTEL
{
  const Decoration type = Decoration::TrueDualPortINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::TrueDualPortINTEL;
  }
  CastableUniquePointer<PropertyTrueDualPortINTEL> clone() const
  {
    CastableUniquePointer<PropertyTrueDualPortINTEL> result //
      {new PropertyTrueDualPortINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyTrueDualPortINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyTrueDualPortINTEL> result //
      {new PropertyTrueDualPortINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBurstCoalesceINTEL
{
  const Decoration type = Decoration::BurstCoalesceINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BurstCoalesceINTEL;
  }
  CastableUniquePointer<PropertyBurstCoalesceINTEL> clone() const
  {
    CastableUniquePointer<PropertyBurstCoalesceINTEL> result //
      {new PropertyBurstCoalesceINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyBurstCoalesceINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBurstCoalesceINTEL> result //
      {new PropertyBurstCoalesceINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCacheSizeINTEL
{
  const Decoration type = Decoration::CacheSizeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger cacheSizeInBytes;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::CacheSizeINTEL;
  }
  CastableUniquePointer<PropertyCacheSizeINTEL> clone() const
  {
    CastableUniquePointer<PropertyCacheSizeINTEL> result //
      {new PropertyCacheSizeINTEL};
    result->memberIndex = memberIndex;
    result->cacheSizeInBytes = cacheSizeInBytes;
    return result;
  }
  CastableUniquePointer<PropertyCacheSizeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCacheSizeINTEL> result //
      {new PropertyCacheSizeINTEL};
    result->memberIndex = i.value;
    result->cacheSizeInBytes = cacheSizeInBytes;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyDontStaticallyCoalesceINTEL
{
  const Decoration type = Decoration::DontStaticallyCoalesceINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::DontStaticallyCoalesceINTEL;
  }
  CastableUniquePointer<PropertyDontStaticallyCoalesceINTEL> clone() const
  {
    CastableUniquePointer<PropertyDontStaticallyCoalesceINTEL> result //
      {new PropertyDontStaticallyCoalesceINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyDontStaticallyCoalesceINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyDontStaticallyCoalesceINTEL> result //
      {new PropertyDontStaticallyCoalesceINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPrefetchINTEL
{
  const Decoration type = Decoration::PrefetchINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger prefetcherSizeInBytes;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PrefetchINTEL;
  }
  CastableUniquePointer<PropertyPrefetchINTEL> clone() const
  {
    CastableUniquePointer<PropertyPrefetchINTEL> result //
      {new PropertyPrefetchINTEL};
    result->memberIndex = memberIndex;
    result->prefetcherSizeInBytes = prefetcherSizeInBytes;
    return result;
  }
  CastableUniquePointer<PropertyPrefetchINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPrefetchINTEL> result //
      {new PropertyPrefetchINTEL};
    result->memberIndex = i.value;
    result->prefetcherSizeInBytes = prefetcherSizeInBytes;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStallEnableINTEL
{
  const Decoration type = Decoration::StallEnableINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::StallEnableINTEL;
  }
  CastableUniquePointer<PropertyStallEnableINTEL> clone() const
  {
    CastableUniquePointer<PropertyStallEnableINTEL> result //
      {new PropertyStallEnableINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyStallEnableINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStallEnableINTEL> result //
      {new PropertyStallEnableINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFuseLoopsInFunctionINTEL
{
  const Decoration type = Decoration::FuseLoopsInFunctionINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FuseLoopsInFunctionINTEL;
  }
  CastableUniquePointer<PropertyFuseLoopsInFunctionINTEL> clone() const
  {
    CastableUniquePointer<PropertyFuseLoopsInFunctionINTEL> result //
      {new PropertyFuseLoopsInFunctionINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyFuseLoopsInFunctionINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFuseLoopsInFunctionINTEL> result //
      {new PropertyFuseLoopsInFunctionINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMathOpDSPModeINTEL
{
  const Decoration type = Decoration::MathOpDSPModeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger mode;
  LiteralInteger propagate;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MathOpDSPModeINTEL;
  }
  CastableUniquePointer<PropertyMathOpDSPModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyMathOpDSPModeINTEL> result //
      {new PropertyMathOpDSPModeINTEL};
    result->memberIndex = memberIndex;
    result->mode = mode;
    result->propagate = propagate;
    return result;
  }
  CastableUniquePointer<PropertyMathOpDSPModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMathOpDSPModeINTEL> result //
      {new PropertyMathOpDSPModeINTEL};
    result->memberIndex = i.value;
    result->mode = mode;
    result->propagate = propagate;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyAliasScopeINTEL
{
  const Decoration type = Decoration::AliasScopeINTEL;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> aliasingScopesList;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::AliasScopeINTEL;
  }
  CastableUniquePointer<PropertyAliasScopeINTEL> clone() const
  {
    CastableUniquePointer<PropertyAliasScopeINTEL> result //
      {new PropertyAliasScopeINTEL};
    result->memberIndex = memberIndex;
    result->aliasingScopesList = aliasingScopesList;
    return result;
  }
  CastableUniquePointer<PropertyAliasScopeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyAliasScopeINTEL> result //
      {new PropertyAliasScopeINTEL};
    result->memberIndex = i.value;
    result->aliasingScopesList = aliasingScopesList;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(aliasingScopesList);
  }
};
struct PropertyNoAliasINTEL
{
  const Decoration type = Decoration::NoAliasINTEL;
  eastl::optional<Id> memberIndex;
  NodePointer<NodeId> aliasingScopesList;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::NoAliasINTEL;
  }
  CastableUniquePointer<PropertyNoAliasINTEL> clone() const
  {
    CastableUniquePointer<PropertyNoAliasINTEL> result //
      {new PropertyNoAliasINTEL};
    result->memberIndex = memberIndex;
    result->aliasingScopesList = aliasingScopesList;
    return result;
  }
  CastableUniquePointer<PropertyNoAliasINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyNoAliasINTEL> result //
      {new PropertyNoAliasINTEL};
    result->memberIndex = i.value;
    result->aliasingScopesList = aliasingScopesList;
    return result;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(aliasingScopesList);
  }
};
struct PropertyInitiationIntervalINTEL
{
  const Decoration type = Decoration::InitiationIntervalINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger cycles;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::InitiationIntervalINTEL;
  }
  CastableUniquePointer<PropertyInitiationIntervalINTEL> clone() const
  {
    CastableUniquePointer<PropertyInitiationIntervalINTEL> result //
      {new PropertyInitiationIntervalINTEL};
    result->memberIndex = memberIndex;
    result->cycles = cycles;
    return result;
  }
  CastableUniquePointer<PropertyInitiationIntervalINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyInitiationIntervalINTEL> result //
      {new PropertyInitiationIntervalINTEL};
    result->memberIndex = i.value;
    result->cycles = cycles;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMaxConcurrencyINTEL
{
  const Decoration type = Decoration::MaxConcurrencyINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger invocations;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MaxConcurrencyINTEL;
  }
  CastableUniquePointer<PropertyMaxConcurrencyINTEL> clone() const
  {
    CastableUniquePointer<PropertyMaxConcurrencyINTEL> result //
      {new PropertyMaxConcurrencyINTEL};
    result->memberIndex = memberIndex;
    result->invocations = invocations;
    return result;
  }
  CastableUniquePointer<PropertyMaxConcurrencyINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMaxConcurrencyINTEL> result //
      {new PropertyMaxConcurrencyINTEL};
    result->memberIndex = i.value;
    result->invocations = invocations;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyPipelineEnableINTEL
{
  const Decoration type = Decoration::PipelineEnableINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger enable;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::PipelineEnableINTEL;
  }
  CastableUniquePointer<PropertyPipelineEnableINTEL> clone() const
  {
    CastableUniquePointer<PropertyPipelineEnableINTEL> result //
      {new PropertyPipelineEnableINTEL};
    result->memberIndex = memberIndex;
    result->enable = enable;
    return result;
  }
  CastableUniquePointer<PropertyPipelineEnableINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyPipelineEnableINTEL> result //
      {new PropertyPipelineEnableINTEL};
    result->memberIndex = i.value;
    result->enable = enable;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyBufferLocationINTEL
{
  const Decoration type = Decoration::BufferLocationINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger bufferLocationId;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::BufferLocationINTEL;
  }
  CastableUniquePointer<PropertyBufferLocationINTEL> clone() const
  {
    CastableUniquePointer<PropertyBufferLocationINTEL> result //
      {new PropertyBufferLocationINTEL};
    result->memberIndex = memberIndex;
    result->bufferLocationId = bufferLocationId;
    return result;
  }
  CastableUniquePointer<PropertyBufferLocationINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyBufferLocationINTEL> result //
      {new PropertyBufferLocationINTEL};
    result->memberIndex = i.value;
    result->bufferLocationId = bufferLocationId;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyIOPipeStorageINTEL
{
  const Decoration type = Decoration::IOPipeStorageINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger ioPipeId;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::IOPipeStorageINTEL;
  }
  CastableUniquePointer<PropertyIOPipeStorageINTEL> clone() const
  {
    CastableUniquePointer<PropertyIOPipeStorageINTEL> result //
      {new PropertyIOPipeStorageINTEL};
    result->memberIndex = memberIndex;
    result->ioPipeId = ioPipeId;
    return result;
  }
  CastableUniquePointer<PropertyIOPipeStorageINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyIOPipeStorageINTEL> result //
      {new PropertyIOPipeStorageINTEL};
    result->memberIndex = i.value;
    result->ioPipeId = ioPipeId;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFunctionFloatingPointModeINTEL
{
  const Decoration type = Decoration::FunctionFloatingPointModeINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger targetWidth;
  FPOperationMode fpOperationMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FunctionFloatingPointModeINTEL;
  }
  CastableUniquePointer<PropertyFunctionFloatingPointModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyFunctionFloatingPointModeINTEL> result //
      {new PropertyFunctionFloatingPointModeINTEL};
    result->memberIndex = memberIndex;
    result->targetWidth = targetWidth;
    result->fpOperationMode = fpOperationMode;
    return result;
  }
  CastableUniquePointer<PropertyFunctionFloatingPointModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFunctionFloatingPointModeINTEL> result //
      {new PropertyFunctionFloatingPointModeINTEL};
    result->memberIndex = i.value;
    result->targetWidth = targetWidth;
    result->fpOperationMode = fpOperationMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertySingleElementVectorINTEL
{
  const Decoration type = Decoration::SingleElementVectorINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::SingleElementVectorINTEL;
  }
  CastableUniquePointer<PropertySingleElementVectorINTEL> clone() const
  {
    CastableUniquePointer<PropertySingleElementVectorINTEL> result //
      {new PropertySingleElementVectorINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertySingleElementVectorINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertySingleElementVectorINTEL> result //
      {new PropertySingleElementVectorINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyVectorComputeCallableFunctionINTEL
{
  const Decoration type = Decoration::VectorComputeCallableFunctionINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::VectorComputeCallableFunctionINTEL;
  }
  CastableUniquePointer<PropertyVectorComputeCallableFunctionINTEL> clone() const
  {
    CastableUniquePointer<PropertyVectorComputeCallableFunctionINTEL> result //
      {new PropertyVectorComputeCallableFunctionINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyVectorComputeCallableFunctionINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyVectorComputeCallableFunctionINTEL> result //
      {new PropertyVectorComputeCallableFunctionINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMediaBlockIOINTEL
{
  const Decoration type = Decoration::MediaBlockIOINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MediaBlockIOINTEL;
  }
  CastableUniquePointer<PropertyMediaBlockIOINTEL> clone() const
  {
    CastableUniquePointer<PropertyMediaBlockIOINTEL> result //
      {new PropertyMediaBlockIOINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyMediaBlockIOINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMediaBlockIOINTEL> result //
      {new PropertyMediaBlockIOINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStallFreeINTEL
{
  const Decoration type = Decoration::StallFreeINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::StallFreeINTEL;
  }
  CastableUniquePointer<PropertyStallFreeINTEL> clone() const
  {
    CastableUniquePointer<PropertyStallFreeINTEL> result //
      {new PropertyStallFreeINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyStallFreeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStallFreeINTEL> result //
      {new PropertyStallFreeINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyFPMaxErrorDecorationINTEL
{
  const Decoration type = Decoration::FPMaxErrorDecorationINTEL;
  eastl::optional<Id> memberIndex;
  LiteralFloat maxError;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::FPMaxErrorDecorationINTEL;
  }
  CastableUniquePointer<PropertyFPMaxErrorDecorationINTEL> clone() const
  {
    CastableUniquePointer<PropertyFPMaxErrorDecorationINTEL> result //
      {new PropertyFPMaxErrorDecorationINTEL};
    result->memberIndex = memberIndex;
    result->maxError = maxError;
    return result;
  }
  CastableUniquePointer<PropertyFPMaxErrorDecorationINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyFPMaxErrorDecorationINTEL> result //
      {new PropertyFPMaxErrorDecorationINTEL};
    result->memberIndex = i.value;
    result->maxError = maxError;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyLatencyControlLabelINTEL
{
  const Decoration type = Decoration::LatencyControlLabelINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger latencyLabel;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::LatencyControlLabelINTEL;
  }
  CastableUniquePointer<PropertyLatencyControlLabelINTEL> clone() const
  {
    CastableUniquePointer<PropertyLatencyControlLabelINTEL> result //
      {new PropertyLatencyControlLabelINTEL};
    result->memberIndex = memberIndex;
    result->latencyLabel = latencyLabel;
    return result;
  }
  CastableUniquePointer<PropertyLatencyControlLabelINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyLatencyControlLabelINTEL> result //
      {new PropertyLatencyControlLabelINTEL};
    result->memberIndex = i.value;
    result->latencyLabel = latencyLabel;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyLatencyControlConstraintINTEL
{
  const Decoration type = Decoration::LatencyControlConstraintINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger relativeTo;
  LiteralInteger controlType;
  LiteralInteger relativeCycle;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::LatencyControlConstraintINTEL;
  }
  CastableUniquePointer<PropertyLatencyControlConstraintINTEL> clone() const
  {
    CastableUniquePointer<PropertyLatencyControlConstraintINTEL> result //
      {new PropertyLatencyControlConstraintINTEL};
    result->memberIndex = memberIndex;
    result->relativeTo = relativeTo;
    result->controlType = controlType;
    result->relativeCycle = relativeCycle;
    return result;
  }
  CastableUniquePointer<PropertyLatencyControlConstraintINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyLatencyControlConstraintINTEL> result //
      {new PropertyLatencyControlConstraintINTEL};
    result->memberIndex = i.value;
    result->relativeTo = relativeTo;
    result->controlType = controlType;
    result->relativeCycle = relativeCycle;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyConduitKernelArgumentINTEL
{
  const Decoration type = Decoration::ConduitKernelArgumentINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ConduitKernelArgumentINTEL;
  }
  CastableUniquePointer<PropertyConduitKernelArgumentINTEL> clone() const
  {
    CastableUniquePointer<PropertyConduitKernelArgumentINTEL> result //
      {new PropertyConduitKernelArgumentINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyConduitKernelArgumentINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyConduitKernelArgumentINTEL> result //
      {new PropertyConduitKernelArgumentINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyRegisterMapKernelArgumentINTEL
{
  const Decoration type = Decoration::RegisterMapKernelArgumentINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::RegisterMapKernelArgumentINTEL;
  }
  CastableUniquePointer<PropertyRegisterMapKernelArgumentINTEL> clone() const
  {
    CastableUniquePointer<PropertyRegisterMapKernelArgumentINTEL> result //
      {new PropertyRegisterMapKernelArgumentINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyRegisterMapKernelArgumentINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyRegisterMapKernelArgumentINTEL> result //
      {new PropertyRegisterMapKernelArgumentINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceAddressWidthINTEL
{
  const Decoration type = Decoration::MMHostInterfaceAddressWidthINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger addressWidth;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceAddressWidthINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceAddressWidthINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceAddressWidthINTEL> result //
      {new PropertyMMHostInterfaceAddressWidthINTEL};
    result->memberIndex = memberIndex;
    result->addressWidth = addressWidth;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceAddressWidthINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceAddressWidthINTEL> result //
      {new PropertyMMHostInterfaceAddressWidthINTEL};
    result->memberIndex = i.value;
    result->addressWidth = addressWidth;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceDataWidthINTEL
{
  const Decoration type = Decoration::MMHostInterfaceDataWidthINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger dataWidth;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceDataWidthINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceDataWidthINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceDataWidthINTEL> result //
      {new PropertyMMHostInterfaceDataWidthINTEL};
    result->memberIndex = memberIndex;
    result->dataWidth = dataWidth;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceDataWidthINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceDataWidthINTEL> result //
      {new PropertyMMHostInterfaceDataWidthINTEL};
    result->memberIndex = i.value;
    result->dataWidth = dataWidth;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceLatencyINTEL
{
  const Decoration type = Decoration::MMHostInterfaceLatencyINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger latency;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceLatencyINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceLatencyINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceLatencyINTEL> result //
      {new PropertyMMHostInterfaceLatencyINTEL};
    result->memberIndex = memberIndex;
    result->latency = latency;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceLatencyINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceLatencyINTEL> result //
      {new PropertyMMHostInterfaceLatencyINTEL};
    result->memberIndex = i.value;
    result->latency = latency;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceReadWriteModeINTEL
{
  const Decoration type = Decoration::MMHostInterfaceReadWriteModeINTEL;
  eastl::optional<Id> memberIndex;
  AccessQualifier readWriteMode;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceReadWriteModeINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceReadWriteModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceReadWriteModeINTEL> result //
      {new PropertyMMHostInterfaceReadWriteModeINTEL};
    result->memberIndex = memberIndex;
    result->readWriteMode = readWriteMode;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceReadWriteModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceReadWriteModeINTEL> result //
      {new PropertyMMHostInterfaceReadWriteModeINTEL};
    result->memberIndex = i.value;
    result->readWriteMode = readWriteMode;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceMaxBurstINTEL
{
  const Decoration type = Decoration::MMHostInterfaceMaxBurstINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger maxBurstCount;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceMaxBurstINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceMaxBurstINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceMaxBurstINTEL> result //
      {new PropertyMMHostInterfaceMaxBurstINTEL};
    result->memberIndex = memberIndex;
    result->maxBurstCount = maxBurstCount;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceMaxBurstINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceMaxBurstINTEL> result //
      {new PropertyMMHostInterfaceMaxBurstINTEL};
    result->memberIndex = i.value;
    result->maxBurstCount = maxBurstCount;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyMMHostInterfaceWaitRequestINTEL
{
  const Decoration type = Decoration::MMHostInterfaceWaitRequestINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger waitrequest;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::MMHostInterfaceWaitRequestINTEL;
  }
  CastableUniquePointer<PropertyMMHostInterfaceWaitRequestINTEL> clone() const
  {
    CastableUniquePointer<PropertyMMHostInterfaceWaitRequestINTEL> result //
      {new PropertyMMHostInterfaceWaitRequestINTEL};
    result->memberIndex = memberIndex;
    result->waitrequest = waitrequest;
    return result;
  }
  CastableUniquePointer<PropertyMMHostInterfaceWaitRequestINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyMMHostInterfaceWaitRequestINTEL> result //
      {new PropertyMMHostInterfaceWaitRequestINTEL};
    result->memberIndex = i.value;
    result->waitrequest = waitrequest;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyStableKernelArgumentINTEL
{
  const Decoration type = Decoration::StableKernelArgumentINTEL;
  eastl::optional<Id> memberIndex;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::StableKernelArgumentINTEL;
  }
  CastableUniquePointer<PropertyStableKernelArgumentINTEL> clone() const
  {
    CastableUniquePointer<PropertyStableKernelArgumentINTEL> result //
      {new PropertyStableKernelArgumentINTEL};
    result->memberIndex = memberIndex;
    return result;
  }
  CastableUniquePointer<PropertyStableKernelArgumentINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyStableKernelArgumentINTEL> result //
      {new PropertyStableKernelArgumentINTEL};
    result->memberIndex = i.value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyHostAccessINTEL
{
  const Decoration type = Decoration::HostAccessINTEL;
  eastl::optional<Id> memberIndex;
  HostAccessQualifier access;
  eastl::string name;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::HostAccessINTEL;
  }
  CastableUniquePointer<PropertyHostAccessINTEL> clone() const
  {
    CastableUniquePointer<PropertyHostAccessINTEL> result //
      {new PropertyHostAccessINTEL};
    result->memberIndex = memberIndex;
    result->access = access;
    result->name = name;
    return result;
  }
  CastableUniquePointer<PropertyHostAccessINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyHostAccessINTEL> result //
      {new PropertyHostAccessINTEL};
    result->memberIndex = i.value;
    result->access = access;
    result->name = name;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyInitModeINTEL
{
  const Decoration type = Decoration::InitModeINTEL;
  eastl::optional<Id> memberIndex;
  InitializationModeQualifier trigger;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::InitModeINTEL;
  }
  CastableUniquePointer<PropertyInitModeINTEL> clone() const
  {
    CastableUniquePointer<PropertyInitModeINTEL> result //
      {new PropertyInitModeINTEL};
    result->memberIndex = memberIndex;
    result->trigger = trigger;
    return result;
  }
  CastableUniquePointer<PropertyInitModeINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyInitModeINTEL> result //
      {new PropertyInitModeINTEL};
    result->memberIndex = i.value;
    result->trigger = trigger;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyImplementInRegisterMapINTEL
{
  const Decoration type = Decoration::ImplementInRegisterMapINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger value;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::ImplementInRegisterMapINTEL;
  }
  CastableUniquePointer<PropertyImplementInRegisterMapINTEL> clone() const
  {
    CastableUniquePointer<PropertyImplementInRegisterMapINTEL> result //
      {new PropertyImplementInRegisterMapINTEL};
    result->memberIndex = memberIndex;
    result->value = value;
    return result;
  }
  CastableUniquePointer<PropertyImplementInRegisterMapINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyImplementInRegisterMapINTEL> result //
      {new PropertyImplementInRegisterMapINTEL};
    result->memberIndex = i.value;
    result->value = value;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCacheControlLoadINTEL
{
  const Decoration type = Decoration::CacheControlLoadINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger cacheLevel;
  LoadCacheControl cacheControl;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::CacheControlLoadINTEL;
  }
  CastableUniquePointer<PropertyCacheControlLoadINTEL> clone() const
  {
    CastableUniquePointer<PropertyCacheControlLoadINTEL> result //
      {new PropertyCacheControlLoadINTEL};
    result->memberIndex = memberIndex;
    result->cacheLevel = cacheLevel;
    result->cacheControl = cacheControl;
    return result;
  }
  CastableUniquePointer<PropertyCacheControlLoadINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCacheControlLoadINTEL> result //
      {new PropertyCacheControlLoadINTEL};
    result->memberIndex = i.value;
    result->cacheLevel = cacheLevel;
    result->cacheControl = cacheControl;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct PropertyCacheControlStoreINTEL
{
  const Decoration type = Decoration::CacheControlStoreINTEL;
  eastl::optional<Id> memberIndex;
  LiteralInteger cacheLevel;
  StoreCacheControl cacheControl;
  template <typename T>
  static constexpr bool is(const T *value)
  {
    return value->type == Decoration::CacheControlStoreINTEL;
  }
  CastableUniquePointer<PropertyCacheControlStoreINTEL> clone() const
  {
    CastableUniquePointer<PropertyCacheControlStoreINTEL> result //
      {new PropertyCacheControlStoreINTEL};
    result->memberIndex = memberIndex;
    result->cacheLevel = cacheLevel;
    result->cacheControl = cacheControl;
    return result;
  }
  CastableUniquePointer<PropertyCacheControlStoreINTEL> cloneWithMemberIndexOverride(LiteralInteger i) const
  {
    CastableUniquePointer<PropertyCacheControlStoreINTEL> result //
      {new PropertyCacheControlStoreINTEL};
    result->memberIndex = i.value;
    result->cacheLevel = cacheLevel;
    result->cacheControl = cacheControl;
    return result;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
// in memory nodes
struct Node
{
  NodeKind nodeKind;
  Op opCode;
  Id extOpCode;
  ExtendedGrammar grammarId;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(Node *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpConstantCompositeContinuedINTEL
{
  const NodeKind nodeKind = NodeKind::Node;
  const Op opCode = Op::OpConstantCompositeContinuedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpConstantCompositeContinuedINTEL() = default;
  ~NodeOpConstantCompositeContinuedINTEL() = default;
  NodeOpConstantCompositeContinuedINTEL(const NodeOpConstantCompositeContinuedINTEL &) = delete;
  NodeOpConstantCompositeContinuedINTEL &operator=(const NodeOpConstantCompositeContinuedINTEL &) = delete;
  NodeOpConstantCompositeContinuedINTEL(NodeOpConstantCompositeContinuedINTEL &&) = delete;
  NodeOpConstantCompositeContinuedINTEL &operator=(NodeOpConstantCompositeContinuedINTEL &&) = delete;
  NodeOpConstantCompositeContinuedINTEL(NodePointer<NodeId> *constituents = nullptr, size_t constituents_count = 0)
  {
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpNop
{
  const NodeKind nodeKind = NodeKind::Node;
  const Op opCode = Op::OpNop;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpNop() = default;
  ~NodeOpNop() = default;
  NodeOpNop(const NodeOpNop &) = delete;
  NodeOpNop &operator=(const NodeOpNop &) = delete;
  NodeOpNop(NodeOpNop &&) = delete;
  NodeOpNop &operator=(NodeOpNop &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSpecConstantCompositeContinuedINTEL
{
  const NodeKind nodeKind = NodeKind::Node;
  const Op opCode = Op::OpSpecConstantCompositeContinuedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpSpecConstantCompositeContinuedINTEL() = default;
  ~NodeOpSpecConstantCompositeContinuedINTEL() = default;
  NodeOpSpecConstantCompositeContinuedINTEL(const NodeOpSpecConstantCompositeContinuedINTEL &) = delete;
  NodeOpSpecConstantCompositeContinuedINTEL &operator=(const NodeOpSpecConstantCompositeContinuedINTEL &) = delete;
  NodeOpSpecConstantCompositeContinuedINTEL(NodeOpSpecConstantCompositeContinuedINTEL &&) = delete;
  NodeOpSpecConstantCompositeContinuedINTEL &operator=(NodeOpSpecConstantCompositeContinuedINTEL &&) = delete;
  NodeOpSpecConstantCompositeContinuedINTEL(NodePointer<NodeId> *constituents = nullptr, size_t constituents_count = 0)
  {
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeStructContinuedINTEL
{
  const NodeKind nodeKind = NodeKind::Node;
  const Op opCode = Op::OpTypeStructContinuedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  eastl::vector<NodePointer<NodeId>> param0;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&ref : param0)
      visitor(ref);
  }
  NodeOpTypeStructContinuedINTEL() = default;
  ~NodeOpTypeStructContinuedINTEL() = default;
  NodeOpTypeStructContinuedINTEL(const NodeOpTypeStructContinuedINTEL &) = delete;
  NodeOpTypeStructContinuedINTEL &operator=(const NodeOpTypeStructContinuedINTEL &) = delete;
  NodeOpTypeStructContinuedINTEL(NodeOpTypeStructContinuedINTEL &&) = delete;
  NodeOpTypeStructContinuedINTEL &operator=(NodeOpTypeStructContinuedINTEL &&) = delete;
  NodeOpTypeStructContinuedINTEL(NodePointer<NodeId> *param_0 = nullptr, size_t param_0_count = 0)
  {
    this->param0.assign(param_0, param_0 + param_0_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeAction : Node
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpBeginInvocationInterlockEXT
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpBeginInvocationInterlockEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpBeginInvocationInterlockEXT() = default;
  ~NodeOpBeginInvocationInterlockEXT() = default;
  NodeOpBeginInvocationInterlockEXT(const NodeOpBeginInvocationInterlockEXT &) = delete;
  NodeOpBeginInvocationInterlockEXT &operator=(const NodeOpBeginInvocationInterlockEXT &) = delete;
  NodeOpBeginInvocationInterlockEXT(NodeOpBeginInvocationInterlockEXT &&) = delete;
  NodeOpBeginInvocationInterlockEXT &operator=(NodeOpBeginInvocationInterlockEXT &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDemoteToHelperInvocation
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpDemoteToHelperInvocation;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpDemoteToHelperInvocation() = default;
  ~NodeOpDemoteToHelperInvocation() = default;
  NodeOpDemoteToHelperInvocation(const NodeOpDemoteToHelperInvocation &) = delete;
  NodeOpDemoteToHelperInvocation &operator=(const NodeOpDemoteToHelperInvocation &) = delete;
  NodeOpDemoteToHelperInvocation(NodeOpDemoteToHelperInvocation &&) = delete;
  NodeOpDemoteToHelperInvocation &operator=(NodeOpDemoteToHelperInvocation &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDemoteToHelperInvocationEXT
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpDemoteToHelperInvocationEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpDemoteToHelperInvocationEXT() = default;
  ~NodeOpDemoteToHelperInvocationEXT() = default;
  NodeOpDemoteToHelperInvocationEXT(const NodeOpDemoteToHelperInvocationEXT &) = delete;
  NodeOpDemoteToHelperInvocationEXT &operator=(const NodeOpDemoteToHelperInvocationEXT &) = delete;
  NodeOpDemoteToHelperInvocationEXT(NodeOpDemoteToHelperInvocationEXT &&) = delete;
  NodeOpDemoteToHelperInvocationEXT &operator=(NodeOpDemoteToHelperInvocationEXT &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEmitVertex
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpEmitVertex;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpEmitVertex() = default;
  ~NodeOpEmitVertex() = default;
  NodeOpEmitVertex(const NodeOpEmitVertex &) = delete;
  NodeOpEmitVertex &operator=(const NodeOpEmitVertex &) = delete;
  NodeOpEmitVertex(NodeOpEmitVertex &&) = delete;
  NodeOpEmitVertex &operator=(NodeOpEmitVertex &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEndInvocationInterlockEXT
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpEndInvocationInterlockEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpEndInvocationInterlockEXT() = default;
  ~NodeOpEndInvocationInterlockEXT() = default;
  NodeOpEndInvocationInterlockEXT(const NodeOpEndInvocationInterlockEXT &) = delete;
  NodeOpEndInvocationInterlockEXT &operator=(const NodeOpEndInvocationInterlockEXT &) = delete;
  NodeOpEndInvocationInterlockEXT(NodeOpEndInvocationInterlockEXT &&) = delete;
  NodeOpEndInvocationInterlockEXT &operator=(NodeOpEndInvocationInterlockEXT &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEndPrimitive
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpEndPrimitive;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpEndPrimitive() = default;
  ~NodeOpEndPrimitive() = default;
  NodeOpEndPrimitive(const NodeOpEndPrimitive &) = delete;
  NodeOpEndPrimitive &operator=(const NodeOpEndPrimitive &) = delete;
  NodeOpEndPrimitive(NodeOpEndPrimitive &&) = delete;
  NodeOpEndPrimitive &operator=(NodeOpEndPrimitive &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIgnoreIntersectionKHR
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpIgnoreIntersectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpIgnoreIntersectionKHR() = default;
  ~NodeOpIgnoreIntersectionKHR() = default;
  NodeOpIgnoreIntersectionKHR(const NodeOpIgnoreIntersectionKHR &) = delete;
  NodeOpIgnoreIntersectionKHR &operator=(const NodeOpIgnoreIntersectionKHR &) = delete;
  NodeOpIgnoreIntersectionKHR(NodeOpIgnoreIntersectionKHR &&) = delete;
  NodeOpIgnoreIntersectionKHR &operator=(NodeOpIgnoreIntersectionKHR &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIgnoreIntersectionNV
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpIgnoreIntersectionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpIgnoreIntersectionNV() = default;
  ~NodeOpIgnoreIntersectionNV() = default;
  NodeOpIgnoreIntersectionNV(const NodeOpIgnoreIntersectionNV &) = delete;
  NodeOpIgnoreIntersectionNV &operator=(const NodeOpIgnoreIntersectionNV &) = delete;
  NodeOpIgnoreIntersectionNV(NodeOpIgnoreIntersectionNV &&) = delete;
  NodeOpIgnoreIntersectionNV &operator=(NodeOpIgnoreIntersectionNV &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLine
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpLine;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> file;
  LiteralInteger line;
  LiteralInteger column;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(file);
  }
  NodeOpLine() = default;
  ~NodeOpLine() = default;
  NodeOpLine(const NodeOpLine &) = delete;
  NodeOpLine &operator=(const NodeOpLine &) = delete;
  NodeOpLine(NodeOpLine &&) = delete;
  NodeOpLine &operator=(NodeOpLine &&) = delete;
  NodeOpLine(NodePointer<NodeId> file, LiteralInteger line, LiteralInteger column)
  {
    this->file = file;
    this->line = line;
    this->column = column;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpNoLine
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpNoLine;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpNoLine() = default;
  ~NodeOpNoLine() = default;
  NodeOpNoLine(const NodeOpNoLine &) = delete;
  NodeOpNoLine &operator=(const NodeOpNoLine &) = delete;
  NodeOpNoLine(NodeOpNoLine &&) = delete;
  NodeOpNoLine &operator=(NodeOpNoLine &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTerminateInvocation
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpTerminateInvocation;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTerminateInvocation() = default;
  ~NodeOpTerminateInvocation() = default;
  NodeOpTerminateInvocation(const NodeOpTerminateInvocation &) = delete;
  NodeOpTerminateInvocation &operator=(const NodeOpTerminateInvocation &) = delete;
  NodeOpTerminateInvocation(NodeOpTerminateInvocation &&) = delete;
  NodeOpTerminateInvocation &operator=(NodeOpTerminateInvocation &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTerminateRayKHR
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpTerminateRayKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTerminateRayKHR() = default;
  ~NodeOpTerminateRayKHR() = default;
  NodeOpTerminateRayKHR(const NodeOpTerminateRayKHR &) = delete;
  NodeOpTerminateRayKHR &operator=(const NodeOpTerminateRayKHR &) = delete;
  NodeOpTerminateRayKHR(NodeOpTerminateRayKHR &&) = delete;
  NodeOpTerminateRayKHR &operator=(NodeOpTerminateRayKHR &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTerminateRayNV
{
  const NodeKind nodeKind = NodeKind::Action;
  const Op opCode = Op::OpTerminateRayNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTerminateRayNV() = default;
  ~NodeOpTerminateRayNV() = default;
  NodeOpTerminateRayNV(const NodeOpTerminateRayNV &) = delete;
  NodeOpTerminateRayNV &operator=(const NodeOpTerminateRayNV &) = delete;
  NodeOpTerminateRayNV(NodeOpTerminateRayNV &&) = delete;
  NodeOpTerminateRayNV &operator=(NodeOpTerminateRayNV &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeBinaryAction : NodeAction
{
  NodePointer<NodeId> first;
  NodePointer<NodeId> second;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeBinaryAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpCopyMemory
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpCopyMemory;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> target;
  NodePointer<NodeId> source;
  eastl::optional<MemoryAccessMask> memoryAccess0;
  // extra values for memoryAccess0
  LiteralInteger memoryAccess0Aligned;
  NodePointer<NodeOperation> memoryAccess0MakePointerAvailable;
  NodePointer<NodeOperation> memoryAccess0MakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccess0MakePointerVisible;
  NodePointer<NodeOperation> memoryAccess0MakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccess0AliasScopeINTELMask;
  NodePointer<NodeId> memoryAccess0NoAliasINTELMask;
  eastl::optional<MemoryAccessMask> memoryAccess1;
  // extra values for memoryAccess1
  LiteralInteger memoryAccess1Aligned;
  NodePointer<NodeOperation> memoryAccess1MakePointerAvailable;
  NodePointer<NodeOperation> memoryAccess1MakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccess1MakePointerVisible;
  NodePointer<NodeOperation> memoryAccess1MakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccess1AliasScopeINTELMask;
  NodePointer<NodeId> memoryAccess1NoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(target);
    visitor(source);
    if (memoryAccess0MakePointerAvailable)
      visitor(memoryAccess0MakePointerAvailable);
    if (memoryAccess0MakePointerAvailableKHR)
      visitor(memoryAccess0MakePointerAvailableKHR);
    if (memoryAccess0MakePointerVisible)
      visitor(memoryAccess0MakePointerVisible);
    if (memoryAccess0MakePointerVisibleKHR)
      visitor(memoryAccess0MakePointerVisibleKHR);
    if (memoryAccess0AliasScopeINTELMask)
      visitor(memoryAccess0AliasScopeINTELMask);
    if (memoryAccess0NoAliasINTELMask)
      visitor(memoryAccess0NoAliasINTELMask);
    if (memoryAccess1MakePointerAvailable)
      visitor(memoryAccess1MakePointerAvailable);
    if (memoryAccess1MakePointerAvailableKHR)
      visitor(memoryAccess1MakePointerAvailableKHR);
    if (memoryAccess1MakePointerVisible)
      visitor(memoryAccess1MakePointerVisible);
    if (memoryAccess1MakePointerVisibleKHR)
      visitor(memoryAccess1MakePointerVisibleKHR);
    if (memoryAccess1AliasScopeINTELMask)
      visitor(memoryAccess1AliasScopeINTELMask);
    if (memoryAccess1NoAliasINTELMask)
      visitor(memoryAccess1NoAliasINTELMask);
  }
  NodeOpCopyMemory() = default;
  ~NodeOpCopyMemory() = default;
  NodeOpCopyMemory(const NodeOpCopyMemory &) = delete;
  NodeOpCopyMemory &operator=(const NodeOpCopyMemory &) = delete;
  NodeOpCopyMemory(NodeOpCopyMemory &&) = delete;
  NodeOpCopyMemory &operator=(NodeOpCopyMemory &&) = delete;
  NodeOpCopyMemory(NodePointer<NodeId> target, NodePointer<NodeId> source, eastl::optional<MemoryAccessMask> memory_access0,
    eastl::optional<LiteralInteger> memory_access0_aligned = {}, NodePointer<NodeOperation> memory_access0_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access0_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access0_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access0_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access0_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access0_noAliasINTELMask = {}, eastl::optional<MemoryAccessMask> memory_access1 = {},
    eastl::optional<LiteralInteger> memory_access1_aligned = {}, NodePointer<NodeOperation> memory_access1_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access1_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access1_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access1_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access1_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access1_noAliasINTELMask = {})
  {
    this->target = target;
    this->source = source;
    this->memoryAccess0 = memory_access0;
    if (memory_access0_aligned)
      this->memoryAccess0Aligned = *memory_access0_aligned;
    this->memoryAccess0MakePointerAvailable = memory_access0_makePointerAvailable;
    this->memoryAccess0MakePointerAvailableKHR = memory_access0_makePointerAvailableKHR;
    this->memoryAccess0MakePointerVisible = memory_access0_makePointerVisible;
    this->memoryAccess0MakePointerVisibleKHR = memory_access0_makePointerVisibleKHR;
    this->memoryAccess0AliasScopeINTELMask = memory_access0_aliasScopeINTELMask;
    this->memoryAccess0NoAliasINTELMask = memory_access0_noAliasINTELMask;
    this->memoryAccess1 = memory_access1;
    if (memory_access1_aligned)
      this->memoryAccess1Aligned = *memory_access1_aligned;
    this->memoryAccess1MakePointerAvailable = memory_access1_makePointerAvailable;
    this->memoryAccess1MakePointerAvailableKHR = memory_access1_makePointerAvailableKHR;
    this->memoryAccess1MakePointerVisible = memory_access1_makePointerVisible;
    this->memoryAccess1MakePointerVisibleKHR = memory_access1_makePointerVisibleKHR;
    this->memoryAccess1AliasScopeINTELMask = memory_access1_aliasScopeINTELMask;
    this->memoryAccess1NoAliasINTELMask = memory_access1_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpExecuteCallableKHR
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpExecuteCallableKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> sbtIndex;
  NodePointer<NodeId> callableData;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(sbtIndex);
    visitor(callableData);
  }
  NodeOpExecuteCallableKHR() = default;
  ~NodeOpExecuteCallableKHR() = default;
  NodeOpExecuteCallableKHR(const NodeOpExecuteCallableKHR &) = delete;
  NodeOpExecuteCallableKHR &operator=(const NodeOpExecuteCallableKHR &) = delete;
  NodeOpExecuteCallableKHR(NodeOpExecuteCallableKHR &&) = delete;
  NodeOpExecuteCallableKHR &operator=(NodeOpExecuteCallableKHR &&) = delete;
  NodeOpExecuteCallableKHR(NodePointer<NodeId> s_b_t_index, NodePointer<NodeId> callable_data)
  {
    this->sbtIndex = s_b_t_index;
    this->callableData = callable_data;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpExecuteCallableNV
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpExecuteCallableNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> sbtIndex;
  NodePointer<NodeId> callableDataid;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(sbtIndex);
    visitor(callableDataid);
  }
  NodeOpExecuteCallableNV() = default;
  ~NodeOpExecuteCallableNV() = default;
  NodeOpExecuteCallableNV(const NodeOpExecuteCallableNV &) = delete;
  NodeOpExecuteCallableNV &operator=(const NodeOpExecuteCallableNV &) = delete;
  NodeOpExecuteCallableNV(NodeOpExecuteCallableNV &&) = delete;
  NodeOpExecuteCallableNV &operator=(NodeOpExecuteCallableNV &&) = delete;
  NodeOpExecuteCallableNV(NodePointer<NodeId> s_b_t_index, NodePointer<NodeId> callable_data_id)
  {
    this->sbtIndex = s_b_t_index;
    this->callableDataid = callable_data_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectExecuteShaderNV
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpHitObjectExecuteShaderNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(payload);
  }
  NodeOpHitObjectExecuteShaderNV() = default;
  ~NodeOpHitObjectExecuteShaderNV() = default;
  NodeOpHitObjectExecuteShaderNV(const NodeOpHitObjectExecuteShaderNV &) = delete;
  NodeOpHitObjectExecuteShaderNV &operator=(const NodeOpHitObjectExecuteShaderNV &) = delete;
  NodeOpHitObjectExecuteShaderNV(NodeOpHitObjectExecuteShaderNV &&) = delete;
  NodeOpHitObjectExecuteShaderNV &operator=(NodeOpHitObjectExecuteShaderNV &&) = delete;
  NodeOpHitObjectExecuteShaderNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> payload)
  {
    this->hitObject = hit_object;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetAttributesNV
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpHitObjectGetAttributesNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> hitObjectAttribute;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(hitObjectAttribute);
  }
  NodeOpHitObjectGetAttributesNV() = default;
  ~NodeOpHitObjectGetAttributesNV() = default;
  NodeOpHitObjectGetAttributesNV(const NodeOpHitObjectGetAttributesNV &) = delete;
  NodeOpHitObjectGetAttributesNV &operator=(const NodeOpHitObjectGetAttributesNV &) = delete;
  NodeOpHitObjectGetAttributesNV(NodeOpHitObjectGetAttributesNV &&) = delete;
  NodeOpHitObjectGetAttributesNV &operator=(NodeOpHitObjectGetAttributesNV &&) = delete;
  NodeOpHitObjectGetAttributesNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> hit_object_attribute)
  {
    this->hitObject = hit_object;
    this->hitObjectAttribute = hit_object_attribute;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMaskedScatterINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpMaskedScatterINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> inputVector;
  NodePointer<NodeId> ptrVector;
  LiteralInteger alignment;
  NodePointer<NodeId> mask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(inputVector);
    visitor(ptrVector);
    visitor(mask);
  }
  NodeOpMaskedScatterINTEL() = default;
  ~NodeOpMaskedScatterINTEL() = default;
  NodeOpMaskedScatterINTEL(const NodeOpMaskedScatterINTEL &) = delete;
  NodeOpMaskedScatterINTEL &operator=(const NodeOpMaskedScatterINTEL &) = delete;
  NodeOpMaskedScatterINTEL(NodeOpMaskedScatterINTEL &&) = delete;
  NodeOpMaskedScatterINTEL &operator=(NodeOpMaskedScatterINTEL &&) = delete;
  NodeOpMaskedScatterINTEL(NodePointer<NodeId> input_vector, NodePointer<NodeId> ptr_vector, LiteralInteger alignment,
    NodePointer<NodeId> mask)
  {
    this->inputVector = input_vector;
    this->ptrVector = ptr_vector;
    this->alignment = alignment;
    this->mask = mask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGenerateIntersectionKHR
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpRayQueryGenerateIntersectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> hitT;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(rayQuery);
    visitor(hitT);
  }
  NodeOpRayQueryGenerateIntersectionKHR() = default;
  ~NodeOpRayQueryGenerateIntersectionKHR() = default;
  NodeOpRayQueryGenerateIntersectionKHR(const NodeOpRayQueryGenerateIntersectionKHR &) = delete;
  NodeOpRayQueryGenerateIntersectionKHR &operator=(const NodeOpRayQueryGenerateIntersectionKHR &) = delete;
  NodeOpRayQueryGenerateIntersectionKHR(NodeOpRayQueryGenerateIntersectionKHR &&) = delete;
  NodeOpRayQueryGenerateIntersectionKHR &operator=(NodeOpRayQueryGenerateIntersectionKHR &&) = delete;
  NodeOpRayQueryGenerateIntersectionKHR(NodePointer<NodeId> ray_query, NodePointer<NodeId> hit_t)
  {
    this->rayQuery = ray_query;
    this->hitT = hit_t;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReorderThreadWithHintNV
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpReorderThreadWithHintNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> hint;
  NodePointer<NodeId> bits;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hint);
    visitor(bits);
  }
  NodeOpReorderThreadWithHintNV() = default;
  ~NodeOpReorderThreadWithHintNV() = default;
  NodeOpReorderThreadWithHintNV(const NodeOpReorderThreadWithHintNV &) = delete;
  NodeOpReorderThreadWithHintNV &operator=(const NodeOpReorderThreadWithHintNV &) = delete;
  NodeOpReorderThreadWithHintNV(NodeOpReorderThreadWithHintNV &&) = delete;
  NodeOpReorderThreadWithHintNV &operator=(NodeOpReorderThreadWithHintNV &&) = delete;
  NodeOpReorderThreadWithHintNV(NodePointer<NodeId> hint, NodePointer<NodeId> bits)
  {
    this->hint = hint;
    this->bits = bits;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSetMeshOutputsEXT
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpSetMeshOutputsEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> vertexCount;
  NodePointer<NodeId> primitiveCount;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(vertexCount);
    visitor(primitiveCount);
  }
  NodeOpSetMeshOutputsEXT() = default;
  ~NodeOpSetMeshOutputsEXT() = default;
  NodeOpSetMeshOutputsEXT(const NodeOpSetMeshOutputsEXT &) = delete;
  NodeOpSetMeshOutputsEXT &operator=(const NodeOpSetMeshOutputsEXT &) = delete;
  NodeOpSetMeshOutputsEXT(NodeOpSetMeshOutputsEXT &&) = delete;
  NodeOpSetMeshOutputsEXT &operator=(NodeOpSetMeshOutputsEXT &&) = delete;
  NodeOpSetMeshOutputsEXT(NodePointer<NodeId> vertex_count, NodePointer<NodeId> primitive_count)
  {
    this->vertexCount = vertex_count;
    this->primitiveCount = primitive_count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSetUserEventStatus
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpSetUserEventStatus;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> event;
  NodePointer<NodeId> status;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(event);
    visitor(status);
  }
  NodeOpSetUserEventStatus() = default;
  ~NodeOpSetUserEventStatus() = default;
  NodeOpSetUserEventStatus(const NodeOpSetUserEventStatus &) = delete;
  NodeOpSetUserEventStatus &operator=(const NodeOpSetUserEventStatus &) = delete;
  NodeOpSetUserEventStatus(NodeOpSetUserEventStatus &&) = delete;
  NodeOpSetUserEventStatus &operator=(NodeOpSetUserEventStatus &&) = delete;
  NodeOpSetUserEventStatus(NodePointer<NodeId> event, NodePointer<NodeId> status)
  {
    this->event = event;
    this->status = status;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpStore
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpStore;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> object;
  eastl::optional<MemoryAccessMask> memoryAccess;
  // extra values for memoryAccess
  LiteralInteger memoryAccessAligned;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailable;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccessMakePointerVisible;
  NodePointer<NodeOperation> memoryAccessMakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccessAliasScopeINTELMask;
  NodePointer<NodeId> memoryAccessNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
    visitor(object);
    if (memoryAccessMakePointerAvailable)
      visitor(memoryAccessMakePointerAvailable);
    if (memoryAccessMakePointerAvailableKHR)
      visitor(memoryAccessMakePointerAvailableKHR);
    if (memoryAccessMakePointerVisible)
      visitor(memoryAccessMakePointerVisible);
    if (memoryAccessMakePointerVisibleKHR)
      visitor(memoryAccessMakePointerVisibleKHR);
    if (memoryAccessAliasScopeINTELMask)
      visitor(memoryAccessAliasScopeINTELMask);
    if (memoryAccessNoAliasINTELMask)
      visitor(memoryAccessNoAliasINTELMask);
  }
  NodeOpStore() = default;
  ~NodeOpStore() = default;
  NodeOpStore(const NodeOpStore &) = delete;
  NodeOpStore &operator=(const NodeOpStore &) = delete;
  NodeOpStore(NodeOpStore &&) = delete;
  NodeOpStore &operator=(NodeOpStore &&) = delete;
  NodeOpStore(NodePointer<NodeId> pointer, NodePointer<NodeId> object, eastl::optional<MemoryAccessMask> memory_access,
    eastl::optional<LiteralInteger> memory_access_aligned = {}, NodePointer<NodeOperation> memory_access_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access_noAliasINTELMask = {})
  {
    this->pointer = pointer;
    this->object = object;
    this->memoryAccess = memory_access;
    if (memory_access_aligned)
      this->memoryAccessAligned = *memory_access_aligned;
    this->memoryAccessMakePointerAvailable = memory_access_makePointerAvailable;
    this->memoryAccessMakePointerAvailableKHR = memory_access_makePointerAvailableKHR;
    this->memoryAccessMakePointerVisible = memory_access_makePointerVisible;
    this->memoryAccessMakePointerVisibleKHR = memory_access_makePointerVisibleKHR;
    this->memoryAccessAliasScopeINTELMask = memory_access_aliasScopeINTELMask;
    this->memoryAccessNoAliasINTELMask = memory_access_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupBlockWriteINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpSubgroupBlockWriteINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> ptr;
  NodePointer<NodeId> data;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(ptr);
    visitor(data);
  }
  NodeOpSubgroupBlockWriteINTEL() = default;
  ~NodeOpSubgroupBlockWriteINTEL() = default;
  NodeOpSubgroupBlockWriteINTEL(const NodeOpSubgroupBlockWriteINTEL &) = delete;
  NodeOpSubgroupBlockWriteINTEL &operator=(const NodeOpSubgroupBlockWriteINTEL &) = delete;
  NodeOpSubgroupBlockWriteINTEL(NodeOpSubgroupBlockWriteINTEL &&) = delete;
  NodeOpSubgroupBlockWriteINTEL &operator=(NodeOpSubgroupBlockWriteINTEL &&) = delete;
  NodeOpSubgroupBlockWriteINTEL(NodePointer<NodeId> ptr, NodePointer<NodeId> data)
  {
    this->ptr = ptr;
    this->data = data;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpWritePackedPrimitiveIndices4x8NV
{
  const NodeKind nodeKind = NodeKind::BinaryAction;
  const Op opCode = Op::OpWritePackedPrimitiveIndices4x8NV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> indexOffset;
  NodePointer<NodeId> packedIndices;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(indexOffset);
    visitor(packedIndices);
  }
  NodeOpWritePackedPrimitiveIndices4x8NV() = default;
  ~NodeOpWritePackedPrimitiveIndices4x8NV() = default;
  NodeOpWritePackedPrimitiveIndices4x8NV(const NodeOpWritePackedPrimitiveIndices4x8NV &) = delete;
  NodeOpWritePackedPrimitiveIndices4x8NV &operator=(const NodeOpWritePackedPrimitiveIndices4x8NV &) = delete;
  NodeOpWritePackedPrimitiveIndices4x8NV(NodeOpWritePackedPrimitiveIndices4x8NV &&) = delete;
  NodeOpWritePackedPrimitiveIndices4x8NV &operator=(NodeOpWritePackedPrimitiveIndices4x8NV &&) = delete;
  NodeOpWritePackedPrimitiveIndices4x8NV(NodePointer<NodeId> index_offset, NodePointer<NodeId> packed_indices)
  {
    this->indexOffset = index_offset;
    this->packedIndices = packed_indices;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeBinaryAction::visit(NodeBinaryAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::BinaryAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpCopyMemory:
        if (visitor(reinterpret_cast<NodeOpCopyMemory *>(node)))
          return true;
        break;
      case Op::OpExecuteCallableKHR:
        if (visitor(reinterpret_cast<NodeOpExecuteCallableKHR *>(node)))
          return true;
        break;
      case Op::OpExecuteCallableNV:
        if (visitor(reinterpret_cast<NodeOpExecuteCallableNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectExecuteShaderNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectExecuteShaderNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetAttributesNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetAttributesNV *>(node)))
          return true;
        break;
      case Op::OpMaskedScatterINTEL:
        if (visitor(reinterpret_cast<NodeOpMaskedScatterINTEL *>(node)))
          return true;
        break;
      case Op::OpRayQueryGenerateIntersectionKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGenerateIntersectionKHR *>(node)))
          return true;
        break;
      case Op::OpReorderThreadWithHintNV:
        if (visitor(reinterpret_cast<NodeOpReorderThreadWithHintNV *>(node)))
          return true;
        break;
      case Op::OpSetMeshOutputsEXT:
        if (visitor(reinterpret_cast<NodeOpSetMeshOutputsEXT *>(node)))
          return true;
        break;
      case Op::OpSetUserEventStatus:
        if (visitor(reinterpret_cast<NodeOpSetUserEventStatus *>(node)))
          return true;
        break;
      case Op::OpStore:
        if (visitor(reinterpret_cast<NodeOpStore *>(node)))
          return true;
        break;
      case Op::OpSubgroupBlockWriteINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupBlockWriteINTEL *>(node)))
          return true;
        break;
      case Op::OpWritePackedPrimitiveIndices4x8NV:
        if (visitor(reinterpret_cast<NodeOpWritePackedPrimitiveIndices4x8NV *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeImageAction : NodeAction
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeImageAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpImageWrite
{
  const NodeKind nodeKind = NodeKind::ImageAction;
  const Op opCode = Op::OpImageWrite;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> texel;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(image);
    visitor(coordinate);
    visitor(texel);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageWrite() = default;
  ~NodeOpImageWrite() = default;
  NodeOpImageWrite(const NodeOpImageWrite &) = delete;
  NodeOpImageWrite &operator=(const NodeOpImageWrite &) = delete;
  NodeOpImageWrite(NodeOpImageWrite &&) = delete;
  NodeOpImageWrite &operator=(NodeOpImageWrite &&) = delete;
  NodeOpImageWrite(NodePointer<NodeId> image, NodePointer<NodeId> coordinate, NodePointer<NodeId> texel,
    eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->image = image;
    this->coordinate = coordinate;
    this->texel = texel;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupImageBlockWriteINTEL
{
  const NodeKind nodeKind = NodeKind::ImageAction;
  const Op opCode = Op::OpSubgroupImageBlockWriteINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> data;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(image);
    visitor(coordinate);
    visitor(data);
  }
  NodeOpSubgroupImageBlockWriteINTEL() = default;
  ~NodeOpSubgroupImageBlockWriteINTEL() = default;
  NodeOpSubgroupImageBlockWriteINTEL(const NodeOpSubgroupImageBlockWriteINTEL &) = delete;
  NodeOpSubgroupImageBlockWriteINTEL &operator=(const NodeOpSubgroupImageBlockWriteINTEL &) = delete;
  NodeOpSubgroupImageBlockWriteINTEL(NodeOpSubgroupImageBlockWriteINTEL &&) = delete;
  NodeOpSubgroupImageBlockWriteINTEL &operator=(NodeOpSubgroupImageBlockWriteINTEL &&) = delete;
  NodeOpSubgroupImageBlockWriteINTEL(NodePointer<NodeId> image, NodePointer<NodeId> coordinate, NodePointer<NodeId> data)
  {
    this->image = image;
    this->coordinate = coordinate;
    this->data = data;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupImageMediaBlockWriteINTEL
{
  const NodeKind nodeKind = NodeKind::ImageAction;
  const Op opCode = Op::OpSubgroupImageMediaBlockWriteINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> width;
  NodePointer<NodeId> height;
  NodePointer<NodeId> data;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(image);
    visitor(coordinate);
    visitor(width);
    visitor(height);
    visitor(data);
  }
  NodeOpSubgroupImageMediaBlockWriteINTEL() = default;
  ~NodeOpSubgroupImageMediaBlockWriteINTEL() = default;
  NodeOpSubgroupImageMediaBlockWriteINTEL(const NodeOpSubgroupImageMediaBlockWriteINTEL &) = delete;
  NodeOpSubgroupImageMediaBlockWriteINTEL &operator=(const NodeOpSubgroupImageMediaBlockWriteINTEL &) = delete;
  NodeOpSubgroupImageMediaBlockWriteINTEL(NodeOpSubgroupImageMediaBlockWriteINTEL &&) = delete;
  NodeOpSubgroupImageMediaBlockWriteINTEL &operator=(NodeOpSubgroupImageMediaBlockWriteINTEL &&) = delete;
  NodeOpSubgroupImageMediaBlockWriteINTEL(NodePointer<NodeId> image, NodePointer<NodeId> coordinate, NodePointer<NodeId> width,
    NodePointer<NodeId> height, NodePointer<NodeId> data)
  {
    this->image = image;
    this->coordinate = coordinate;
    this->width = width;
    this->height = height;
    this->data = data;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeImageAction::visit(NodeImageAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::ImageAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpImageWrite:
        if (visitor(reinterpret_cast<NodeOpImageWrite *>(node)))
          return true;
        break;
      case Op::OpSubgroupImageBlockWriteINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupImageBlockWriteINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupImageMediaBlockWriteINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupImageMediaBlockWriteINTEL *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeMultinaryAction : NodeAction
{
  Id pCount;
  // operands can be more, this depends on the opcode
  NodePointer<NodeId> operands[4];
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeMultinaryAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpCommitReadPipe
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpCommitReadPipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pipe);
    visitor(reserveId);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpCommitReadPipe() = default;
  ~NodeOpCommitReadPipe() = default;
  NodeOpCommitReadPipe(const NodeOpCommitReadPipe &) = delete;
  NodeOpCommitReadPipe &operator=(const NodeOpCommitReadPipe &) = delete;
  NodeOpCommitReadPipe(NodeOpCommitReadPipe &&) = delete;
  NodeOpCommitReadPipe &operator=(NodeOpCommitReadPipe &&) = delete;
  NodeOpCommitReadPipe(NodePointer<NodeId> pipe, NodePointer<NodeId> reserve_id, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCommitWritePipe
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpCommitWritePipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pipe);
    visitor(reserveId);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpCommitWritePipe() = default;
  ~NodeOpCommitWritePipe() = default;
  NodeOpCommitWritePipe(const NodeOpCommitWritePipe &) = delete;
  NodeOpCommitWritePipe &operator=(const NodeOpCommitWritePipe &) = delete;
  NodeOpCommitWritePipe(NodeOpCommitWritePipe &&) = delete;
  NodeOpCommitWritePipe &operator=(NodeOpCommitWritePipe &&) = delete;
  NodeOpCommitWritePipe(NodePointer<NodeId> pipe, NodePointer<NodeId> reserve_id, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixStoreNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpCooperativeMatrixStoreNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 4;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> object;
  NodePointer<NodeId> stride;
  NodePointer<NodeId> columnMajor;
  eastl::optional<MemoryAccessMask> memoryAccess;
  // extra values for memoryAccess
  LiteralInteger memoryAccessAligned;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailable;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccessMakePointerVisible;
  NodePointer<NodeOperation> memoryAccessMakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccessAliasScopeINTELMask;
  NodePointer<NodeId> memoryAccessNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
    visitor(object);
    visitor(stride);
    visitor(columnMajor);
    if (memoryAccessMakePointerAvailable)
      visitor(memoryAccessMakePointerAvailable);
    if (memoryAccessMakePointerAvailableKHR)
      visitor(memoryAccessMakePointerAvailableKHR);
    if (memoryAccessMakePointerVisible)
      visitor(memoryAccessMakePointerVisible);
    if (memoryAccessMakePointerVisibleKHR)
      visitor(memoryAccessMakePointerVisibleKHR);
    if (memoryAccessAliasScopeINTELMask)
      visitor(memoryAccessAliasScopeINTELMask);
    if (memoryAccessNoAliasINTELMask)
      visitor(memoryAccessNoAliasINTELMask);
  }
  NodeOpCooperativeMatrixStoreNV() = default;
  ~NodeOpCooperativeMatrixStoreNV() = default;
  NodeOpCooperativeMatrixStoreNV(const NodeOpCooperativeMatrixStoreNV &) = delete;
  NodeOpCooperativeMatrixStoreNV &operator=(const NodeOpCooperativeMatrixStoreNV &) = delete;
  NodeOpCooperativeMatrixStoreNV(NodeOpCooperativeMatrixStoreNV &&) = delete;
  NodeOpCooperativeMatrixStoreNV &operator=(NodeOpCooperativeMatrixStoreNV &&) = delete;
  NodeOpCooperativeMatrixStoreNV(NodePointer<NodeId> pointer, NodePointer<NodeId> object, NodePointer<NodeId> stride,
    NodePointer<NodeId> column_major, eastl::optional<MemoryAccessMask> memory_access,
    eastl::optional<LiteralInteger> memory_access_aligned = {}, NodePointer<NodeOperation> memory_access_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access_noAliasINTELMask = {})
  {
    this->pointer = pointer;
    this->object = object;
    this->stride = stride;
    this->columnMajor = column_major;
    this->memoryAccess = memory_access;
    if (memory_access_aligned)
      this->memoryAccessAligned = *memory_access_aligned;
    this->memoryAccessMakePointerAvailable = memory_access_makePointerAvailable;
    this->memoryAccessMakePointerAvailableKHR = memory_access_makePointerAvailableKHR;
    this->memoryAccessMakePointerVisible = memory_access_makePointerVisible;
    this->memoryAccessMakePointerVisibleKHR = memory_access_makePointerVisibleKHR;
    this->memoryAccessAliasScopeINTELMask = memory_access_aliasScopeINTELMask;
    this->memoryAccessNoAliasINTELMask = memory_access_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordHitMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordHitMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 14;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> primitiveId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> hitKind;
  NodePointer<NodeId> sbtRecordOffset;
  NodePointer<NodeId> sbtRecordStride;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> currentTime;
  NodePointer<NodeId> hitobjectAttributes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(instanceId);
    visitor(primitiveId);
    visitor(geometryIndex);
    visitor(hitKind);
    visitor(sbtRecordOffset);
    visitor(sbtRecordStride);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(currentTime);
    visitor(hitobjectAttributes);
  }
  NodeOpHitObjectRecordHitMotionNV() = default;
  ~NodeOpHitObjectRecordHitMotionNV() = default;
  NodeOpHitObjectRecordHitMotionNV(const NodeOpHitObjectRecordHitMotionNV &) = delete;
  NodeOpHitObjectRecordHitMotionNV &operator=(const NodeOpHitObjectRecordHitMotionNV &) = delete;
  NodeOpHitObjectRecordHitMotionNV(NodeOpHitObjectRecordHitMotionNV &&) = delete;
  NodeOpHitObjectRecordHitMotionNV &operator=(NodeOpHitObjectRecordHitMotionNV &&) = delete;
  NodeOpHitObjectRecordHitMotionNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> primitive_id, NodePointer<NodeId> geometry_index,
    NodePointer<NodeId> hit_kind, NodePointer<NodeId> s_b_t_record_offset, NodePointer<NodeId> s_b_t_record_stride,
    NodePointer<NodeId> origin, NodePointer<NodeId> t_min, NodePointer<NodeId> direction, NodePointer<NodeId> t_max,
    NodePointer<NodeId> current_time, NodePointer<NodeId> hit_object_attributes)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->instanceId = instance_id;
    this->primitiveId = primitive_id;
    this->geometryIndex = geometry_index;
    this->hitKind = hit_kind;
    this->sbtRecordOffset = s_b_t_record_offset;
    this->sbtRecordStride = s_b_t_record_stride;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->currentTime = current_time;
    this->hitobjectAttributes = hit_object_attributes;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordHitNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordHitNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 13;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> primitiveId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> hitKind;
  NodePointer<NodeId> sbtRecordOffset;
  NodePointer<NodeId> sbtRecordStride;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> hitobjectAttributes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(instanceId);
    visitor(primitiveId);
    visitor(geometryIndex);
    visitor(hitKind);
    visitor(sbtRecordOffset);
    visitor(sbtRecordStride);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(hitobjectAttributes);
  }
  NodeOpHitObjectRecordHitNV() = default;
  ~NodeOpHitObjectRecordHitNV() = default;
  NodeOpHitObjectRecordHitNV(const NodeOpHitObjectRecordHitNV &) = delete;
  NodeOpHitObjectRecordHitNV &operator=(const NodeOpHitObjectRecordHitNV &) = delete;
  NodeOpHitObjectRecordHitNV(NodeOpHitObjectRecordHitNV &&) = delete;
  NodeOpHitObjectRecordHitNV &operator=(NodeOpHitObjectRecordHitNV &&) = delete;
  NodeOpHitObjectRecordHitNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> primitive_id, NodePointer<NodeId> geometry_index,
    NodePointer<NodeId> hit_kind, NodePointer<NodeId> s_b_t_record_offset, NodePointer<NodeId> s_b_t_record_stride,
    NodePointer<NodeId> origin, NodePointer<NodeId> t_min, NodePointer<NodeId> direction, NodePointer<NodeId> t_max,
    NodePointer<NodeId> hit_object_attributes)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->instanceId = instance_id;
    this->primitiveId = primitive_id;
    this->geometryIndex = geometry_index;
    this->hitKind = hit_kind;
    this->sbtRecordOffset = s_b_t_record_offset;
    this->sbtRecordStride = s_b_t_record_stride;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->hitobjectAttributes = hit_object_attributes;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordHitWithIndexMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordHitWithIndexMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 13;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> primitiveId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> hitKind;
  NodePointer<NodeId> sbtRecordIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> currentTime;
  NodePointer<NodeId> hitobjectAttributes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(instanceId);
    visitor(primitiveId);
    visitor(geometryIndex);
    visitor(hitKind);
    visitor(sbtRecordIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(currentTime);
    visitor(hitobjectAttributes);
  }
  NodeOpHitObjectRecordHitWithIndexMotionNV() = default;
  ~NodeOpHitObjectRecordHitWithIndexMotionNV() = default;
  NodeOpHitObjectRecordHitWithIndexMotionNV(const NodeOpHitObjectRecordHitWithIndexMotionNV &) = delete;
  NodeOpHitObjectRecordHitWithIndexMotionNV &operator=(const NodeOpHitObjectRecordHitWithIndexMotionNV &) = delete;
  NodeOpHitObjectRecordHitWithIndexMotionNV(NodeOpHitObjectRecordHitWithIndexMotionNV &&) = delete;
  NodeOpHitObjectRecordHitWithIndexMotionNV &operator=(NodeOpHitObjectRecordHitWithIndexMotionNV &&) = delete;
  NodeOpHitObjectRecordHitWithIndexMotionNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> primitive_id, NodePointer<NodeId> geometry_index,
    NodePointer<NodeId> hit_kind, NodePointer<NodeId> s_b_t_record_index, NodePointer<NodeId> origin, NodePointer<NodeId> t_min,
    NodePointer<NodeId> direction, NodePointer<NodeId> t_max, NodePointer<NodeId> current_time,
    NodePointer<NodeId> hit_object_attributes)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->instanceId = instance_id;
    this->primitiveId = primitive_id;
    this->geometryIndex = geometry_index;
    this->hitKind = hit_kind;
    this->sbtRecordIndex = s_b_t_record_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->currentTime = current_time;
    this->hitobjectAttributes = hit_object_attributes;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordHitWithIndexNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordHitWithIndexNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 12;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> primitiveId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> hitKind;
  NodePointer<NodeId> sbtRecordIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> hitobjectAttributes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(instanceId);
    visitor(primitiveId);
    visitor(geometryIndex);
    visitor(hitKind);
    visitor(sbtRecordIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(hitobjectAttributes);
  }
  NodeOpHitObjectRecordHitWithIndexNV() = default;
  ~NodeOpHitObjectRecordHitWithIndexNV() = default;
  NodeOpHitObjectRecordHitWithIndexNV(const NodeOpHitObjectRecordHitWithIndexNV &) = delete;
  NodeOpHitObjectRecordHitWithIndexNV &operator=(const NodeOpHitObjectRecordHitWithIndexNV &) = delete;
  NodeOpHitObjectRecordHitWithIndexNV(NodeOpHitObjectRecordHitWithIndexNV &&) = delete;
  NodeOpHitObjectRecordHitWithIndexNV &operator=(NodeOpHitObjectRecordHitWithIndexNV &&) = delete;
  NodeOpHitObjectRecordHitWithIndexNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> primitive_id, NodePointer<NodeId> geometry_index,
    NodePointer<NodeId> hit_kind, NodePointer<NodeId> s_b_t_record_index, NodePointer<NodeId> origin, NodePointer<NodeId> t_min,
    NodePointer<NodeId> direction, NodePointer<NodeId> t_max, NodePointer<NodeId> hit_object_attributes)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->instanceId = instance_id;
    this->primitiveId = primitive_id;
    this->geometryIndex = geometry_index;
    this->hitKind = hit_kind;
    this->sbtRecordIndex = s_b_t_record_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->hitobjectAttributes = hit_object_attributes;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordMissMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordMissMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 7;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> sbtIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> currentTime;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(sbtIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(currentTime);
  }
  NodeOpHitObjectRecordMissMotionNV() = default;
  ~NodeOpHitObjectRecordMissMotionNV() = default;
  NodeOpHitObjectRecordMissMotionNV(const NodeOpHitObjectRecordMissMotionNV &) = delete;
  NodeOpHitObjectRecordMissMotionNV &operator=(const NodeOpHitObjectRecordMissMotionNV &) = delete;
  NodeOpHitObjectRecordMissMotionNV(NodeOpHitObjectRecordMissMotionNV &&) = delete;
  NodeOpHitObjectRecordMissMotionNV &operator=(NodeOpHitObjectRecordMissMotionNV &&) = delete;
  NodeOpHitObjectRecordMissMotionNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> s_b_t_index, NodePointer<NodeId> origin,
    NodePointer<NodeId> t_min, NodePointer<NodeId> direction, NodePointer<NodeId> t_max, NodePointer<NodeId> current_time)
  {
    this->hitObject = hit_object;
    this->sbtIndex = s_b_t_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->currentTime = current_time;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordMissNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectRecordMissNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 6;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> sbtIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(sbtIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
  }
  NodeOpHitObjectRecordMissNV() = default;
  ~NodeOpHitObjectRecordMissNV() = default;
  NodeOpHitObjectRecordMissNV(const NodeOpHitObjectRecordMissNV &) = delete;
  NodeOpHitObjectRecordMissNV &operator=(const NodeOpHitObjectRecordMissNV &) = delete;
  NodeOpHitObjectRecordMissNV(NodeOpHitObjectRecordMissNV &&) = delete;
  NodeOpHitObjectRecordMissNV &operator=(NodeOpHitObjectRecordMissNV &&) = delete;
  NodeOpHitObjectRecordMissNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> s_b_t_index, NodePointer<NodeId> origin,
    NodePointer<NodeId> t_min, NodePointer<NodeId> direction, NodePointer<NodeId> t_max)
  {
    this->hitObject = hit_object;
    this->sbtIndex = s_b_t_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectTraceRayMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectTraceRayMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 13;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullmask;
  NodePointer<NodeId> sbtRecordOffset;
  NodePointer<NodeId> sbtRecordStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> time;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(rayFlags);
    visitor(cullmask);
    visitor(sbtRecordOffset);
    visitor(sbtRecordStride);
    visitor(missIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(time);
    visitor(payload);
  }
  NodeOpHitObjectTraceRayMotionNV() = default;
  ~NodeOpHitObjectTraceRayMotionNV() = default;
  NodeOpHitObjectTraceRayMotionNV(const NodeOpHitObjectTraceRayMotionNV &) = delete;
  NodeOpHitObjectTraceRayMotionNV &operator=(const NodeOpHitObjectTraceRayMotionNV &) = delete;
  NodeOpHitObjectTraceRayMotionNV(NodeOpHitObjectTraceRayMotionNV &&) = delete;
  NodeOpHitObjectTraceRayMotionNV &operator=(NodeOpHitObjectTraceRayMotionNV &&) = delete;
  NodeOpHitObjectTraceRayMotionNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure,
    NodePointer<NodeId> ray_flags, NodePointer<NodeId> cullmask, NodePointer<NodeId> s_b_t_record_offset,
    NodePointer<NodeId> s_b_t_record_stride, NodePointer<NodeId> miss_index, NodePointer<NodeId> origin, NodePointer<NodeId> t_min,
    NodePointer<NodeId> direction, NodePointer<NodeId> t_max, NodePointer<NodeId> time, NodePointer<NodeId> payload)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->rayFlags = ray_flags;
    this->cullmask = cullmask;
    this->sbtRecordOffset = s_b_t_record_offset;
    this->sbtRecordStride = s_b_t_record_stride;
    this->missIndex = miss_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->time = time;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectTraceRayNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpHitObjectTraceRayNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 12;
  NodePointer<NodeId> hitObject;
  NodePointer<NodeId> accelerationStructure;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullmask;
  NodePointer<NodeId> sbtRecordOffset;
  NodePointer<NodeId> sbtRecordStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> origin;
  NodePointer<NodeId> tMin;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> tMax;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    visitor(accelerationStructure);
    visitor(rayFlags);
    visitor(cullmask);
    visitor(sbtRecordOffset);
    visitor(sbtRecordStride);
    visitor(missIndex);
    visitor(origin);
    visitor(tMin);
    visitor(direction);
    visitor(tMax);
    visitor(payload);
  }
  NodeOpHitObjectTraceRayNV() = default;
  ~NodeOpHitObjectTraceRayNV() = default;
  NodeOpHitObjectTraceRayNV(const NodeOpHitObjectTraceRayNV &) = delete;
  NodeOpHitObjectTraceRayNV &operator=(const NodeOpHitObjectTraceRayNV &) = delete;
  NodeOpHitObjectTraceRayNV(NodeOpHitObjectTraceRayNV &&) = delete;
  NodeOpHitObjectTraceRayNV &operator=(NodeOpHitObjectTraceRayNV &&) = delete;
  NodeOpHitObjectTraceRayNV(NodePointer<NodeId> hit_object, NodePointer<NodeId> acceleration_structure, NodePointer<NodeId> ray_flags,
    NodePointer<NodeId> cullmask, NodePointer<NodeId> s_b_t_record_offset, NodePointer<NodeId> s_b_t_record_stride,
    NodePointer<NodeId> miss_index, NodePointer<NodeId> origin, NodePointer<NodeId> t_min, NodePointer<NodeId> direction,
    NodePointer<NodeId> t_max, NodePointer<NodeId> payload)
  {
    this->hitObject = hit_object;
    this->accelerationStructure = acceleration_structure;
    this->rayFlags = ray_flags;
    this->cullmask = cullmask;
    this->sbtRecordOffset = s_b_t_record_offset;
    this->sbtRecordStride = s_b_t_record_stride;
    this->missIndex = miss_index;
    this->origin = origin;
    this->tMin = t_min;
    this->direction = direction;
    this->tMax = t_max;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryInitializeKHR
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpRayQueryInitializeKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 8;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullMask;
  NodePointer<NodeId> rayOrigin;
  NodePointer<NodeId> rayTMin;
  NodePointer<NodeId> rayDirection;
  NodePointer<NodeId> rayTMax;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(rayQuery);
    visitor(accel);
    visitor(rayFlags);
    visitor(cullMask);
    visitor(rayOrigin);
    visitor(rayTMin);
    visitor(rayDirection);
    visitor(rayTMax);
  }
  NodeOpRayQueryInitializeKHR() = default;
  ~NodeOpRayQueryInitializeKHR() = default;
  NodeOpRayQueryInitializeKHR(const NodeOpRayQueryInitializeKHR &) = delete;
  NodeOpRayQueryInitializeKHR &operator=(const NodeOpRayQueryInitializeKHR &) = delete;
  NodeOpRayQueryInitializeKHR(NodeOpRayQueryInitializeKHR &&) = delete;
  NodeOpRayQueryInitializeKHR &operator=(NodeOpRayQueryInitializeKHR &&) = delete;
  NodeOpRayQueryInitializeKHR(NodePointer<NodeId> ray_query, NodePointer<NodeId> accel, NodePointer<NodeId> ray_flags,
    NodePointer<NodeId> cull_mask, NodePointer<NodeId> ray_origin, NodePointer<NodeId> ray_t_min, NodePointer<NodeId> ray_direction,
    NodePointer<NodeId> ray_t_max)
  {
    this->rayQuery = ray_query;
    this->accel = accel;
    this->rayFlags = ray_flags;
    this->cullMask = cull_mask;
    this->rayOrigin = ray_origin;
    this->rayTMin = ray_t_min;
    this->rayDirection = ray_direction;
    this->rayTMax = ray_t_max;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTraceMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpTraceMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 12;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullMask;
  NodePointer<NodeId> sbtOffset;
  NodePointer<NodeId> sbtStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> rayOrigin;
  NodePointer<NodeId> rayTmin;
  NodePointer<NodeId> rayDirection;
  NodePointer<NodeId> rayTmax;
  NodePointer<NodeId> time;
  NodePointer<NodeId> payloadId;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(accel);
    visitor(rayFlags);
    visitor(cullMask);
    visitor(sbtOffset);
    visitor(sbtStride);
    visitor(missIndex);
    visitor(rayOrigin);
    visitor(rayTmin);
    visitor(rayDirection);
    visitor(rayTmax);
    visitor(time);
    visitor(payloadId);
  }
  NodeOpTraceMotionNV() = default;
  ~NodeOpTraceMotionNV() = default;
  NodeOpTraceMotionNV(const NodeOpTraceMotionNV &) = delete;
  NodeOpTraceMotionNV &operator=(const NodeOpTraceMotionNV &) = delete;
  NodeOpTraceMotionNV(NodeOpTraceMotionNV &&) = delete;
  NodeOpTraceMotionNV &operator=(NodeOpTraceMotionNV &&) = delete;
  NodeOpTraceMotionNV(NodePointer<NodeId> accel, NodePointer<NodeId> ray_flags, NodePointer<NodeId> cull_mask,
    NodePointer<NodeId> s_b_t_offset, NodePointer<NodeId> s_b_t_stride, NodePointer<NodeId> miss_index, NodePointer<NodeId> ray_origin,
    NodePointer<NodeId> ray_tmin, NodePointer<NodeId> ray_direction, NodePointer<NodeId> ray_tmax, NodePointer<NodeId> time,
    NodePointer<NodeId> payload_id)
  {
    this->accel = accel;
    this->rayFlags = ray_flags;
    this->cullMask = cull_mask;
    this->sbtOffset = s_b_t_offset;
    this->sbtStride = s_b_t_stride;
    this->missIndex = miss_index;
    this->rayOrigin = ray_origin;
    this->rayTmin = ray_tmin;
    this->rayDirection = ray_direction;
    this->rayTmax = ray_tmax;
    this->time = time;
    this->payloadId = payload_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTraceNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpTraceNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 11;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullMask;
  NodePointer<NodeId> sbtOffset;
  NodePointer<NodeId> sbtStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> rayOrigin;
  NodePointer<NodeId> rayTmin;
  NodePointer<NodeId> rayDirection;
  NodePointer<NodeId> rayTmax;
  NodePointer<NodeId> payloadId;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(accel);
    visitor(rayFlags);
    visitor(cullMask);
    visitor(sbtOffset);
    visitor(sbtStride);
    visitor(missIndex);
    visitor(rayOrigin);
    visitor(rayTmin);
    visitor(rayDirection);
    visitor(rayTmax);
    visitor(payloadId);
  }
  NodeOpTraceNV() = default;
  ~NodeOpTraceNV() = default;
  NodeOpTraceNV(const NodeOpTraceNV &) = delete;
  NodeOpTraceNV &operator=(const NodeOpTraceNV &) = delete;
  NodeOpTraceNV(NodeOpTraceNV &&) = delete;
  NodeOpTraceNV &operator=(NodeOpTraceNV &&) = delete;
  NodeOpTraceNV(NodePointer<NodeId> accel, NodePointer<NodeId> ray_flags, NodePointer<NodeId> cull_mask,
    NodePointer<NodeId> s_b_t_offset, NodePointer<NodeId> s_b_t_stride, NodePointer<NodeId> miss_index, NodePointer<NodeId> ray_origin,
    NodePointer<NodeId> ray_tmin, NodePointer<NodeId> ray_direction, NodePointer<NodeId> ray_tmax, NodePointer<NodeId> payload_id)
  {
    this->accel = accel;
    this->rayFlags = ray_flags;
    this->cullMask = cull_mask;
    this->sbtOffset = s_b_t_offset;
    this->sbtStride = s_b_t_stride;
    this->missIndex = miss_index;
    this->rayOrigin = ray_origin;
    this->rayTmin = ray_tmin;
    this->rayDirection = ray_direction;
    this->rayTmax = ray_tmax;
    this->payloadId = payload_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTraceRayKHR
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpTraceRayKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 11;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullMask;
  NodePointer<NodeId> sbtOffset;
  NodePointer<NodeId> sbtStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> rayOrigin;
  NodePointer<NodeId> rayTmin;
  NodePointer<NodeId> rayDirection;
  NodePointer<NodeId> rayTmax;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(accel);
    visitor(rayFlags);
    visitor(cullMask);
    visitor(sbtOffset);
    visitor(sbtStride);
    visitor(missIndex);
    visitor(rayOrigin);
    visitor(rayTmin);
    visitor(rayDirection);
    visitor(rayTmax);
    visitor(payload);
  }
  NodeOpTraceRayKHR() = default;
  ~NodeOpTraceRayKHR() = default;
  NodeOpTraceRayKHR(const NodeOpTraceRayKHR &) = delete;
  NodeOpTraceRayKHR &operator=(const NodeOpTraceRayKHR &) = delete;
  NodeOpTraceRayKHR(NodeOpTraceRayKHR &&) = delete;
  NodeOpTraceRayKHR &operator=(NodeOpTraceRayKHR &&) = delete;
  NodeOpTraceRayKHR(NodePointer<NodeId> accel, NodePointer<NodeId> ray_flags, NodePointer<NodeId> cull_mask,
    NodePointer<NodeId> s_b_t_offset, NodePointer<NodeId> s_b_t_stride, NodePointer<NodeId> miss_index, NodePointer<NodeId> ray_origin,
    NodePointer<NodeId> ray_tmin, NodePointer<NodeId> ray_direction, NodePointer<NodeId> ray_tmax, NodePointer<NodeId> payload)
  {
    this->accel = accel;
    this->rayFlags = ray_flags;
    this->cullMask = cull_mask;
    this->sbtOffset = s_b_t_offset;
    this->sbtStride = s_b_t_stride;
    this->missIndex = miss_index;
    this->rayOrigin = ray_origin;
    this->rayTmin = ray_tmin;
    this->rayDirection = ray_direction;
    this->rayTmax = ray_tmax;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTraceRayMotionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryAction;
  const Op opCode = Op::OpTraceRayMotionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  const Id pCount = 12;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> rayFlags;
  NodePointer<NodeId> cullMask;
  NodePointer<NodeId> sbtOffset;
  NodePointer<NodeId> sbtStride;
  NodePointer<NodeId> missIndex;
  NodePointer<NodeId> rayOrigin;
  NodePointer<NodeId> rayTmin;
  NodePointer<NodeId> rayDirection;
  NodePointer<NodeId> rayTmax;
  NodePointer<NodeId> time;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(accel);
    visitor(rayFlags);
    visitor(cullMask);
    visitor(sbtOffset);
    visitor(sbtStride);
    visitor(missIndex);
    visitor(rayOrigin);
    visitor(rayTmin);
    visitor(rayDirection);
    visitor(rayTmax);
    visitor(time);
    visitor(payload);
  }
  NodeOpTraceRayMotionNV() = default;
  ~NodeOpTraceRayMotionNV() = default;
  NodeOpTraceRayMotionNV(const NodeOpTraceRayMotionNV &) = delete;
  NodeOpTraceRayMotionNV &operator=(const NodeOpTraceRayMotionNV &) = delete;
  NodeOpTraceRayMotionNV(NodeOpTraceRayMotionNV &&) = delete;
  NodeOpTraceRayMotionNV &operator=(NodeOpTraceRayMotionNV &&) = delete;
  NodeOpTraceRayMotionNV(NodePointer<NodeId> accel, NodePointer<NodeId> ray_flags, NodePointer<NodeId> cull_mask,
    NodePointer<NodeId> s_b_t_offset, NodePointer<NodeId> s_b_t_stride, NodePointer<NodeId> miss_index, NodePointer<NodeId> ray_origin,
    NodePointer<NodeId> ray_tmin, NodePointer<NodeId> ray_direction, NodePointer<NodeId> ray_tmax, NodePointer<NodeId> time,
    NodePointer<NodeId> payload)
  {
    this->accel = accel;
    this->rayFlags = ray_flags;
    this->cullMask = cull_mask;
    this->sbtOffset = s_b_t_offset;
    this->sbtStride = s_b_t_stride;
    this->missIndex = miss_index;
    this->rayOrigin = ray_origin;
    this->rayTmin = ray_tmin;
    this->rayDirection = ray_direction;
    this->rayTmax = ray_tmax;
    this->time = time;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeMultinaryAction::visit(NodeMultinaryAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::MultinaryAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpCommitReadPipe:
        if (visitor(reinterpret_cast<NodeOpCommitReadPipe *>(node)))
          return true;
        break;
      case Op::OpCommitWritePipe:
        if (visitor(reinterpret_cast<NodeOpCommitWritePipe *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixStoreNV:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixStoreNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordHitMotionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordHitMotionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordHitNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordHitNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordHitWithIndexMotionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordHitWithIndexMotionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordHitWithIndexNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordHitWithIndexNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordMissMotionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordMissMotionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordMissNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordMissNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectTraceRayMotionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectTraceRayMotionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectTraceRayNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectTraceRayNV *>(node)))
          return true;
        break;
      case Op::OpRayQueryInitializeKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryInitializeKHR *>(node)))
          return true;
        break;
      case Op::OpTraceMotionNV:
        if (visitor(reinterpret_cast<NodeOpTraceMotionNV *>(node)))
          return true;
        break;
      case Op::OpTraceNV:
        if (visitor(reinterpret_cast<NodeOpTraceNV *>(node)))
          return true;
        break;
      case Op::OpTraceRayKHR:
        if (visitor(reinterpret_cast<NodeOpTraceRayKHR *>(node)))
          return true;
        break;
      case Op::OpTraceRayMotionNV:
        if (visitor(reinterpret_cast<NodeOpTraceRayMotionNV *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeScopedAction : NodeAction
{
  NodePointer<NodeOperation> scope;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeScopedAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpControlBarrier
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpControlBarrier;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpControlBarrier() = default;
  ~NodeOpControlBarrier() = default;
  NodeOpControlBarrier(const NodeOpControlBarrier &) = delete;
  NodeOpControlBarrier &operator=(const NodeOpControlBarrier &) = delete;
  NodeOpControlBarrier(NodeOpControlBarrier &&) = delete;
  NodeOpControlBarrier &operator=(NodeOpControlBarrier &&) = delete;
  NodeOpControlBarrier(NodePointer<NodeOperation> execution, NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->execution = execution;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpControlBarrierArriveINTEL
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpControlBarrierArriveINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpControlBarrierArriveINTEL() = default;
  ~NodeOpControlBarrierArriveINTEL() = default;
  NodeOpControlBarrierArriveINTEL(const NodeOpControlBarrierArriveINTEL &) = delete;
  NodeOpControlBarrierArriveINTEL &operator=(const NodeOpControlBarrierArriveINTEL &) = delete;
  NodeOpControlBarrierArriveINTEL(NodeOpControlBarrierArriveINTEL &&) = delete;
  NodeOpControlBarrierArriveINTEL &operator=(NodeOpControlBarrierArriveINTEL &&) = delete;
  NodeOpControlBarrierArriveINTEL(NodePointer<NodeOperation> execution, NodePointer<NodeOperation> memory,
    NodePointer<NodeOperation> semantics)
  {
    this->execution = execution;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpControlBarrierWaitINTEL
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpControlBarrierWaitINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpControlBarrierWaitINTEL() = default;
  ~NodeOpControlBarrierWaitINTEL() = default;
  NodeOpControlBarrierWaitINTEL(const NodeOpControlBarrierWaitINTEL &) = delete;
  NodeOpControlBarrierWaitINTEL &operator=(const NodeOpControlBarrierWaitINTEL &) = delete;
  NodeOpControlBarrierWaitINTEL(NodeOpControlBarrierWaitINTEL &&) = delete;
  NodeOpControlBarrierWaitINTEL &operator=(NodeOpControlBarrierWaitINTEL &&) = delete;
  NodeOpControlBarrierWaitINTEL(NodePointer<NodeOperation> execution, NodePointer<NodeOperation> memory,
    NodePointer<NodeOperation> semantics)
  {
    this->execution = execution;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupCommitReadPipe
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpGroupCommitReadPipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(pipe);
    visitor(reserveId);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGroupCommitReadPipe() = default;
  ~NodeOpGroupCommitReadPipe() = default;
  NodeOpGroupCommitReadPipe(const NodeOpGroupCommitReadPipe &) = delete;
  NodeOpGroupCommitReadPipe &operator=(const NodeOpGroupCommitReadPipe &) = delete;
  NodeOpGroupCommitReadPipe(NodeOpGroupCommitReadPipe &&) = delete;
  NodeOpGroupCommitReadPipe &operator=(NodeOpGroupCommitReadPipe &&) = delete;
  NodeOpGroupCommitReadPipe(NodePointer<NodeOperation> execution, NodePointer<NodeId> pipe, NodePointer<NodeId> reserve_id,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->execution = execution;
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupCommitWritePipe
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpGroupCommitWritePipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(pipe);
    visitor(reserveId);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGroupCommitWritePipe() = default;
  ~NodeOpGroupCommitWritePipe() = default;
  NodeOpGroupCommitWritePipe(const NodeOpGroupCommitWritePipe &) = delete;
  NodeOpGroupCommitWritePipe &operator=(const NodeOpGroupCommitWritePipe &) = delete;
  NodeOpGroupCommitWritePipe(NodeOpGroupCommitWritePipe &&) = delete;
  NodeOpGroupCommitWritePipe &operator=(NodeOpGroupCommitWritePipe &&) = delete;
  NodeOpGroupCommitWritePipe(NodePointer<NodeOperation> execution, NodePointer<NodeId> pipe, NodePointer<NodeId> reserve_id,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->execution = execution;
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupWaitEvents
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpGroupWaitEvents;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> numEvents;
  NodePointer<NodeId> eventsList;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(execution);
    visitor(numEvents);
    visitor(eventsList);
  }
  NodeOpGroupWaitEvents() = default;
  ~NodeOpGroupWaitEvents() = default;
  NodeOpGroupWaitEvents(const NodeOpGroupWaitEvents &) = delete;
  NodeOpGroupWaitEvents &operator=(const NodeOpGroupWaitEvents &) = delete;
  NodeOpGroupWaitEvents(NodeOpGroupWaitEvents &&) = delete;
  NodeOpGroupWaitEvents &operator=(NodeOpGroupWaitEvents &&) = delete;
  NodeOpGroupWaitEvents(NodePointer<NodeOperation> execution, NodePointer<NodeId> num_events, NodePointer<NodeId> events_list)
  {
    this->execution = execution;
    this->numEvents = num_events;
    this->eventsList = events_list;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMemoryBarrier
{
  const NodeKind nodeKind = NodeKind::ScopedAction;
  const Op opCode = Op::OpMemoryBarrier;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(memory);
    visitor(semantics);
  }
  NodeOpMemoryBarrier() = default;
  ~NodeOpMemoryBarrier() = default;
  NodeOpMemoryBarrier(const NodeOpMemoryBarrier &) = delete;
  NodeOpMemoryBarrier &operator=(const NodeOpMemoryBarrier &) = delete;
  NodeOpMemoryBarrier(NodeOpMemoryBarrier &&) = delete;
  NodeOpMemoryBarrier &operator=(NodeOpMemoryBarrier &&) = delete;
  NodeOpMemoryBarrier(NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeGroupedAction : NodeScopedAction
{
  GroupOperation groupOperation;
  NodePointer<NodeOperation> value;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeGroupedAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
template <typename T>
inline bool NodeGroupedAction::visit(NodeGroupedAction *node, T visitor)
{
  return visitor(node);
}
template <typename T>
inline bool NodeScopedAction::visit(NodeScopedAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::ScopedAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpControlBarrier:
        if (visitor(reinterpret_cast<NodeOpControlBarrier *>(node)))
          return true;
        break;
      case Op::OpControlBarrierArriveINTEL:
        if (visitor(reinterpret_cast<NodeOpControlBarrierArriveINTEL *>(node)))
          return true;
        break;
      case Op::OpControlBarrierWaitINTEL:
        if (visitor(reinterpret_cast<NodeOpControlBarrierWaitINTEL *>(node)))
          return true;
        break;
      case Op::OpGroupCommitReadPipe:
        if (visitor(reinterpret_cast<NodeOpGroupCommitReadPipe *>(node)))
          return true;
        break;
      case Op::OpGroupCommitWritePipe:
        if (visitor(reinterpret_cast<NodeOpGroupCommitWritePipe *>(node)))
          return true;
        break;
      case Op::OpGroupWaitEvents:
        if (visitor(reinterpret_cast<NodeOpGroupWaitEvents *>(node)))
          return true;
        break;
      case Op::OpMemoryBarrier:
        if (visitor(reinterpret_cast<NodeOpMemoryBarrier *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeGroupedAction::is(node))
    {
      if (NodeGroupedAction::visit(reinterpret_cast<NodeGroupedAction *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeTrinaryAction : NodeAction
{
  NodePointer<NodeId> first;
  NodePointer<NodeId> second;
  NodePointer<NodeId> third;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeTrinaryAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpCaptureEventProfilingInfo
{
  const NodeKind nodeKind = NodeKind::TrinaryAction;
  const Op opCode = Op::OpCaptureEventProfilingInfo;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> event;
  NodePointer<NodeId> profilingInfo;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(event);
    visitor(profilingInfo);
    visitor(value);
  }
  NodeOpCaptureEventProfilingInfo() = default;
  ~NodeOpCaptureEventProfilingInfo() = default;
  NodeOpCaptureEventProfilingInfo(const NodeOpCaptureEventProfilingInfo &) = delete;
  NodeOpCaptureEventProfilingInfo &operator=(const NodeOpCaptureEventProfilingInfo &) = delete;
  NodeOpCaptureEventProfilingInfo(NodeOpCaptureEventProfilingInfo &&) = delete;
  NodeOpCaptureEventProfilingInfo &operator=(NodeOpCaptureEventProfilingInfo &&) = delete;
  NodeOpCaptureEventProfilingInfo(NodePointer<NodeId> event, NodePointer<NodeId> profiling_info, NodePointer<NodeId> value)
  {
    this->event = event;
    this->profilingInfo = profiling_info;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixStoreKHR
{
  const NodeKind nodeKind = NodeKind::TrinaryAction;
  const Op opCode = Op::OpCooperativeMatrixStoreKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> object;
  NodePointer<NodeId> memoryLayout;
  eastl::optional<NodePointer<NodeId>> stride;
  eastl::optional<MemoryAccessMask> memoryOperand;
  // extra values for memoryOperand
  LiteralInteger memoryOperandAligned;
  NodePointer<NodeOperation> memoryOperandMakePointerAvailable;
  NodePointer<NodeOperation> memoryOperandMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryOperandMakePointerVisible;
  NodePointer<NodeOperation> memoryOperandMakePointerVisibleKHR;
  NodePointer<NodeId> memoryOperandAliasScopeINTELMask;
  NodePointer<NodeId> memoryOperandNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
    visitor(object);
    visitor(memoryLayout);
    if (stride)
      visitor(*stride);
    if (memoryOperandMakePointerAvailable)
      visitor(memoryOperandMakePointerAvailable);
    if (memoryOperandMakePointerAvailableKHR)
      visitor(memoryOperandMakePointerAvailableKHR);
    if (memoryOperandMakePointerVisible)
      visitor(memoryOperandMakePointerVisible);
    if (memoryOperandMakePointerVisibleKHR)
      visitor(memoryOperandMakePointerVisibleKHR);
    if (memoryOperandAliasScopeINTELMask)
      visitor(memoryOperandAliasScopeINTELMask);
    if (memoryOperandNoAliasINTELMask)
      visitor(memoryOperandNoAliasINTELMask);
  }
  NodeOpCooperativeMatrixStoreKHR() = default;
  ~NodeOpCooperativeMatrixStoreKHR() = default;
  NodeOpCooperativeMatrixStoreKHR(const NodeOpCooperativeMatrixStoreKHR &) = delete;
  NodeOpCooperativeMatrixStoreKHR &operator=(const NodeOpCooperativeMatrixStoreKHR &) = delete;
  NodeOpCooperativeMatrixStoreKHR(NodeOpCooperativeMatrixStoreKHR &&) = delete;
  NodeOpCooperativeMatrixStoreKHR &operator=(NodeOpCooperativeMatrixStoreKHR &&) = delete;
  NodeOpCooperativeMatrixStoreKHR(NodePointer<NodeId> pointer, NodePointer<NodeId> object, NodePointer<NodeId> memory_layout,
    eastl::optional<NodePointer<NodeId>> stride = {}, eastl::optional<MemoryAccessMask> memory_operand = {},
    eastl::optional<LiteralInteger> memory_operand_aligned = {}, NodePointer<NodeOperation> memory_operand_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_operand_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_operand_makePointerVisible = {},
    NodePointer<NodeOperation> memory_operand_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_operand_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_operand_noAliasINTELMask = {})
  {
    this->pointer = pointer;
    this->object = object;
    this->memoryLayout = memory_layout;
    this->stride = stride;
    this->memoryOperand = memory_operand;
    if (memory_operand_aligned)
      this->memoryOperandAligned = *memory_operand_aligned;
    this->memoryOperandMakePointerAvailable = memory_operand_makePointerAvailable;
    this->memoryOperandMakePointerAvailableKHR = memory_operand_makePointerAvailableKHR;
    this->memoryOperandMakePointerVisible = memory_operand_makePointerVisible;
    this->memoryOperandMakePointerVisibleKHR = memory_operand_makePointerVisibleKHR;
    this->memoryOperandAliasScopeINTELMask = memory_operand_aliasScopeINTELMask;
    this->memoryOperandNoAliasINTELMask = memory_operand_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCopyMemorySized
{
  const NodeKind nodeKind = NodeKind::TrinaryAction;
  const Op opCode = Op::OpCopyMemorySized;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> target;
  NodePointer<NodeId> source;
  NodePointer<NodeId> size;
  eastl::optional<MemoryAccessMask> memoryAccess0;
  // extra values for memoryAccess0
  LiteralInteger memoryAccess0Aligned;
  NodePointer<NodeOperation> memoryAccess0MakePointerAvailable;
  NodePointer<NodeOperation> memoryAccess0MakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccess0MakePointerVisible;
  NodePointer<NodeOperation> memoryAccess0MakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccess0AliasScopeINTELMask;
  NodePointer<NodeId> memoryAccess0NoAliasINTELMask;
  eastl::optional<MemoryAccessMask> memoryAccess1;
  // extra values for memoryAccess1
  LiteralInteger memoryAccess1Aligned;
  NodePointer<NodeOperation> memoryAccess1MakePointerAvailable;
  NodePointer<NodeOperation> memoryAccess1MakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccess1MakePointerVisible;
  NodePointer<NodeOperation> memoryAccess1MakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccess1AliasScopeINTELMask;
  NodePointer<NodeId> memoryAccess1NoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(target);
    visitor(source);
    visitor(size);
    if (memoryAccess0MakePointerAvailable)
      visitor(memoryAccess0MakePointerAvailable);
    if (memoryAccess0MakePointerAvailableKHR)
      visitor(memoryAccess0MakePointerAvailableKHR);
    if (memoryAccess0MakePointerVisible)
      visitor(memoryAccess0MakePointerVisible);
    if (memoryAccess0MakePointerVisibleKHR)
      visitor(memoryAccess0MakePointerVisibleKHR);
    if (memoryAccess0AliasScopeINTELMask)
      visitor(memoryAccess0AliasScopeINTELMask);
    if (memoryAccess0NoAliasINTELMask)
      visitor(memoryAccess0NoAliasINTELMask);
    if (memoryAccess1MakePointerAvailable)
      visitor(memoryAccess1MakePointerAvailable);
    if (memoryAccess1MakePointerAvailableKHR)
      visitor(memoryAccess1MakePointerAvailableKHR);
    if (memoryAccess1MakePointerVisible)
      visitor(memoryAccess1MakePointerVisible);
    if (memoryAccess1MakePointerVisibleKHR)
      visitor(memoryAccess1MakePointerVisibleKHR);
    if (memoryAccess1AliasScopeINTELMask)
      visitor(memoryAccess1AliasScopeINTELMask);
    if (memoryAccess1NoAliasINTELMask)
      visitor(memoryAccess1NoAliasINTELMask);
  }
  NodeOpCopyMemorySized() = default;
  ~NodeOpCopyMemorySized() = default;
  NodeOpCopyMemorySized(const NodeOpCopyMemorySized &) = delete;
  NodeOpCopyMemorySized &operator=(const NodeOpCopyMemorySized &) = delete;
  NodeOpCopyMemorySized(NodeOpCopyMemorySized &&) = delete;
  NodeOpCopyMemorySized &operator=(NodeOpCopyMemorySized &&) = delete;
  NodeOpCopyMemorySized(NodePointer<NodeId> target, NodePointer<NodeId> source, NodePointer<NodeId> size,
    eastl::optional<MemoryAccessMask> memory_access0, eastl::optional<LiteralInteger> memory_access0_aligned = {},
    NodePointer<NodeOperation> memory_access0_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access0_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access0_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access0_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access0_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access0_noAliasINTELMask = {}, eastl::optional<MemoryAccessMask> memory_access1 = {},
    eastl::optional<LiteralInteger> memory_access1_aligned = {}, NodePointer<NodeOperation> memory_access1_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access1_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access1_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access1_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access1_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access1_noAliasINTELMask = {})
  {
    this->target = target;
    this->source = source;
    this->size = size;
    this->memoryAccess0 = memory_access0;
    if (memory_access0_aligned)
      this->memoryAccess0Aligned = *memory_access0_aligned;
    this->memoryAccess0MakePointerAvailable = memory_access0_makePointerAvailable;
    this->memoryAccess0MakePointerAvailableKHR = memory_access0_makePointerAvailableKHR;
    this->memoryAccess0MakePointerVisible = memory_access0_makePointerVisible;
    this->memoryAccess0MakePointerVisibleKHR = memory_access0_makePointerVisibleKHR;
    this->memoryAccess0AliasScopeINTELMask = memory_access0_aliasScopeINTELMask;
    this->memoryAccess0NoAliasINTELMask = memory_access0_noAliasINTELMask;
    this->memoryAccess1 = memory_access1;
    if (memory_access1_aligned)
      this->memoryAccess1Aligned = *memory_access1_aligned;
    this->memoryAccess1MakePointerAvailable = memory_access1_makePointerAvailable;
    this->memoryAccess1MakePointerAvailableKHR = memory_access1_makePointerAvailableKHR;
    this->memoryAccess1MakePointerVisible = memory_access1_makePointerVisible;
    this->memoryAccess1MakePointerVisibleKHR = memory_access1_makePointerVisibleKHR;
    this->memoryAccess1AliasScopeINTELMask = memory_access1_aliasScopeINTELMask;
    this->memoryAccess1NoAliasINTELMask = memory_access1_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEmitMeshTasksEXT
{
  const NodeKind nodeKind = NodeKind::TrinaryAction;
  const Op opCode = Op::OpEmitMeshTasksEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> groupCountX;
  NodePointer<NodeId> groupCountY;
  NodePointer<NodeId> groupCountZ;
  eastl::optional<NodePointer<NodeId>> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(groupCountX);
    visitor(groupCountY);
    visitor(groupCountZ);
    if (payload)
      visitor(*payload);
  }
  NodeOpEmitMeshTasksEXT() = default;
  ~NodeOpEmitMeshTasksEXT() = default;
  NodeOpEmitMeshTasksEXT(const NodeOpEmitMeshTasksEXT &) = delete;
  NodeOpEmitMeshTasksEXT &operator=(const NodeOpEmitMeshTasksEXT &) = delete;
  NodeOpEmitMeshTasksEXT(NodeOpEmitMeshTasksEXT &&) = delete;
  NodeOpEmitMeshTasksEXT &operator=(NodeOpEmitMeshTasksEXT &&) = delete;
  NodeOpEmitMeshTasksEXT(NodePointer<NodeId> group_count_x, NodePointer<NodeId> group_count_y, NodePointer<NodeId> group_count_z,
    eastl::optional<NodePointer<NodeId>> payload = {})
  {
    this->groupCountX = group_count_x;
    this->groupCountY = group_count_y;
    this->groupCountZ = group_count_z;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeTrinaryAction::visit(NodeTrinaryAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::TrinaryAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpCaptureEventProfilingInfo:
        if (visitor(reinterpret_cast<NodeOpCaptureEventProfilingInfo *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixStoreKHR:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixStoreKHR *>(node)))
          return true;
        break;
      case Op::OpCopyMemorySized:
        if (visitor(reinterpret_cast<NodeOpCopyMemorySized *>(node)))
          return true;
        break;
      case Op::OpEmitMeshTasksEXT:
        if (visitor(reinterpret_cast<NodeOpEmitMeshTasksEXT *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeUnaryAction : NodeAction
{
  NodePointer<NodeId> first;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeUnaryAction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpAssumeTrueKHR
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpAssumeTrueKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> condition;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(condition);
  }
  NodeOpAssumeTrueKHR() = default;
  ~NodeOpAssumeTrueKHR() = default;
  NodeOpAssumeTrueKHR(const NodeOpAssumeTrueKHR &) = delete;
  NodeOpAssumeTrueKHR &operator=(const NodeOpAssumeTrueKHR &) = delete;
  NodeOpAssumeTrueKHR(NodeOpAssumeTrueKHR &&) = delete;
  NodeOpAssumeTrueKHR &operator=(NodeOpAssumeTrueKHR &&) = delete;
  NodeOpAssumeTrueKHR(NodePointer<NodeId> condition) { this->condition = condition; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicFlagClear
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpAtomicFlagClear;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpAtomicFlagClear() = default;
  ~NodeOpAtomicFlagClear() = default;
  NodeOpAtomicFlagClear(const NodeOpAtomicFlagClear &) = delete;
  NodeOpAtomicFlagClear &operator=(const NodeOpAtomicFlagClear &) = delete;
  NodeOpAtomicFlagClear(NodeOpAtomicFlagClear &&) = delete;
  NodeOpAtomicFlagClear &operator=(NodeOpAtomicFlagClear &&) = delete;
  NodeOpAtomicFlagClear(NodePointer<NodeId> pointer, NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicStore
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpAtomicStore;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicStore() = default;
  ~NodeOpAtomicStore() = default;
  NodeOpAtomicStore(const NodeOpAtomicStore &) = delete;
  NodeOpAtomicStore &operator=(const NodeOpAtomicStore &) = delete;
  NodeOpAtomicStore(NodeOpAtomicStore &&) = delete;
  NodeOpAtomicStore &operator=(NodeOpAtomicStore &&) = delete;
  NodeOpAtomicStore(NodePointer<NodeId> pointer, NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics,
    NodePointer<NodeId> value)
  {
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEmitStreamVertex
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpEmitStreamVertex;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> stream;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(stream);
  }
  NodeOpEmitStreamVertex() = default;
  ~NodeOpEmitStreamVertex() = default;
  NodeOpEmitStreamVertex(const NodeOpEmitStreamVertex &) = delete;
  NodeOpEmitStreamVertex &operator=(const NodeOpEmitStreamVertex &) = delete;
  NodeOpEmitStreamVertex(NodeOpEmitStreamVertex &&) = delete;
  NodeOpEmitStreamVertex &operator=(NodeOpEmitStreamVertex &&) = delete;
  NodeOpEmitStreamVertex(NodePointer<NodeId> stream) { this->stream = stream; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEndStreamPrimitive
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpEndStreamPrimitive;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> stream;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(stream);
  }
  NodeOpEndStreamPrimitive() = default;
  ~NodeOpEndStreamPrimitive() = default;
  NodeOpEndStreamPrimitive(const NodeOpEndStreamPrimitive &) = delete;
  NodeOpEndStreamPrimitive &operator=(const NodeOpEndStreamPrimitive &) = delete;
  NodeOpEndStreamPrimitive(NodeOpEndStreamPrimitive &&) = delete;
  NodeOpEndStreamPrimitive &operator=(NodeOpEndStreamPrimitive &&) = delete;
  NodeOpEndStreamPrimitive(NodePointer<NodeId> stream) { this->stream = stream; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFinalizeNodePayloadsAMDX
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpFinalizeNodePayloadsAMDX;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> payloadArray;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(payloadArray);
  }
  NodeOpFinalizeNodePayloadsAMDX() = default;
  ~NodeOpFinalizeNodePayloadsAMDX() = default;
  NodeOpFinalizeNodePayloadsAMDX(const NodeOpFinalizeNodePayloadsAMDX &) = delete;
  NodeOpFinalizeNodePayloadsAMDX &operator=(const NodeOpFinalizeNodePayloadsAMDX &) = delete;
  NodeOpFinalizeNodePayloadsAMDX(NodeOpFinalizeNodePayloadsAMDX &&) = delete;
  NodeOpFinalizeNodePayloadsAMDX &operator=(NodeOpFinalizeNodePayloadsAMDX &&) = delete;
  NodeOpFinalizeNodePayloadsAMDX(NodePointer<NodeId> payload_array) { this->payloadArray = payload_array; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectRecordEmptyNV
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpHitObjectRecordEmptyNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
  }
  NodeOpHitObjectRecordEmptyNV() = default;
  ~NodeOpHitObjectRecordEmptyNV() = default;
  NodeOpHitObjectRecordEmptyNV(const NodeOpHitObjectRecordEmptyNV &) = delete;
  NodeOpHitObjectRecordEmptyNV &operator=(const NodeOpHitObjectRecordEmptyNV &) = delete;
  NodeOpHitObjectRecordEmptyNV(NodeOpHitObjectRecordEmptyNV &&) = delete;
  NodeOpHitObjectRecordEmptyNV &operator=(NodeOpHitObjectRecordEmptyNV &&) = delete;
  NodeOpHitObjectRecordEmptyNV(NodePointer<NodeId> hit_object) { this->hitObject = hit_object; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpInitializeNodePayloadsAMDX
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpInitializeNodePayloadsAMDX;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> payloadArray;
  NodePointer<NodeOperation> visibility;
  NodePointer<NodeId> payloadCount;
  NodePointer<NodeId> nodeIndex;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(payloadArray);
    visitor(visibility);
    visitor(payloadCount);
    visitor(nodeIndex);
  }
  NodeOpInitializeNodePayloadsAMDX() = default;
  ~NodeOpInitializeNodePayloadsAMDX() = default;
  NodeOpInitializeNodePayloadsAMDX(const NodeOpInitializeNodePayloadsAMDX &) = delete;
  NodeOpInitializeNodePayloadsAMDX &operator=(const NodeOpInitializeNodePayloadsAMDX &) = delete;
  NodeOpInitializeNodePayloadsAMDX(NodeOpInitializeNodePayloadsAMDX &&) = delete;
  NodeOpInitializeNodePayloadsAMDX &operator=(NodeOpInitializeNodePayloadsAMDX &&) = delete;
  NodeOpInitializeNodePayloadsAMDX(NodePointer<NodeId> payload_array, NodePointer<NodeOperation> visibility,
    NodePointer<NodeId> payload_count, NodePointer<NodeId> node_index)
  {
    this->payloadArray = payload_array;
    this->visibility = visibility;
    this->payloadCount = payload_count;
    this->nodeIndex = node_index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLifetimeStart
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpLifetimeStart;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  LiteralInteger size;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
  }
  NodeOpLifetimeStart() = default;
  ~NodeOpLifetimeStart() = default;
  NodeOpLifetimeStart(const NodeOpLifetimeStart &) = delete;
  NodeOpLifetimeStart &operator=(const NodeOpLifetimeStart &) = delete;
  NodeOpLifetimeStart(NodeOpLifetimeStart &&) = delete;
  NodeOpLifetimeStart &operator=(NodeOpLifetimeStart &&) = delete;
  NodeOpLifetimeStart(NodePointer<NodeId> pointer, LiteralInteger size)
  {
    this->pointer = pointer;
    this->size = size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLifetimeStop
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpLifetimeStop;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> pointer;
  LiteralInteger size;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(pointer);
  }
  NodeOpLifetimeStop() = default;
  ~NodeOpLifetimeStop() = default;
  NodeOpLifetimeStop(const NodeOpLifetimeStop &) = delete;
  NodeOpLifetimeStop &operator=(const NodeOpLifetimeStop &) = delete;
  NodeOpLifetimeStop(NodeOpLifetimeStop &&) = delete;
  NodeOpLifetimeStop &operator=(NodeOpLifetimeStop &&) = delete;
  NodeOpLifetimeStop(NodePointer<NodeId> pointer, LiteralInteger size)
  {
    this->pointer = pointer;
    this->size = size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMemoryNamedBarrier
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpMemoryNamedBarrier;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> namedBarrier;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(namedBarrier);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpMemoryNamedBarrier() = default;
  ~NodeOpMemoryNamedBarrier() = default;
  NodeOpMemoryNamedBarrier(const NodeOpMemoryNamedBarrier &) = delete;
  NodeOpMemoryNamedBarrier &operator=(const NodeOpMemoryNamedBarrier &) = delete;
  NodeOpMemoryNamedBarrier(NodeOpMemoryNamedBarrier &&) = delete;
  NodeOpMemoryNamedBarrier &operator=(NodeOpMemoryNamedBarrier &&) = delete;
  NodeOpMemoryNamedBarrier(NodePointer<NodeId> named_barrier, NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->namedBarrier = named_barrier;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryConfirmIntersectionKHR
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpRayQueryConfirmIntersectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(rayQuery);
  }
  NodeOpRayQueryConfirmIntersectionKHR() = default;
  ~NodeOpRayQueryConfirmIntersectionKHR() = default;
  NodeOpRayQueryConfirmIntersectionKHR(const NodeOpRayQueryConfirmIntersectionKHR &) = delete;
  NodeOpRayQueryConfirmIntersectionKHR &operator=(const NodeOpRayQueryConfirmIntersectionKHR &) = delete;
  NodeOpRayQueryConfirmIntersectionKHR(NodeOpRayQueryConfirmIntersectionKHR &&) = delete;
  NodeOpRayQueryConfirmIntersectionKHR &operator=(NodeOpRayQueryConfirmIntersectionKHR &&) = delete;
  NodeOpRayQueryConfirmIntersectionKHR(NodePointer<NodeId> ray_query) { this->rayQuery = ray_query; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryTerminateKHR
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpRayQueryTerminateKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(rayQuery);
  }
  NodeOpRayQueryTerminateKHR() = default;
  ~NodeOpRayQueryTerminateKHR() = default;
  NodeOpRayQueryTerminateKHR(const NodeOpRayQueryTerminateKHR &) = delete;
  NodeOpRayQueryTerminateKHR &operator=(const NodeOpRayQueryTerminateKHR &) = delete;
  NodeOpRayQueryTerminateKHR(NodeOpRayQueryTerminateKHR &&) = delete;
  NodeOpRayQueryTerminateKHR &operator=(NodeOpRayQueryTerminateKHR &&) = delete;
  NodeOpRayQueryTerminateKHR(NodePointer<NodeId> ray_query) { this->rayQuery = ray_query; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReleaseEvent
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpReleaseEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> event;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(event);
  }
  NodeOpReleaseEvent() = default;
  ~NodeOpReleaseEvent() = default;
  NodeOpReleaseEvent(const NodeOpReleaseEvent &) = delete;
  NodeOpReleaseEvent &operator=(const NodeOpReleaseEvent &) = delete;
  NodeOpReleaseEvent(NodeOpReleaseEvent &&) = delete;
  NodeOpReleaseEvent &operator=(NodeOpReleaseEvent &&) = delete;
  NodeOpReleaseEvent(NodePointer<NodeId> event) { this->event = event; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReorderThreadWithHitObjectNV
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpReorderThreadWithHitObjectNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> hitObject;
  eastl::optional<NodePointer<NodeId>> hint;
  eastl::optional<NodePointer<NodeId>> bits;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(hitObject);
    if (hint)
      visitor(*hint);
    if (bits)
      visitor(*bits);
  }
  NodeOpReorderThreadWithHitObjectNV() = default;
  ~NodeOpReorderThreadWithHitObjectNV() = default;
  NodeOpReorderThreadWithHitObjectNV(const NodeOpReorderThreadWithHitObjectNV &) = delete;
  NodeOpReorderThreadWithHitObjectNV &operator=(const NodeOpReorderThreadWithHitObjectNV &) = delete;
  NodeOpReorderThreadWithHitObjectNV(NodeOpReorderThreadWithHitObjectNV &&) = delete;
  NodeOpReorderThreadWithHitObjectNV &operator=(NodeOpReorderThreadWithHitObjectNV &&) = delete;
  NodeOpReorderThreadWithHitObjectNV(NodePointer<NodeId> hit_object, eastl::optional<NodePointer<NodeId>> hint = {},
    eastl::optional<NodePointer<NodeId>> bits = {})
  {
    this->hitObject = hit_object;
    this->hint = hint;
    this->bits = bits;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRestoreMemoryINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpRestoreMemoryINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> ptr;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(ptr);
  }
  NodeOpRestoreMemoryINTEL() = default;
  ~NodeOpRestoreMemoryINTEL() = default;
  NodeOpRestoreMemoryINTEL(const NodeOpRestoreMemoryINTEL &) = delete;
  NodeOpRestoreMemoryINTEL &operator=(const NodeOpRestoreMemoryINTEL &) = delete;
  NodeOpRestoreMemoryINTEL(NodeOpRestoreMemoryINTEL &&) = delete;
  NodeOpRestoreMemoryINTEL &operator=(NodeOpRestoreMemoryINTEL &&) = delete;
  NodeOpRestoreMemoryINTEL(NodePointer<NodeId> ptr) { this->ptr = ptr; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRetainEvent
{
  const NodeKind nodeKind = NodeKind::UnaryAction;
  const Op opCode = Op::OpRetainEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> event;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(event);
  }
  NodeOpRetainEvent() = default;
  ~NodeOpRetainEvent() = default;
  NodeOpRetainEvent(const NodeOpRetainEvent &) = delete;
  NodeOpRetainEvent &operator=(const NodeOpRetainEvent &) = delete;
  NodeOpRetainEvent(NodeOpRetainEvent &&) = delete;
  NodeOpRetainEvent &operator=(NodeOpRetainEvent &&) = delete;
  NodeOpRetainEvent(NodePointer<NodeId> event) { this->event = event; }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeUnaryAction::visit(NodeUnaryAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::UnaryAction)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAssumeTrueKHR:
        if (visitor(reinterpret_cast<NodeOpAssumeTrueKHR *>(node)))
          return true;
        break;
      case Op::OpAtomicFlagClear:
        if (visitor(reinterpret_cast<NodeOpAtomicFlagClear *>(node)))
          return true;
        break;
      case Op::OpAtomicStore:
        if (visitor(reinterpret_cast<NodeOpAtomicStore *>(node)))
          return true;
        break;
      case Op::OpEmitStreamVertex:
        if (visitor(reinterpret_cast<NodeOpEmitStreamVertex *>(node)))
          return true;
        break;
      case Op::OpEndStreamPrimitive:
        if (visitor(reinterpret_cast<NodeOpEndStreamPrimitive *>(node)))
          return true;
        break;
      case Op::OpFinalizeNodePayloadsAMDX:
        if (visitor(reinterpret_cast<NodeOpFinalizeNodePayloadsAMDX *>(node)))
          return true;
        break;
      case Op::OpHitObjectRecordEmptyNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectRecordEmptyNV *>(node)))
          return true;
        break;
      case Op::OpInitializeNodePayloadsAMDX:
        if (visitor(reinterpret_cast<NodeOpInitializeNodePayloadsAMDX *>(node)))
          return true;
        break;
      case Op::OpLifetimeStart:
        if (visitor(reinterpret_cast<NodeOpLifetimeStart *>(node)))
          return true;
        break;
      case Op::OpLifetimeStop:
        if (visitor(reinterpret_cast<NodeOpLifetimeStop *>(node)))
          return true;
        break;
      case Op::OpMemoryNamedBarrier:
        if (visitor(reinterpret_cast<NodeOpMemoryNamedBarrier *>(node)))
          return true;
        break;
      case Op::OpRayQueryConfirmIntersectionKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryConfirmIntersectionKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryTerminateKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryTerminateKHR *>(node)))
          return true;
        break;
      case Op::OpReleaseEvent:
        if (visitor(reinterpret_cast<NodeOpReleaseEvent *>(node)))
          return true;
        break;
      case Op::OpReorderThreadWithHitObjectNV:
        if (visitor(reinterpret_cast<NodeOpReorderThreadWithHitObjectNV *>(node)))
          return true;
        break;
      case Op::OpRestoreMemoryINTEL:
        if (visitor(reinterpret_cast<NodeOpRestoreMemoryINTEL *>(node)))
          return true;
        break;
      case Op::OpRetainEvent:
        if (visitor(reinterpret_cast<NodeOpRetainEvent *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
template <typename T>
inline bool NodeAction::visit(NodeAction *node, T visitor)
{
  if (node->nodeKind == NodeKind::Action)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpBeginInvocationInterlockEXT:
        if (visitor(reinterpret_cast<NodeOpBeginInvocationInterlockEXT *>(node)))
          return true;
        break;
      case Op::OpDemoteToHelperInvocation:
        if (visitor(reinterpret_cast<NodeOpDemoteToHelperInvocation *>(node)))
          return true;
        break;
      // duplicated OpDemoteToHelperInvocationEXT = 5380
      case Op::OpEmitVertex:
        if (visitor(reinterpret_cast<NodeOpEmitVertex *>(node)))
          return true;
        break;
      case Op::OpEndInvocationInterlockEXT:
        if (visitor(reinterpret_cast<NodeOpEndInvocationInterlockEXT *>(node)))
          return true;
        break;
      case Op::OpEndPrimitive:
        if (visitor(reinterpret_cast<NodeOpEndPrimitive *>(node)))
          return true;
        break;
      case Op::OpIgnoreIntersectionKHR:
        if (visitor(reinterpret_cast<NodeOpIgnoreIntersectionKHR *>(node)))
          return true;
        break;
      case Op::OpIgnoreIntersectionNV:
        if (visitor(reinterpret_cast<NodeOpIgnoreIntersectionNV *>(node)))
          return true;
        break;
      case Op::OpLine:
        if (visitor(reinterpret_cast<NodeOpLine *>(node)))
          return true;
        break;
      case Op::OpNoLine:
        if (visitor(reinterpret_cast<NodeOpNoLine *>(node)))
          return true;
        break;
      case Op::OpTerminateInvocation:
        if (visitor(reinterpret_cast<NodeOpTerminateInvocation *>(node)))
          return true;
        break;
      case Op::OpTerminateRayKHR:
        if (visitor(reinterpret_cast<NodeOpTerminateRayKHR *>(node)))
          return true;
        break;
      case Op::OpTerminateRayNV:
        if (visitor(reinterpret_cast<NodeOpTerminateRayNV *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeBinaryAction::is(node))
    {
      if (NodeBinaryAction::visit(reinterpret_cast<NodeBinaryAction *>(node), visitor))
        return true;
    }
    else if (NodeImageAction::is(node))
    {
      if (NodeImageAction::visit(reinterpret_cast<NodeImageAction *>(node), visitor))
        return true;
    }
    else if (NodeMultinaryAction::is(node))
    {
      if (NodeMultinaryAction::visit(reinterpret_cast<NodeMultinaryAction *>(node), visitor))
        return true;
    }
    else if (NodeScopedAction::is(node))
    {
      if (NodeScopedAction::visit(reinterpret_cast<NodeScopedAction *>(node), visitor))
        return true;
    }
    else if (NodeTrinaryAction::is(node))
    {
      if (NodeTrinaryAction::visit(reinterpret_cast<NodeTrinaryAction *>(node), visitor))
        return true;
    }
    else if (NodeUnaryAction::is(node))
    {
      if (NodeUnaryAction::visit(reinterpret_cast<NodeUnaryAction *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeBlockEnd : Node
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeBlockEnd *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpUnreachable
{
  const NodeKind nodeKind = NodeKind::BlockEnd;
  const Op opCode = Op::OpUnreachable;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpUnreachable() = default;
  ~NodeOpUnreachable() = default;
  NodeOpUnreachable(const NodeOpUnreachable &) = delete;
  NodeOpUnreachable &operator=(const NodeOpUnreachable &) = delete;
  NodeOpUnreachable(NodeOpUnreachable &&) = delete;
  NodeOpUnreachable &operator=(NodeOpUnreachable &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeBranch : NodeBlockEnd
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeBranch *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpBranch
{
  const NodeKind nodeKind = NodeKind::Branch;
  const Op opCode = Op::OpBranch;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> targetLabel;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(targetLabel);
  }
  NodeOpBranch() = default;
  ~NodeOpBranch() = default;
  NodeOpBranch(const NodeOpBranch &) = delete;
  NodeOpBranch &operator=(const NodeOpBranch &) = delete;
  NodeOpBranch(NodeOpBranch &&) = delete;
  NodeOpBranch &operator=(NodeOpBranch &&) = delete;
  NodeOpBranch(NodePointer<NodeId> target_label) { this->targetLabel = target_label; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBranchConditional
{
  const NodeKind nodeKind = NodeKind::Branch;
  const Op opCode = Op::OpBranchConditional;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> condition;
  NodePointer<NodeId> trueLabel;
  NodePointer<NodeId> falseLabel;
  eastl::vector<LiteralInteger> branchWeights;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(condition);
    visitor(trueLabel);
    visitor(falseLabel);
  }
  NodeOpBranchConditional() = default;
  ~NodeOpBranchConditional() = default;
  NodeOpBranchConditional(const NodeOpBranchConditional &) = delete;
  NodeOpBranchConditional &operator=(const NodeOpBranchConditional &) = delete;
  NodeOpBranchConditional(NodeOpBranchConditional &&) = delete;
  NodeOpBranchConditional &operator=(NodeOpBranchConditional &&) = delete;
  NodeOpBranchConditional(NodePointer<NodeId> condition, NodePointer<NodeId> true_label, NodePointer<NodeId> false_label,
    LiteralInteger *branch_weights = nullptr, size_t branch_weights_count = 0)
  {
    this->condition = condition;
    this->trueLabel = true_label;
    this->falseLabel = false_label;
    this->branchWeights.assign(branch_weights, branch_weights + branch_weights_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeBranch::visit(NodeBranch *node, T visitor)
{
  if (node->nodeKind == NodeKind::Branch)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpBranch:
        if (visitor(reinterpret_cast<NodeOpBranch *>(node)))
          return true;
        break;
      case Op::OpBranchConditional:
        if (visitor(reinterpret_cast<NodeOpBranchConditional *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeExit : NodeBlockEnd
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeExit *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpKill
{
  const NodeKind nodeKind = NodeKind::Exit;
  const Op opCode = Op::OpKill;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpKill() = default;
  ~NodeOpKill() = default;
  NodeOpKill(const NodeOpKill &) = delete;
  NodeOpKill &operator=(const NodeOpKill &) = delete;
  NodeOpKill(NodeOpKill &&) = delete;
  NodeOpKill &operator=(NodeOpKill &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeExit::visit(NodeExit *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpKill *>(node)))
    return true;
  return visitor(node);
}
struct NodeReturn : NodeBlockEnd
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeReturn *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpReturn
{
  const NodeKind nodeKind = NodeKind::Return;
  const Op opCode = Op::OpReturn;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpReturn() = default;
  ~NodeOpReturn() = default;
  NodeOpReturn(const NodeOpReturn &) = delete;
  NodeOpReturn &operator=(const NodeOpReturn &) = delete;
  NodeOpReturn(NodeOpReturn &&) = delete;
  NodeOpReturn &operator=(NodeOpReturn &&) = delete;
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReturnValue
{
  const NodeKind nodeKind = NodeKind::Return;
  const Op opCode = Op::OpReturnValue;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(value);
  }
  NodeOpReturnValue() = default;
  ~NodeOpReturnValue() = default;
  NodeOpReturnValue(const NodeOpReturnValue &) = delete;
  NodeOpReturnValue &operator=(const NodeOpReturnValue &) = delete;
  NodeOpReturnValue(NodeOpReturnValue &&) = delete;
  NodeOpReturnValue &operator=(NodeOpReturnValue &&) = delete;
  NodeOpReturnValue(NodePointer<NodeId> value) { this->value = value; }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeReturn::visit(NodeReturn *node, T visitor)
{
  if (node->nodeKind == NodeKind::Return)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpReturn:
        if (visitor(reinterpret_cast<NodeOpReturn *>(node)))
          return true;
        break;
      case Op::OpReturnValue:
        if (visitor(reinterpret_cast<NodeOpReturnValue *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeSwitch : NodeBlockEnd
{
  NodePointer<NodeOperation> value;
  NodePointer<NodeBlock> defaultBlock;
  struct Case
  {
    LiteralInteger value;
    NodePointer<NodeBlock> block;
  };
  eastl::vector<Case> cases;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeSwitch *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpSwitch
{
  const NodeKind nodeKind = NodeKind::Switch;
  const Op opCode = Op::OpSwitch;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  NodePointer<NodeOperation> value;
  NodePointer<NodeBlock> defaultBlock;
  struct Case
  {
    LiteralInteger value;
    NodePointer<NodeBlock> block;
  };
  eastl::vector<Case> cases;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(value);
    visitor(defaultBlock);
    for (auto &&c : cases)
      visitor(c.block);
  }
  NodeOpSwitch() = default;
  ~NodeOpSwitch() = default;
  NodeOpSwitch(const NodeOpSwitch &) = delete;
  NodeOpSwitch &operator=(const NodeOpSwitch &) = delete;
  NodeOpSwitch(NodeOpSwitch &&) = delete;
  NodeOpSwitch &operator=(NodeOpSwitch &&) = delete;
  NodeOpSwitch(NodePointer<NodeId> selector, NodePointer<NodeId> _default, NodePairLiteralIntegerIdRef *target = nullptr,
    size_t target_count = 0)
  {
    value = selector;
    defaultBlock = _default;
    cases.reserve(target_count);
    for (int i = 0; i < target_count; ++i)
    {
      Case cblock;
      cblock.value = target[i].first;
      cblock.block = target[i].second;
      cases.push_back(cblock);
    }
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeSwitch::visit(NodeSwitch *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpSwitch *>(node)))
    return true;
  return visitor(node);
}
template <typename T>
inline bool NodeBlockEnd::visit(NodeBlockEnd *node, T visitor)
{
  if (node->nodeKind == NodeKind::BlockEnd)
  {
    // only one operation
    if (node->opCode == Op::OpUnreachable)
    {
      if (visitor(reinterpret_cast<NodeOpUnreachable *>(node)))
        return true;
    }
  }
  else
  {
    if (NodeBranch::is(node))
    {
      if (NodeBranch::visit(reinterpret_cast<NodeBranch *>(node), visitor))
        return true;
    }
    else if (NodeExit::is(node))
    {
      if (NodeExit::visit(reinterpret_cast<NodeExit *>(node), visitor))
        return true;
    }
    else if (NodeReturn::is(node))
    {
      if (NodeReturn::visit(reinterpret_cast<NodeReturn *>(node), visitor))
        return true;
    }
    else if (NodeSwitch::is(node))
    {
      if (NodeSwitch::visit(reinterpret_cast<NodeSwitch *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeId : Node
{
  Id resultId;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeId *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpAliasDomainDeclINTEL
{
  const NodeKind nodeKind = NodeKind::Id;
  const Op opCode = Op::OpAliasDomainDeclINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::optional<NodePointer<NodeId>> name;
  template <typename T>
  void visitRefs(T visitor)
  {
    if (name)
      visitor(*name);
  }
  NodeOpAliasDomainDeclINTEL() = default;
  ~NodeOpAliasDomainDeclINTEL() = default;
  NodeOpAliasDomainDeclINTEL(const NodeOpAliasDomainDeclINTEL &) = delete;
  NodeOpAliasDomainDeclINTEL &operator=(const NodeOpAliasDomainDeclINTEL &) = delete;
  NodeOpAliasDomainDeclINTEL(NodeOpAliasDomainDeclINTEL &&) = delete;
  NodeOpAliasDomainDeclINTEL &operator=(NodeOpAliasDomainDeclINTEL &&) = delete;
  NodeOpAliasDomainDeclINTEL(Id id_result, eastl::optional<NodePointer<NodeId>> name = {})
  {
    this->resultId = id_result;
    this->name = name;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAliasScopeDeclINTEL
{
  const NodeKind nodeKind = NodeKind::Id;
  const Op opCode = Op::OpAliasScopeDeclINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> aliasDomain;
  eastl::optional<NodePointer<NodeId>> name;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(aliasDomain);
    if (name)
      visitor(*name);
  }
  NodeOpAliasScopeDeclINTEL() = default;
  ~NodeOpAliasScopeDeclINTEL() = default;
  NodeOpAliasScopeDeclINTEL(const NodeOpAliasScopeDeclINTEL &) = delete;
  NodeOpAliasScopeDeclINTEL &operator=(const NodeOpAliasScopeDeclINTEL &) = delete;
  NodeOpAliasScopeDeclINTEL(NodeOpAliasScopeDeclINTEL &&) = delete;
  NodeOpAliasScopeDeclINTEL &operator=(NodeOpAliasScopeDeclINTEL &&) = delete;
  NodeOpAliasScopeDeclINTEL(Id id_result, NodePointer<NodeId> alias_domain, eastl::optional<NodePointer<NodeId>> name = {})
  {
    this->resultId = id_result;
    this->aliasDomain = alias_domain;
    this->name = name;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAliasScopeListDeclINTEL
{
  const NodeKind nodeKind = NodeKind::Id;
  const Op opCode = Op::OpAliasScopeListDeclINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::vector<NodePointer<NodeId>> aliasscope1Aliasscope2;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&ref : aliasscope1Aliasscope2)
      visitor(ref);
  }
  NodeOpAliasScopeListDeclINTEL() = default;
  ~NodeOpAliasScopeListDeclINTEL() = default;
  NodeOpAliasScopeListDeclINTEL(const NodeOpAliasScopeListDeclINTEL &) = delete;
  NodeOpAliasScopeListDeclINTEL &operator=(const NodeOpAliasScopeListDeclINTEL &) = delete;
  NodeOpAliasScopeListDeclINTEL(NodeOpAliasScopeListDeclINTEL &&) = delete;
  NodeOpAliasScopeListDeclINTEL &operator=(NodeOpAliasScopeListDeclINTEL &&) = delete;
  NodeOpAliasScopeListDeclINTEL(Id id_result, NodePointer<NodeId> *alias_scope1_alias_scope2 = nullptr,
    size_t alias_scope1_alias_scope2_count = 0)
  {
    this->resultId = id_result;
    this->aliasscope1Aliasscope2.assign(alias_scope1_alias_scope2, alias_scope1_alias_scope2 + alias_scope1_alias_scope2_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDecorationGroup
{
  const NodeKind nodeKind = NodeKind::Id;
  const Op opCode = Op::OpDecorationGroup;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpDecorationGroup() = default;
  ~NodeOpDecorationGroup() = default;
  NodeOpDecorationGroup(const NodeOpDecorationGroup &) = delete;
  NodeOpDecorationGroup &operator=(const NodeOpDecorationGroup &) = delete;
  NodeOpDecorationGroup(NodeOpDecorationGroup &&) = delete;
  NodeOpDecorationGroup &operator=(NodeOpDecorationGroup &&) = delete;
  NodeOpDecorationGroup(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpString
{
  const NodeKind nodeKind = NodeKind::Id;
  const Op opCode = Op::OpString;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::string string;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpString() = default;
  ~NodeOpString() = default;
  NodeOpString(const NodeOpString &) = delete;
  NodeOpString &operator=(const NodeOpString &) = delete;
  NodeOpString(NodeOpString &&) = delete;
  NodeOpString &operator=(NodeOpString &&) = delete;
  NodeOpString(Id id_result, eastl::string string)
  {
    this->resultId = id_result;
    this->string = string;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeBlock : NodeId
{
  eastl::vector<NodePointer<Node>> instructions;
  NodePointer<NodeBlockEnd> exit;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeBlock *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpLabel
{
  const NodeKind nodeKind = NodeKind::Block;
  const Op opCode = Op::OpLabel;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::vector<NodePointer<Node>> instructions;
  NodePointer<NodeBlockEnd> exit;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&i : instructions)
      visitor(i);
    visitor(exit);
  }
  NodeOpLabel() = default;
  ~NodeOpLabel() = default;
  NodeOpLabel(const NodeOpLabel &) = delete;
  NodeOpLabel &operator=(const NodeOpLabel &) = delete;
  NodeOpLabel(NodeOpLabel &&) = delete;
  NodeOpLabel &operator=(NodeOpLabel &&) = delete;
  NodeOpLabel(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeBlock::visit(NodeBlock *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpLabel *>(node)))
    return true;
  return visitor(node);
}
struct NodeOperation : NodeId
{
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpAsmTargetINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpAsmTargetINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::string asmTarget;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpAsmTargetINTEL() = default;
  ~NodeOpAsmTargetINTEL() = default;
  NodeOpAsmTargetINTEL(const NodeOpAsmTargetINTEL &) = delete;
  NodeOpAsmTargetINTEL &operator=(const NodeOpAsmTargetINTEL &) = delete;
  NodeOpAsmTargetINTEL(NodeOpAsmTargetINTEL &&) = delete;
  NodeOpAsmTargetINTEL &operator=(NodeOpAsmTargetINTEL &&) = delete;
  NodeOpAsmTargetINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, eastl::string asm_target)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->asmTarget = asm_target;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCompositeConstruct
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpCompositeConstruct;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpCompositeConstruct() = default;
  ~NodeOpCompositeConstruct() = default;
  NodeOpCompositeConstruct(const NodeOpCompositeConstruct &) = delete;
  NodeOpCompositeConstruct &operator=(const NodeOpCompositeConstruct &) = delete;
  NodeOpCompositeConstruct(NodeOpCompositeConstruct &&) = delete;
  NodeOpCompositeConstruct &operator=(NodeOpCompositeConstruct &&) = delete;
  NodeOpCompositeConstruct(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> *constituents = nullptr,
    size_t constituents_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCompositeConstructContinuedINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpCompositeConstructContinuedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpCompositeConstructContinuedINTEL() = default;
  ~NodeOpCompositeConstructContinuedINTEL() = default;
  NodeOpCompositeConstructContinuedINTEL(const NodeOpCompositeConstructContinuedINTEL &) = delete;
  NodeOpCompositeConstructContinuedINTEL &operator=(const NodeOpCompositeConstructContinuedINTEL &) = delete;
  NodeOpCompositeConstructContinuedINTEL(NodeOpCompositeConstructContinuedINTEL &&) = delete;
  NodeOpCompositeConstructContinuedINTEL &operator=(NodeOpCompositeConstructContinuedINTEL &&) = delete;
  NodeOpCompositeConstructContinuedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> *constituents = nullptr, size_t constituents_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCreateUserEvent
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpCreateUserEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpCreateUserEvent() = default;
  ~NodeOpCreateUserEvent() = default;
  NodeOpCreateUserEvent(const NodeOpCreateUserEvent &) = delete;
  NodeOpCreateUserEvent &operator=(const NodeOpCreateUserEvent &) = delete;
  NodeOpCreateUserEvent(NodeOpCreateUserEvent &&) = delete;
  NodeOpCreateUserEvent &operator=(NodeOpCreateUserEvent &&) = delete;
  NodeOpCreateUserEvent(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDepthAttachmentReadEXT
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpDepthAttachmentReadEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::optional<NodePointer<NodeId>> sample;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    if (sample)
      visitor(*sample);
  }
  NodeOpDepthAttachmentReadEXT() = default;
  ~NodeOpDepthAttachmentReadEXT() = default;
  NodeOpDepthAttachmentReadEXT(const NodeOpDepthAttachmentReadEXT &) = delete;
  NodeOpDepthAttachmentReadEXT &operator=(const NodeOpDepthAttachmentReadEXT &) = delete;
  NodeOpDepthAttachmentReadEXT(NodeOpDepthAttachmentReadEXT &&) = delete;
  NodeOpDepthAttachmentReadEXT &operator=(NodeOpDepthAttachmentReadEXT &&) = delete;
  NodeOpDepthAttachmentReadEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, eastl::optional<NodePointer<NodeId>> sample = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sample = sample;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFunctionPointerCallINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpFunctionPointerCallINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::vector<NodePointer<NodeId>> operand1;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&ref : operand1)
      visitor(ref);
  }
  NodeOpFunctionPointerCallINTEL() = default;
  ~NodeOpFunctionPointerCallINTEL() = default;
  NodeOpFunctionPointerCallINTEL(const NodeOpFunctionPointerCallINTEL &) = delete;
  NodeOpFunctionPointerCallINTEL &operator=(const NodeOpFunctionPointerCallINTEL &) = delete;
  NodeOpFunctionPointerCallINTEL(NodeOpFunctionPointerCallINTEL &&) = delete;
  NodeOpFunctionPointerCallINTEL &operator=(NodeOpFunctionPointerCallINTEL &&) = delete;
  NodeOpFunctionPointerCallINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> *operand_1 = nullptr,
    size_t operand_1_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1.assign(operand_1, operand_1 + operand_1_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetDefaultQueue
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpGetDefaultQueue;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpGetDefaultQueue() = default;
  ~NodeOpGetDefaultQueue() = default;
  NodeOpGetDefaultQueue(const NodeOpGetDefaultQueue &) = delete;
  NodeOpGetDefaultQueue &operator=(const NodeOpGetDefaultQueue &) = delete;
  NodeOpGetDefaultQueue(NodeOpGetDefaultQueue &&) = delete;
  NodeOpGetDefaultQueue &operator=(NodeOpGetDefaultQueue &&) = delete;
  NodeOpGetDefaultQueue(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsHelperInvocationEXT
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpIsHelperInvocationEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpIsHelperInvocationEXT() = default;
  ~NodeOpIsHelperInvocationEXT() = default;
  NodeOpIsHelperInvocationEXT(const NodeOpIsHelperInvocationEXT &) = delete;
  NodeOpIsHelperInvocationEXT &operator=(const NodeOpIsHelperInvocationEXT &) = delete;
  NodeOpIsHelperInvocationEXT(NodeOpIsHelperInvocationEXT &&) = delete;
  NodeOpIsHelperInvocationEXT &operator=(NodeOpIsHelperInvocationEXT &&) = delete;
  NodeOpIsHelperInvocationEXT(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSaveMemoryINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSaveMemoryINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSaveMemoryINTEL() = default;
  ~NodeOpSaveMemoryINTEL() = default;
  NodeOpSaveMemoryINTEL(const NodeOpSaveMemoryINTEL &) = delete;
  NodeOpSaveMemoryINTEL &operator=(const NodeOpSaveMemoryINTEL &) = delete;
  NodeOpSaveMemoryINTEL(NodeOpSaveMemoryINTEL &&) = delete;
  NodeOpSaveMemoryINTEL &operator=(NodeOpSaveMemoryINTEL &&) = delete;
  NodeOpSaveMemoryINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpStencilAttachmentReadEXT
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpStencilAttachmentReadEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::optional<NodePointer<NodeId>> sample;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    if (sample)
      visitor(*sample);
  }
  NodeOpStencilAttachmentReadEXT() = default;
  ~NodeOpStencilAttachmentReadEXT() = default;
  NodeOpStencilAttachmentReadEXT(const NodeOpStencilAttachmentReadEXT &) = delete;
  NodeOpStencilAttachmentReadEXT &operator=(const NodeOpStencilAttachmentReadEXT &) = delete;
  NodeOpStencilAttachmentReadEXT(NodeOpStencilAttachmentReadEXT &&) = delete;
  NodeOpStencilAttachmentReadEXT &operator=(NodeOpStencilAttachmentReadEXT &&) = delete;
  NodeOpStencilAttachmentReadEXT(Id id_result, NodePointer<NodeTypedef> id_result_type,
    eastl::optional<NodePointer<NodeId>> sample = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sample = sample;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(const NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(
    const NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(
    NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(const NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(
    const NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(const NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUndef
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpUndef;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpUndef() = default;
  ~NodeOpUndef() = default;
  NodeOpUndef(const NodeOpUndef &) = delete;
  NodeOpUndef &operator=(const NodeOpUndef &) = delete;
  NodeOpUndef(NodeOpUndef &&) = delete;
  NodeOpUndef &operator=(NodeOpUndef &&) = delete;
  NodeOpUndef(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDGcnShaderTime
{
  const NodeKind nodeKind = NodeKind::Operation;
  const Op opCode = Op::OpExtInst;
  const AMDGcnShader extOpCode = AMDGcnShader::TimeAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_gcn_shader;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpAMDGcnShaderTime() = default;
  ~NodeOpAMDGcnShaderTime() = default;
  NodeOpAMDGcnShaderTime(const NodeOpAMDGcnShaderTime &) = delete;
  NodeOpAMDGcnShaderTime &operator=(const NodeOpAMDGcnShaderTime &) = delete;
  NodeOpAMDGcnShaderTime(NodeOpAMDGcnShaderTime &&) = delete;
  NodeOpAMDGcnShaderTime &operator=(NodeOpAMDGcnShaderTime &&) = delete;
  NodeOpAMDGcnShaderTime(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeBinaryOperation : NodeOperation
{
  NodePointer<NodeId> first;
  NodePointer<NodeId> second;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeBinaryOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpGLSLstd450Atan2
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Atan2;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> y;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(y);
    visitor(x);
  }
  NodeOpGLSLstd450Atan2() = default;
  ~NodeOpGLSLstd450Atan2() = default;
  NodeOpGLSLstd450Atan2(const NodeOpGLSLstd450Atan2 &) = delete;
  NodeOpGLSLstd450Atan2 &operator=(const NodeOpGLSLstd450Atan2 &) = delete;
  NodeOpGLSLstd450Atan2(NodeOpGLSLstd450Atan2 &&) = delete;
  NodeOpGLSLstd450Atan2 &operator=(NodeOpGLSLstd450Atan2 &&) = delete;
  NodeOpGLSLstd450Atan2(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> y, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->y = y;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Cross
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Cross;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450Cross() = default;
  ~NodeOpGLSLstd450Cross() = default;
  NodeOpGLSLstd450Cross(const NodeOpGLSLstd450Cross &) = delete;
  NodeOpGLSLstd450Cross &operator=(const NodeOpGLSLstd450Cross &) = delete;
  NodeOpGLSLstd450Cross(NodeOpGLSLstd450Cross &&) = delete;
  NodeOpGLSLstd450Cross &operator=(NodeOpGLSLstd450Cross &&) = delete;
  NodeOpGLSLstd450Cross(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Distance
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Distance;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p0;
  NodePointer<NodeId> p1;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p0);
    visitor(p1);
  }
  NodeOpGLSLstd450Distance() = default;
  ~NodeOpGLSLstd450Distance() = default;
  NodeOpGLSLstd450Distance(const NodeOpGLSLstd450Distance &) = delete;
  NodeOpGLSLstd450Distance &operator=(const NodeOpGLSLstd450Distance &) = delete;
  NodeOpGLSLstd450Distance(NodeOpGLSLstd450Distance &&) = delete;
  NodeOpGLSLstd450Distance &operator=(NodeOpGLSLstd450Distance &&) = delete;
  NodeOpGLSLstd450Distance(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p0, NodePointer<NodeId> p1)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p0 = p0;
    this->p1 = p1;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FMax
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FMax;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450FMax() = default;
  ~NodeOpGLSLstd450FMax() = default;
  NodeOpGLSLstd450FMax(const NodeOpGLSLstd450FMax &) = delete;
  NodeOpGLSLstd450FMax &operator=(const NodeOpGLSLstd450FMax &) = delete;
  NodeOpGLSLstd450FMax(NodeOpGLSLstd450FMax &&) = delete;
  NodeOpGLSLstd450FMax &operator=(NodeOpGLSLstd450FMax &&) = delete;
  NodeOpGLSLstd450FMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FMin
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FMin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450FMin() = default;
  ~NodeOpGLSLstd450FMin() = default;
  NodeOpGLSLstd450FMin(const NodeOpGLSLstd450FMin &) = delete;
  NodeOpGLSLstd450FMin &operator=(const NodeOpGLSLstd450FMin &) = delete;
  NodeOpGLSLstd450FMin(NodeOpGLSLstd450FMin &&) = delete;
  NodeOpGLSLstd450FMin &operator=(NodeOpGLSLstd450FMin &&) = delete;
  NodeOpGLSLstd450FMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Frexp
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Frexp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> exp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(exp);
  }
  NodeOpGLSLstd450Frexp() = default;
  ~NodeOpGLSLstd450Frexp() = default;
  NodeOpGLSLstd450Frexp(const NodeOpGLSLstd450Frexp &) = delete;
  NodeOpGLSLstd450Frexp &operator=(const NodeOpGLSLstd450Frexp &) = delete;
  NodeOpGLSLstd450Frexp(NodeOpGLSLstd450Frexp &&) = delete;
  NodeOpGLSLstd450Frexp &operator=(NodeOpGLSLstd450Frexp &&) = delete;
  NodeOpGLSLstd450Frexp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> exp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->exp = exp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450InterpolateAtOffset
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::InterpolateAtOffset;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> interpolant;
  NodePointer<NodeId> offset;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(interpolant);
    visitor(offset);
  }
  NodeOpGLSLstd450InterpolateAtOffset() = default;
  ~NodeOpGLSLstd450InterpolateAtOffset() = default;
  NodeOpGLSLstd450InterpolateAtOffset(const NodeOpGLSLstd450InterpolateAtOffset &) = delete;
  NodeOpGLSLstd450InterpolateAtOffset &operator=(const NodeOpGLSLstd450InterpolateAtOffset &) = delete;
  NodeOpGLSLstd450InterpolateAtOffset(NodeOpGLSLstd450InterpolateAtOffset &&) = delete;
  NodeOpGLSLstd450InterpolateAtOffset &operator=(NodeOpGLSLstd450InterpolateAtOffset &&) = delete;
  NodeOpGLSLstd450InterpolateAtOffset(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> interpolant,
    NodePointer<NodeId> offset)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->interpolant = interpolant;
    this->offset = offset;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450InterpolateAtSample
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::InterpolateAtSample;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> interpolant;
  NodePointer<NodeId> sample;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(interpolant);
    visitor(sample);
  }
  NodeOpGLSLstd450InterpolateAtSample() = default;
  ~NodeOpGLSLstd450InterpolateAtSample() = default;
  NodeOpGLSLstd450InterpolateAtSample(const NodeOpGLSLstd450InterpolateAtSample &) = delete;
  NodeOpGLSLstd450InterpolateAtSample &operator=(const NodeOpGLSLstd450InterpolateAtSample &) = delete;
  NodeOpGLSLstd450InterpolateAtSample(NodeOpGLSLstd450InterpolateAtSample &&) = delete;
  NodeOpGLSLstd450InterpolateAtSample &operator=(NodeOpGLSLstd450InterpolateAtSample &&) = delete;
  NodeOpGLSLstd450InterpolateAtSample(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> interpolant,
    NodePointer<NodeId> sample)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->interpolant = interpolant;
    this->sample = sample;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderExplicitVertexParameter extOpCode = AMDShaderExplicitVertexParameter::InterpolateAtVertexAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_explicit_vertex_parameter;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> interpolant;
  NodePointer<NodeId> vertexIdx;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(interpolant);
    visitor(vertexIdx);
  }
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex() = default;
  ~NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex() = default;
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex(
    const NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &) = delete;
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &operator=(
    const NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &) = delete;
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex(NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &&) = delete;
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &operator=(
    NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex &&) = delete;
  NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> interpolant, NodePointer<NodeId> vertex_idx)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->interpolant = interpolant;
    this->vertexIdx = vertex_idx;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Ldexp
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Ldexp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> exp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(exp);
  }
  NodeOpGLSLstd450Ldexp() = default;
  ~NodeOpGLSLstd450Ldexp() = default;
  NodeOpGLSLstd450Ldexp(const NodeOpGLSLstd450Ldexp &) = delete;
  NodeOpGLSLstd450Ldexp &operator=(const NodeOpGLSLstd450Ldexp &) = delete;
  NodeOpGLSLstd450Ldexp(NodeOpGLSLstd450Ldexp &&) = delete;
  NodeOpGLSLstd450Ldexp &operator=(NodeOpGLSLstd450Ldexp &&) = delete;
  NodeOpGLSLstd450Ldexp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> exp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->exp = exp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Modf
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Modf;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> i;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(i);
  }
  NodeOpGLSLstd450Modf() = default;
  ~NodeOpGLSLstd450Modf() = default;
  NodeOpGLSLstd450Modf(const NodeOpGLSLstd450Modf &) = delete;
  NodeOpGLSLstd450Modf &operator=(const NodeOpGLSLstd450Modf &) = delete;
  NodeOpGLSLstd450Modf(NodeOpGLSLstd450Modf &&) = delete;
  NodeOpGLSLstd450Modf &operator=(NodeOpGLSLstd450Modf &&) = delete;
  NodeOpGLSLstd450Modf(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> i)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->i = i;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450NMax
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::NMax;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450NMax() = default;
  ~NodeOpGLSLstd450NMax() = default;
  NodeOpGLSLstd450NMax(const NodeOpGLSLstd450NMax &) = delete;
  NodeOpGLSLstd450NMax &operator=(const NodeOpGLSLstd450NMax &) = delete;
  NodeOpGLSLstd450NMax(NodeOpGLSLstd450NMax &&) = delete;
  NodeOpGLSLstd450NMax &operator=(NodeOpGLSLstd450NMax &&) = delete;
  NodeOpGLSLstd450NMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450NMin
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::NMin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450NMin() = default;
  ~NodeOpGLSLstd450NMin() = default;
  NodeOpGLSLstd450NMin(const NodeOpGLSLstd450NMin &) = delete;
  NodeOpGLSLstd450NMin &operator=(const NodeOpGLSLstd450NMin &) = delete;
  NodeOpGLSLstd450NMin(NodeOpGLSLstd450NMin &&) = delete;
  NodeOpGLSLstd450NMin &operator=(NodeOpGLSLstd450NMin &&) = delete;
  NodeOpGLSLstd450NMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAbsISubINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpAbsISubINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpAbsISubINTEL() = default;
  ~NodeOpAbsISubINTEL() = default;
  NodeOpAbsISubINTEL(const NodeOpAbsISubINTEL &) = delete;
  NodeOpAbsISubINTEL &operator=(const NodeOpAbsISubINTEL &) = delete;
  NodeOpAbsISubINTEL(NodeOpAbsISubINTEL &&) = delete;
  NodeOpAbsISubINTEL &operator=(NodeOpAbsISubINTEL &&) = delete;
  NodeOpAbsISubINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAbsUSubINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpAbsUSubINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpAbsUSubINTEL() = default;
  ~NodeOpAbsUSubINTEL() = default;
  NodeOpAbsUSubINTEL(const NodeOpAbsUSubINTEL &) = delete;
  NodeOpAbsUSubINTEL &operator=(const NodeOpAbsUSubINTEL &) = delete;
  NodeOpAbsUSubINTEL(NodeOpAbsUSubINTEL &&) = delete;
  NodeOpAbsUSubINTEL &operator=(NodeOpAbsUSubINTEL &&) = delete;
  NodeOpAbsUSubINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAsmINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpAsmINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> asmType;
  NodePointer<NodeId> target;
  eastl::string asmInstructions;
  eastl::string constraints;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(asmType);
    visitor(target);
  }
  NodeOpAsmINTEL() = default;
  ~NodeOpAsmINTEL() = default;
  NodeOpAsmINTEL(const NodeOpAsmINTEL &) = delete;
  NodeOpAsmINTEL &operator=(const NodeOpAsmINTEL &) = delete;
  NodeOpAsmINTEL(NodeOpAsmINTEL &&) = delete;
  NodeOpAsmINTEL &operator=(NodeOpAsmINTEL &&) = delete;
  NodeOpAsmINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> asm_type, NodePointer<NodeId> target,
    eastl::string asm_instructions, eastl::string constraints)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->asmType = asm_type;
    this->target = target;
    this->asmInstructions = asm_instructions;
    this->constraints = constraints;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitwiseAnd
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpBitwiseAnd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpBitwiseAnd() = default;
  ~NodeOpBitwiseAnd() = default;
  NodeOpBitwiseAnd(const NodeOpBitwiseAnd &) = delete;
  NodeOpBitwiseAnd &operator=(const NodeOpBitwiseAnd &) = delete;
  NodeOpBitwiseAnd(NodeOpBitwiseAnd &&) = delete;
  NodeOpBitwiseAnd &operator=(NodeOpBitwiseAnd &&) = delete;
  NodeOpBitwiseAnd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitwiseOr
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpBitwiseOr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpBitwiseOr() = default;
  ~NodeOpBitwiseOr() = default;
  NodeOpBitwiseOr(const NodeOpBitwiseOr &) = delete;
  NodeOpBitwiseOr &operator=(const NodeOpBitwiseOr &) = delete;
  NodeOpBitwiseOr(NodeOpBitwiseOr &&) = delete;
  NodeOpBitwiseOr &operator=(NodeOpBitwiseOr &&) = delete;
  NodeOpBitwiseOr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitwiseXor
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpBitwiseXor;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpBitwiseXor() = default;
  ~NodeOpBitwiseXor() = default;
  NodeOpBitwiseXor(const NodeOpBitwiseXor &) = delete;
  NodeOpBitwiseXor &operator=(const NodeOpBitwiseXor &) = delete;
  NodeOpBitwiseXor(NodeOpBitwiseXor &&) = delete;
  NodeOpBitwiseXor &operator=(NodeOpBitwiseXor &&) = delete;
  NodeOpBitwiseXor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCompositeInsert
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpCompositeInsert;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> object;
  NodePointer<NodeId> composite;
  eastl::vector<LiteralInteger> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(object);
    visitor(composite);
  }
  NodeOpCompositeInsert() = default;
  ~NodeOpCompositeInsert() = default;
  NodeOpCompositeInsert(const NodeOpCompositeInsert &) = delete;
  NodeOpCompositeInsert &operator=(const NodeOpCompositeInsert &) = delete;
  NodeOpCompositeInsert(NodeOpCompositeInsert &&) = delete;
  NodeOpCompositeInsert &operator=(NodeOpCompositeInsert &&) = delete;
  NodeOpCompositeInsert(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> object,
    NodePointer<NodeId> composite, LiteralInteger *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->object = object;
    this->composite = composite;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixLoadKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpCooperativeMatrixLoadKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> memoryLayout;
  eastl::optional<NodePointer<NodeId>> stride;
  eastl::optional<MemoryAccessMask> memoryOperand;
  // extra values for memoryOperand
  LiteralInteger memoryOperandAligned;
  NodePointer<NodeOperation> memoryOperandMakePointerAvailable;
  NodePointer<NodeOperation> memoryOperandMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryOperandMakePointerVisible;
  NodePointer<NodeOperation> memoryOperandMakePointerVisibleKHR;
  NodePointer<NodeId> memoryOperandAliasScopeINTELMask;
  NodePointer<NodeId> memoryOperandNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memoryLayout);
    if (stride)
      visitor(*stride);
    if (memoryOperandMakePointerAvailable)
      visitor(memoryOperandMakePointerAvailable);
    if (memoryOperandMakePointerAvailableKHR)
      visitor(memoryOperandMakePointerAvailableKHR);
    if (memoryOperandMakePointerVisible)
      visitor(memoryOperandMakePointerVisible);
    if (memoryOperandMakePointerVisibleKHR)
      visitor(memoryOperandMakePointerVisibleKHR);
    if (memoryOperandAliasScopeINTELMask)
      visitor(memoryOperandAliasScopeINTELMask);
    if (memoryOperandNoAliasINTELMask)
      visitor(memoryOperandNoAliasINTELMask);
  }
  NodeOpCooperativeMatrixLoadKHR() = default;
  ~NodeOpCooperativeMatrixLoadKHR() = default;
  NodeOpCooperativeMatrixLoadKHR(const NodeOpCooperativeMatrixLoadKHR &) = delete;
  NodeOpCooperativeMatrixLoadKHR &operator=(const NodeOpCooperativeMatrixLoadKHR &) = delete;
  NodeOpCooperativeMatrixLoadKHR(NodeOpCooperativeMatrixLoadKHR &&) = delete;
  NodeOpCooperativeMatrixLoadKHR &operator=(NodeOpCooperativeMatrixLoadKHR &&) = delete;
  NodeOpCooperativeMatrixLoadKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeId> memory_layout, eastl::optional<NodePointer<NodeId>> stride = {},
    eastl::optional<MemoryAccessMask> memory_operand = {}, eastl::optional<LiteralInteger> memory_operand_aligned = {},
    NodePointer<NodeOperation> memory_operand_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_operand_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_operand_makePointerVisible = {},
    NodePointer<NodeOperation> memory_operand_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_operand_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_operand_noAliasINTELMask = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memoryLayout = memory_layout;
    this->stride = stride;
    this->memoryOperand = memory_operand;
    if (memory_operand_aligned)
      this->memoryOperandAligned = *memory_operand_aligned;
    this->memoryOperandMakePointerAvailable = memory_operand_makePointerAvailable;
    this->memoryOperandMakePointerAvailableKHR = memory_operand_makePointerAvailableKHR;
    this->memoryOperandMakePointerVisible = memory_operand_makePointerVisible;
    this->memoryOperandMakePointerVisibleKHR = memory_operand_makePointerVisibleKHR;
    this->memoryOperandAliasScopeINTELMask = memory_operand_aliasScopeINTELMask;
    this->memoryOperandNoAliasINTELMask = memory_operand_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDot
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpDot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpDot() = default;
  ~NodeOpDot() = default;
  NodeOpDot(const NodeOpDot &) = delete;
  NodeOpDot &operator=(const NodeOpDot &) = delete;
  NodeOpDot(NodeOpDot &&) = delete;
  NodeOpDot &operator=(NodeOpDot &&) = delete;
  NodeOpDot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpExpectKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExpectKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  NodePointer<NodeId> expectedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
    visitor(expectedValue);
  }
  NodeOpExpectKHR() = default;
  ~NodeOpExpectKHR() = default;
  NodeOpExpectKHR(const NodeOpExpectKHR &) = delete;
  NodeOpExpectKHR &operator=(const NodeOpExpectKHR &) = delete;
  NodeOpExpectKHR(NodeOpExpectKHR &&) = delete;
  NodeOpExpectKHR &operator=(NodeOpExpectKHR &&) = delete;
  NodeOpExpectKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value, NodePointer<NodeId> expected_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
    this->expectedValue = expected_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFAdd
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFAdd() = default;
  ~NodeOpFAdd() = default;
  NodeOpFAdd(const NodeOpFAdd &) = delete;
  NodeOpFAdd &operator=(const NodeOpFAdd &) = delete;
  NodeOpFAdd(NodeOpFAdd &&) = delete;
  NodeOpFAdd &operator=(NodeOpFAdd &&) = delete;
  NodeOpFAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFDiv
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFDiv;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFDiv() = default;
  ~NodeOpFDiv() = default;
  NodeOpFDiv(const NodeOpFDiv &) = delete;
  NodeOpFDiv &operator=(const NodeOpFDiv &) = delete;
  NodeOpFDiv(NodeOpFDiv &&) = delete;
  NodeOpFDiv &operator=(NodeOpFDiv &&) = delete;
  NodeOpFDiv(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFMod
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFMod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFMod() = default;
  ~NodeOpFMod() = default;
  NodeOpFMod(const NodeOpFMod &) = delete;
  NodeOpFMod &operator=(const NodeOpFMod &) = delete;
  NodeOpFMod(NodeOpFMod &&) = delete;
  NodeOpFMod &operator=(NodeOpFMod &&) = delete;
  NodeOpFMod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFMul
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFMul;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFMul() = default;
  ~NodeOpFMul() = default;
  NodeOpFMul(const NodeOpFMul &) = delete;
  NodeOpFMul &operator=(const NodeOpFMul &) = delete;
  NodeOpFMul(NodeOpFMul &&) = delete;
  NodeOpFMul &operator=(NodeOpFMul &&) = delete;
  NodeOpFMul(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdEqual() = default;
  ~NodeOpFOrdEqual() = default;
  NodeOpFOrdEqual(const NodeOpFOrdEqual &) = delete;
  NodeOpFOrdEqual &operator=(const NodeOpFOrdEqual &) = delete;
  NodeOpFOrdEqual(NodeOpFOrdEqual &&) = delete;
  NodeOpFOrdEqual &operator=(NodeOpFOrdEqual &&) = delete;
  NodeOpFOrdEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdGreaterThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdGreaterThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdGreaterThan() = default;
  ~NodeOpFOrdGreaterThan() = default;
  NodeOpFOrdGreaterThan(const NodeOpFOrdGreaterThan &) = delete;
  NodeOpFOrdGreaterThan &operator=(const NodeOpFOrdGreaterThan &) = delete;
  NodeOpFOrdGreaterThan(NodeOpFOrdGreaterThan &&) = delete;
  NodeOpFOrdGreaterThan &operator=(NodeOpFOrdGreaterThan &&) = delete;
  NodeOpFOrdGreaterThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdGreaterThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdGreaterThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdGreaterThanEqual() = default;
  ~NodeOpFOrdGreaterThanEqual() = default;
  NodeOpFOrdGreaterThanEqual(const NodeOpFOrdGreaterThanEqual &) = delete;
  NodeOpFOrdGreaterThanEqual &operator=(const NodeOpFOrdGreaterThanEqual &) = delete;
  NodeOpFOrdGreaterThanEqual(NodeOpFOrdGreaterThanEqual &&) = delete;
  NodeOpFOrdGreaterThanEqual &operator=(NodeOpFOrdGreaterThanEqual &&) = delete;
  NodeOpFOrdGreaterThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdLessThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdLessThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdLessThan() = default;
  ~NodeOpFOrdLessThan() = default;
  NodeOpFOrdLessThan(const NodeOpFOrdLessThan &) = delete;
  NodeOpFOrdLessThan &operator=(const NodeOpFOrdLessThan &) = delete;
  NodeOpFOrdLessThan(NodeOpFOrdLessThan &&) = delete;
  NodeOpFOrdLessThan &operator=(NodeOpFOrdLessThan &&) = delete;
  NodeOpFOrdLessThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdLessThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdLessThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdLessThanEqual() = default;
  ~NodeOpFOrdLessThanEqual() = default;
  NodeOpFOrdLessThanEqual(const NodeOpFOrdLessThanEqual &) = delete;
  NodeOpFOrdLessThanEqual &operator=(const NodeOpFOrdLessThanEqual &) = delete;
  NodeOpFOrdLessThanEqual(NodeOpFOrdLessThanEqual &&) = delete;
  NodeOpFOrdLessThanEqual &operator=(NodeOpFOrdLessThanEqual &&) = delete;
  NodeOpFOrdLessThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFOrdNotEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFOrdNotEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFOrdNotEqual() = default;
  ~NodeOpFOrdNotEqual() = default;
  NodeOpFOrdNotEqual(const NodeOpFOrdNotEqual &) = delete;
  NodeOpFOrdNotEqual &operator=(const NodeOpFOrdNotEqual &) = delete;
  NodeOpFOrdNotEqual(NodeOpFOrdNotEqual &&) = delete;
  NodeOpFOrdNotEqual &operator=(NodeOpFOrdNotEqual &&) = delete;
  NodeOpFOrdNotEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFPGARegINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFPGARegINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> result;
  NodePointer<NodeId> input;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(result);
    visitor(input);
  }
  NodeOpFPGARegINTEL() = default;
  ~NodeOpFPGARegINTEL() = default;
  NodeOpFPGARegINTEL(const NodeOpFPGARegINTEL &) = delete;
  NodeOpFPGARegINTEL &operator=(const NodeOpFPGARegINTEL &) = delete;
  NodeOpFPGARegINTEL(NodeOpFPGARegINTEL &&) = delete;
  NodeOpFPGARegINTEL &operator=(NodeOpFPGARegINTEL &&) = delete;
  NodeOpFPGARegINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> result, NodePointer<NodeId> input)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->result = result;
    this->input = input;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFRem
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFRem;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFRem() = default;
  ~NodeOpFRem() = default;
  NodeOpFRem(const NodeOpFRem &) = delete;
  NodeOpFRem &operator=(const NodeOpFRem &) = delete;
  NodeOpFRem(NodeOpFRem &&) = delete;
  NodeOpFRem &operator=(NodeOpFRem &&) = delete;
  NodeOpFRem(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFSub
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFSub;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFSub() = default;
  ~NodeOpFSub() = default;
  NodeOpFSub(const NodeOpFSub &) = delete;
  NodeOpFSub &operator=(const NodeOpFSub &) = delete;
  NodeOpFSub(NodeOpFSub &&) = delete;
  NodeOpFSub &operator=(NodeOpFSub &&) = delete;
  NodeOpFSub(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordEqual() = default;
  ~NodeOpFUnordEqual() = default;
  NodeOpFUnordEqual(const NodeOpFUnordEqual &) = delete;
  NodeOpFUnordEqual &operator=(const NodeOpFUnordEqual &) = delete;
  NodeOpFUnordEqual(NodeOpFUnordEqual &&) = delete;
  NodeOpFUnordEqual &operator=(NodeOpFUnordEqual &&) = delete;
  NodeOpFUnordEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordGreaterThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordGreaterThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordGreaterThan() = default;
  ~NodeOpFUnordGreaterThan() = default;
  NodeOpFUnordGreaterThan(const NodeOpFUnordGreaterThan &) = delete;
  NodeOpFUnordGreaterThan &operator=(const NodeOpFUnordGreaterThan &) = delete;
  NodeOpFUnordGreaterThan(NodeOpFUnordGreaterThan &&) = delete;
  NodeOpFUnordGreaterThan &operator=(NodeOpFUnordGreaterThan &&) = delete;
  NodeOpFUnordGreaterThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordGreaterThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordGreaterThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordGreaterThanEqual() = default;
  ~NodeOpFUnordGreaterThanEqual() = default;
  NodeOpFUnordGreaterThanEqual(const NodeOpFUnordGreaterThanEqual &) = delete;
  NodeOpFUnordGreaterThanEqual &operator=(const NodeOpFUnordGreaterThanEqual &) = delete;
  NodeOpFUnordGreaterThanEqual(NodeOpFUnordGreaterThanEqual &&) = delete;
  NodeOpFUnordGreaterThanEqual &operator=(NodeOpFUnordGreaterThanEqual &&) = delete;
  NodeOpFUnordGreaterThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordLessThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordLessThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordLessThan() = default;
  ~NodeOpFUnordLessThan() = default;
  NodeOpFUnordLessThan(const NodeOpFUnordLessThan &) = delete;
  NodeOpFUnordLessThan &operator=(const NodeOpFUnordLessThan &) = delete;
  NodeOpFUnordLessThan(NodeOpFUnordLessThan &&) = delete;
  NodeOpFUnordLessThan &operator=(NodeOpFUnordLessThan &&) = delete;
  NodeOpFUnordLessThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordLessThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordLessThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordLessThanEqual() = default;
  ~NodeOpFUnordLessThanEqual() = default;
  NodeOpFUnordLessThanEqual(const NodeOpFUnordLessThanEqual &) = delete;
  NodeOpFUnordLessThanEqual &operator=(const NodeOpFUnordLessThanEqual &) = delete;
  NodeOpFUnordLessThanEqual(NodeOpFUnordLessThanEqual &&) = delete;
  NodeOpFUnordLessThanEqual &operator=(NodeOpFUnordLessThanEqual &&) = delete;
  NodeOpFUnordLessThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFUnordNotEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFUnordNotEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpFUnordNotEqual() = default;
  ~NodeOpFUnordNotEqual() = default;
  NodeOpFUnordNotEqual(const NodeOpFUnordNotEqual &) = delete;
  NodeOpFUnordNotEqual &operator=(const NodeOpFUnordNotEqual &) = delete;
  NodeOpFUnordNotEqual(NodeOpFUnordNotEqual &&) = delete;
  NodeOpFUnordNotEqual &operator=(NodeOpFUnordNotEqual &&) = delete;
  NodeOpFUnordNotEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedCosINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedCosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedCosINTEL() = default;
  ~NodeOpFixedCosINTEL() = default;
  NodeOpFixedCosINTEL(const NodeOpFixedCosINTEL &) = delete;
  NodeOpFixedCosINTEL &operator=(const NodeOpFixedCosINTEL &) = delete;
  NodeOpFixedCosINTEL(NodeOpFixedCosINTEL &&) = delete;
  NodeOpFixedCosINTEL &operator=(NodeOpFixedCosINTEL &&) = delete;
  NodeOpFixedCosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type, NodePointer<NodeId> input,
    LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedCosPiINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedCosPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedCosPiINTEL() = default;
  ~NodeOpFixedCosPiINTEL() = default;
  NodeOpFixedCosPiINTEL(const NodeOpFixedCosPiINTEL &) = delete;
  NodeOpFixedCosPiINTEL &operator=(const NodeOpFixedCosPiINTEL &) = delete;
  NodeOpFixedCosPiINTEL(NodeOpFixedCosPiINTEL &&) = delete;
  NodeOpFixedCosPiINTEL &operator=(NodeOpFixedCosPiINTEL &&) = delete;
  NodeOpFixedCosPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedExpINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedExpINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedExpINTEL() = default;
  ~NodeOpFixedExpINTEL() = default;
  NodeOpFixedExpINTEL(const NodeOpFixedExpINTEL &) = delete;
  NodeOpFixedExpINTEL &operator=(const NodeOpFixedExpINTEL &) = delete;
  NodeOpFixedExpINTEL(NodeOpFixedExpINTEL &&) = delete;
  NodeOpFixedExpINTEL &operator=(NodeOpFixedExpINTEL &&) = delete;
  NodeOpFixedExpINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type, NodePointer<NodeId> input,
    LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedLogINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedLogINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedLogINTEL() = default;
  ~NodeOpFixedLogINTEL() = default;
  NodeOpFixedLogINTEL(const NodeOpFixedLogINTEL &) = delete;
  NodeOpFixedLogINTEL &operator=(const NodeOpFixedLogINTEL &) = delete;
  NodeOpFixedLogINTEL(NodeOpFixedLogINTEL &&) = delete;
  NodeOpFixedLogINTEL &operator=(NodeOpFixedLogINTEL &&) = delete;
  NodeOpFixedLogINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type, NodePointer<NodeId> input,
    LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedRecipINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedRecipINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedRecipINTEL() = default;
  ~NodeOpFixedRecipINTEL() = default;
  NodeOpFixedRecipINTEL(const NodeOpFixedRecipINTEL &) = delete;
  NodeOpFixedRecipINTEL &operator=(const NodeOpFixedRecipINTEL &) = delete;
  NodeOpFixedRecipINTEL(NodeOpFixedRecipINTEL &&) = delete;
  NodeOpFixedRecipINTEL &operator=(NodeOpFixedRecipINTEL &&) = delete;
  NodeOpFixedRecipINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedRsqrtINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedRsqrtINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedRsqrtINTEL() = default;
  ~NodeOpFixedRsqrtINTEL() = default;
  NodeOpFixedRsqrtINTEL(const NodeOpFixedRsqrtINTEL &) = delete;
  NodeOpFixedRsqrtINTEL &operator=(const NodeOpFixedRsqrtINTEL &) = delete;
  NodeOpFixedRsqrtINTEL(NodeOpFixedRsqrtINTEL &&) = delete;
  NodeOpFixedRsqrtINTEL &operator=(NodeOpFixedRsqrtINTEL &&) = delete;
  NodeOpFixedRsqrtINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedSinCosINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedSinCosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedSinCosINTEL() = default;
  ~NodeOpFixedSinCosINTEL() = default;
  NodeOpFixedSinCosINTEL(const NodeOpFixedSinCosINTEL &) = delete;
  NodeOpFixedSinCosINTEL &operator=(const NodeOpFixedSinCosINTEL &) = delete;
  NodeOpFixedSinCosINTEL(NodeOpFixedSinCosINTEL &&) = delete;
  NodeOpFixedSinCosINTEL &operator=(NodeOpFixedSinCosINTEL &&) = delete;
  NodeOpFixedSinCosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedSinCosPiINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedSinCosPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedSinCosPiINTEL() = default;
  ~NodeOpFixedSinCosPiINTEL() = default;
  NodeOpFixedSinCosPiINTEL(const NodeOpFixedSinCosPiINTEL &) = delete;
  NodeOpFixedSinCosPiINTEL &operator=(const NodeOpFixedSinCosPiINTEL &) = delete;
  NodeOpFixedSinCosPiINTEL(NodeOpFixedSinCosPiINTEL &&) = delete;
  NodeOpFixedSinCosPiINTEL &operator=(NodeOpFixedSinCosPiINTEL &&) = delete;
  NodeOpFixedSinCosPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedSinINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedSinINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedSinINTEL() = default;
  ~NodeOpFixedSinINTEL() = default;
  NodeOpFixedSinINTEL(const NodeOpFixedSinINTEL &) = delete;
  NodeOpFixedSinINTEL &operator=(const NodeOpFixedSinINTEL &) = delete;
  NodeOpFixedSinINTEL(NodeOpFixedSinINTEL &&) = delete;
  NodeOpFixedSinINTEL &operator=(NodeOpFixedSinINTEL &&) = delete;
  NodeOpFixedSinINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type, NodePointer<NodeId> input,
    LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedSinPiINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedSinPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedSinPiINTEL() = default;
  ~NodeOpFixedSinPiINTEL() = default;
  NodeOpFixedSinPiINTEL(const NodeOpFixedSinPiINTEL &) = delete;
  NodeOpFixedSinPiINTEL &operator=(const NodeOpFixedSinPiINTEL &) = delete;
  NodeOpFixedSinPiINTEL(NodeOpFixedSinPiINTEL &&) = delete;
  NodeOpFixedSinPiINTEL &operator=(NodeOpFixedSinPiINTEL &&) = delete;
  NodeOpFixedSinPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFixedSqrtINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpFixedSqrtINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputType;
  NodePointer<NodeId> input;
  LiteralInteger s;
  LiteralInteger i;
  LiteralInteger rI;
  LiteralInteger q;
  LiteralInteger o;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputType);
    visitor(input);
  }
  NodeOpFixedSqrtINTEL() = default;
  ~NodeOpFixedSqrtINTEL() = default;
  NodeOpFixedSqrtINTEL(const NodeOpFixedSqrtINTEL &) = delete;
  NodeOpFixedSqrtINTEL &operator=(const NodeOpFixedSqrtINTEL &) = delete;
  NodeOpFixedSqrtINTEL(NodeOpFixedSqrtINTEL &&) = delete;
  NodeOpFixedSqrtINTEL &operator=(NodeOpFixedSqrtINTEL &&) = delete;
  NodeOpFixedSqrtINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_type,
    NodePointer<NodeId> input, LiteralInteger s, LiteralInteger i, LiteralInteger r_i, LiteralInteger q, LiteralInteger o)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputType = input_type;
    this->input = input;
    this->s = s;
    this->i = i;
    this->rI = r_i;
    this->q = q;
    this->o = o;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIAdd
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIAdd() = default;
  ~NodeOpIAdd() = default;
  NodeOpIAdd(const NodeOpIAdd &) = delete;
  NodeOpIAdd &operator=(const NodeOpIAdd &) = delete;
  NodeOpIAdd(NodeOpIAdd &&) = delete;
  NodeOpIAdd &operator=(NodeOpIAdd &&) = delete;
  NodeOpIAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIAddCarry
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIAddCarry;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIAddCarry() = default;
  ~NodeOpIAddCarry() = default;
  NodeOpIAddCarry(const NodeOpIAddCarry &) = delete;
  NodeOpIAddCarry &operator=(const NodeOpIAddCarry &) = delete;
  NodeOpIAddCarry(NodeOpIAddCarry &&) = delete;
  NodeOpIAddCarry &operator=(NodeOpIAddCarry &&) = delete;
  NodeOpIAddCarry(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIAddSatINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIAddSatINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIAddSatINTEL() = default;
  ~NodeOpIAddSatINTEL() = default;
  NodeOpIAddSatINTEL(const NodeOpIAddSatINTEL &) = delete;
  NodeOpIAddSatINTEL &operator=(const NodeOpIAddSatINTEL &) = delete;
  NodeOpIAddSatINTEL(NodeOpIAddSatINTEL &&) = delete;
  NodeOpIAddSatINTEL &operator=(NodeOpIAddSatINTEL &&) = delete;
  NodeOpIAddSatINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIAverageINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIAverageINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIAverageINTEL() = default;
  ~NodeOpIAverageINTEL() = default;
  NodeOpIAverageINTEL(const NodeOpIAverageINTEL &) = delete;
  NodeOpIAverageINTEL &operator=(const NodeOpIAverageINTEL &) = delete;
  NodeOpIAverageINTEL(NodeOpIAverageINTEL &&) = delete;
  NodeOpIAverageINTEL &operator=(NodeOpIAverageINTEL &&) = delete;
  NodeOpIAverageINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIAverageRoundedINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIAverageRoundedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIAverageRoundedINTEL() = default;
  ~NodeOpIAverageRoundedINTEL() = default;
  NodeOpIAverageRoundedINTEL(const NodeOpIAverageRoundedINTEL &) = delete;
  NodeOpIAverageRoundedINTEL &operator=(const NodeOpIAverageRoundedINTEL &) = delete;
  NodeOpIAverageRoundedINTEL(NodeOpIAverageRoundedINTEL &&) = delete;
  NodeOpIAverageRoundedINTEL &operator=(NodeOpIAverageRoundedINTEL &&) = delete;
  NodeOpIAverageRoundedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIEqual() = default;
  ~NodeOpIEqual() = default;
  NodeOpIEqual(const NodeOpIEqual &) = delete;
  NodeOpIEqual &operator=(const NodeOpIEqual &) = delete;
  NodeOpIEqual(NodeOpIEqual &&) = delete;
  NodeOpIEqual &operator=(NodeOpIEqual &&) = delete;
  NodeOpIEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIMul
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIMul;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIMul() = default;
  ~NodeOpIMul() = default;
  NodeOpIMul(const NodeOpIMul &) = delete;
  NodeOpIMul &operator=(const NodeOpIMul &) = delete;
  NodeOpIMul(NodeOpIMul &&) = delete;
  NodeOpIMul &operator=(NodeOpIMul &&) = delete;
  NodeOpIMul(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIMul32x16INTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpIMul32x16INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpIMul32x16INTEL() = default;
  ~NodeOpIMul32x16INTEL() = default;
  NodeOpIMul32x16INTEL(const NodeOpIMul32x16INTEL &) = delete;
  NodeOpIMul32x16INTEL &operator=(const NodeOpIMul32x16INTEL &) = delete;
  NodeOpIMul32x16INTEL(NodeOpIMul32x16INTEL &&) = delete;
  NodeOpIMul32x16INTEL &operator=(NodeOpIMul32x16INTEL &&) = delete;
  NodeOpIMul32x16INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpINotEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpINotEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpINotEqual() = default;
  ~NodeOpINotEqual() = default;
  NodeOpINotEqual(const NodeOpINotEqual &) = delete;
  NodeOpINotEqual &operator=(const NodeOpINotEqual &) = delete;
  NodeOpINotEqual(NodeOpINotEqual &&) = delete;
  NodeOpINotEqual &operator=(NodeOpINotEqual &&) = delete;
  NodeOpINotEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpISub
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpISub;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpISub() = default;
  ~NodeOpISub() = default;
  NodeOpISub(const NodeOpISub &) = delete;
  NodeOpISub &operator=(const NodeOpISub &) = delete;
  NodeOpISub(NodeOpISub &&) = delete;
  NodeOpISub &operator=(NodeOpISub &&) = delete;
  NodeOpISub(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpISubBorrow
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpISubBorrow;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpISubBorrow() = default;
  ~NodeOpISubBorrow() = default;
  NodeOpISubBorrow(const NodeOpISubBorrow &) = delete;
  NodeOpISubBorrow &operator=(const NodeOpISubBorrow &) = delete;
  NodeOpISubBorrow(NodeOpISubBorrow &&) = delete;
  NodeOpISubBorrow &operator=(NodeOpISubBorrow &&) = delete;
  NodeOpISubBorrow(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpISubSatINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpISubSatINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpISubSatINTEL() = default;
  ~NodeOpISubSatINTEL() = default;
  NodeOpISubSatINTEL(const NodeOpISubSatINTEL &) = delete;
  NodeOpISubSatINTEL &operator=(const NodeOpISubSatINTEL &) = delete;
  NodeOpISubSatINTEL(NodeOpISubSatINTEL &&) = delete;
  NodeOpISubSatINTEL &operator=(NodeOpISubSatINTEL &&) = delete;
  NodeOpISubSatINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLessOrGreater
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpLessOrGreater;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpLessOrGreater() = default;
  ~NodeOpLessOrGreater() = default;
  NodeOpLessOrGreater(const NodeOpLessOrGreater &) = delete;
  NodeOpLessOrGreater &operator=(const NodeOpLessOrGreater &) = delete;
  NodeOpLessOrGreater(NodeOpLessOrGreater &&) = delete;
  NodeOpLessOrGreater &operator=(NodeOpLessOrGreater &&) = delete;
  NodeOpLessOrGreater(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLogicalAnd
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpLogicalAnd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpLogicalAnd() = default;
  ~NodeOpLogicalAnd() = default;
  NodeOpLogicalAnd(const NodeOpLogicalAnd &) = delete;
  NodeOpLogicalAnd &operator=(const NodeOpLogicalAnd &) = delete;
  NodeOpLogicalAnd(NodeOpLogicalAnd &&) = delete;
  NodeOpLogicalAnd &operator=(NodeOpLogicalAnd &&) = delete;
  NodeOpLogicalAnd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLogicalEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpLogicalEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpLogicalEqual() = default;
  ~NodeOpLogicalEqual() = default;
  NodeOpLogicalEqual(const NodeOpLogicalEqual &) = delete;
  NodeOpLogicalEqual &operator=(const NodeOpLogicalEqual &) = delete;
  NodeOpLogicalEqual(NodeOpLogicalEqual &&) = delete;
  NodeOpLogicalEqual &operator=(NodeOpLogicalEqual &&) = delete;
  NodeOpLogicalEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLogicalNotEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpLogicalNotEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpLogicalNotEqual() = default;
  ~NodeOpLogicalNotEqual() = default;
  NodeOpLogicalNotEqual(const NodeOpLogicalNotEqual &) = delete;
  NodeOpLogicalNotEqual &operator=(const NodeOpLogicalNotEqual &) = delete;
  NodeOpLogicalNotEqual(NodeOpLogicalNotEqual &&) = delete;
  NodeOpLogicalNotEqual &operator=(NodeOpLogicalNotEqual &&) = delete;
  NodeOpLogicalNotEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLogicalOr
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpLogicalOr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpLogicalOr() = default;
  ~NodeOpLogicalOr() = default;
  NodeOpLogicalOr(const NodeOpLogicalOr &) = delete;
  NodeOpLogicalOr &operator=(const NodeOpLogicalOr &) = delete;
  NodeOpLogicalOr(NodeOpLogicalOr &&) = delete;
  NodeOpLogicalOr &operator=(NodeOpLogicalOr &&) = delete;
  NodeOpLogicalOr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMatrixTimesMatrix
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpMatrixTimesMatrix;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> leftMatrix;
  NodePointer<NodeId> rightMatrix;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(leftMatrix);
    visitor(rightMatrix);
  }
  NodeOpMatrixTimesMatrix() = default;
  ~NodeOpMatrixTimesMatrix() = default;
  NodeOpMatrixTimesMatrix(const NodeOpMatrixTimesMatrix &) = delete;
  NodeOpMatrixTimesMatrix &operator=(const NodeOpMatrixTimesMatrix &) = delete;
  NodeOpMatrixTimesMatrix(NodeOpMatrixTimesMatrix &&) = delete;
  NodeOpMatrixTimesMatrix &operator=(NodeOpMatrixTimesMatrix &&) = delete;
  NodeOpMatrixTimesMatrix(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> left_matrix,
    NodePointer<NodeId> right_matrix)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->leftMatrix = left_matrix;
    this->rightMatrix = right_matrix;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMatrixTimesScalar
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpMatrixTimesScalar;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> matrix;
  NodePointer<NodeId> scalar;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(matrix);
    visitor(scalar);
  }
  NodeOpMatrixTimesScalar() = default;
  ~NodeOpMatrixTimesScalar() = default;
  NodeOpMatrixTimesScalar(const NodeOpMatrixTimesScalar &) = delete;
  NodeOpMatrixTimesScalar &operator=(const NodeOpMatrixTimesScalar &) = delete;
  NodeOpMatrixTimesScalar(NodeOpMatrixTimesScalar &&) = delete;
  NodeOpMatrixTimesScalar &operator=(NodeOpMatrixTimesScalar &&) = delete;
  NodeOpMatrixTimesScalar(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> matrix,
    NodePointer<NodeId> scalar)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->matrix = matrix;
    this->scalar = scalar;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMatrixTimesVector
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpMatrixTimesVector;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> matrix;
  NodePointer<NodeId> vector;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(matrix);
    visitor(vector);
  }
  NodeOpMatrixTimesVector() = default;
  ~NodeOpMatrixTimesVector() = default;
  NodeOpMatrixTimesVector(const NodeOpMatrixTimesVector &) = delete;
  NodeOpMatrixTimesVector &operator=(const NodeOpMatrixTimesVector &) = delete;
  NodeOpMatrixTimesVector(NodeOpMatrixTimesVector &&) = delete;
  NodeOpMatrixTimesVector &operator=(NodeOpMatrixTimesVector &&) = delete;
  NodeOpMatrixTimesVector(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> matrix,
    NodePointer<NodeId> vector)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->matrix = matrix;
    this->vector = vector;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpOrdered
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpOrdered;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpOrdered() = default;
  ~NodeOpOrdered() = default;
  NodeOpOrdered(const NodeOpOrdered &) = delete;
  NodeOpOrdered &operator=(const NodeOpOrdered &) = delete;
  NodeOpOrdered(NodeOpOrdered &&) = delete;
  NodeOpOrdered &operator=(NodeOpOrdered &&) = delete;
  NodeOpOrdered(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpOuterProduct
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpOuterProduct;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpOuterProduct() = default;
  ~NodeOpOuterProduct() = default;
  NodeOpOuterProduct(const NodeOpOuterProduct &) = delete;
  NodeOpOuterProduct &operator=(const NodeOpOuterProduct &) = delete;
  NodeOpOuterProduct(NodeOpOuterProduct &&) = delete;
  NodeOpOuterProduct &operator=(NodeOpOuterProduct &&) = delete;
  NodeOpOuterProduct(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrDiff
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpPtrDiff;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpPtrDiff() = default;
  ~NodeOpPtrDiff() = default;
  NodeOpPtrDiff(const NodeOpPtrDiff &) = delete;
  NodeOpPtrDiff &operator=(const NodeOpPtrDiff &) = delete;
  NodeOpPtrDiff(NodeOpPtrDiff &&) = delete;
  NodeOpPtrDiff &operator=(NodeOpPtrDiff &&) = delete;
  NodeOpPtrDiff(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpPtrEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpPtrEqual() = default;
  ~NodeOpPtrEqual() = default;
  NodeOpPtrEqual(const NodeOpPtrEqual &) = delete;
  NodeOpPtrEqual &operator=(const NodeOpPtrEqual &) = delete;
  NodeOpPtrEqual(NodeOpPtrEqual &&) = delete;
  NodeOpPtrEqual &operator=(NodeOpPtrEqual &&) = delete;
  NodeOpPtrEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrNotEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpPtrNotEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpPtrNotEqual() = default;
  ~NodeOpPtrNotEqual() = default;
  NodeOpPtrNotEqual(const NodeOpPtrNotEqual &) = delete;
  NodeOpPtrNotEqual &operator=(const NodeOpPtrNotEqual &) = delete;
  NodeOpPtrNotEqual(NodeOpPtrNotEqual &&) = delete;
  NodeOpPtrNotEqual &operator=(NodeOpPtrNotEqual &&) = delete;
  NodeOpPtrNotEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionBarycentricsKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionBarycentricsKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionBarycentricsKHR() = default;
  ~NodeOpRayQueryGetIntersectionBarycentricsKHR() = default;
  NodeOpRayQueryGetIntersectionBarycentricsKHR(const NodeOpRayQueryGetIntersectionBarycentricsKHR &) = delete;
  NodeOpRayQueryGetIntersectionBarycentricsKHR &operator=(const NodeOpRayQueryGetIntersectionBarycentricsKHR &) = delete;
  NodeOpRayQueryGetIntersectionBarycentricsKHR(NodeOpRayQueryGetIntersectionBarycentricsKHR &&) = delete;
  NodeOpRayQueryGetIntersectionBarycentricsKHR &operator=(NodeOpRayQueryGetIntersectionBarycentricsKHR &&) = delete;
  NodeOpRayQueryGetIntersectionBarycentricsKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionFrontFaceKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionFrontFaceKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionFrontFaceKHR() = default;
  ~NodeOpRayQueryGetIntersectionFrontFaceKHR() = default;
  NodeOpRayQueryGetIntersectionFrontFaceKHR(const NodeOpRayQueryGetIntersectionFrontFaceKHR &) = delete;
  NodeOpRayQueryGetIntersectionFrontFaceKHR &operator=(const NodeOpRayQueryGetIntersectionFrontFaceKHR &) = delete;
  NodeOpRayQueryGetIntersectionFrontFaceKHR(NodeOpRayQueryGetIntersectionFrontFaceKHR &&) = delete;
  NodeOpRayQueryGetIntersectionFrontFaceKHR &operator=(NodeOpRayQueryGetIntersectionFrontFaceKHR &&) = delete;
  NodeOpRayQueryGetIntersectionFrontFaceKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionGeometryIndexKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionGeometryIndexKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionGeometryIndexKHR() = default;
  ~NodeOpRayQueryGetIntersectionGeometryIndexKHR() = default;
  NodeOpRayQueryGetIntersectionGeometryIndexKHR(const NodeOpRayQueryGetIntersectionGeometryIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionGeometryIndexKHR &operator=(const NodeOpRayQueryGetIntersectionGeometryIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionGeometryIndexKHR(NodeOpRayQueryGetIntersectionGeometryIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionGeometryIndexKHR &operator=(NodeOpRayQueryGetIntersectionGeometryIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionGeometryIndexKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionInstanceCustomIndexKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR() = default;
  ~NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR() = default;
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR(const NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &operator=(const NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR(NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &operator=(NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> ray_query, NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionInstanceIdKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionInstanceIdKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionInstanceIdKHR() = default;
  ~NodeOpRayQueryGetIntersectionInstanceIdKHR() = default;
  NodeOpRayQueryGetIntersectionInstanceIdKHR(const NodeOpRayQueryGetIntersectionInstanceIdKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceIdKHR &operator=(const NodeOpRayQueryGetIntersectionInstanceIdKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceIdKHR(NodeOpRayQueryGetIntersectionInstanceIdKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceIdKHR &operator=(NodeOpRayQueryGetIntersectionInstanceIdKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceIdKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR() = default;
  ~NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR() = default;
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(
    const NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &operator=(
    const NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &) = delete;
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(
    NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &operator=(
    NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR &&) = delete;
  NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> ray_query, NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionObjectRayDirectionKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionObjectRayDirectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR() = default;
  ~NodeOpRayQueryGetIntersectionObjectRayDirectionKHR() = default;
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR(const NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &operator=(const NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR(NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &operator=(NodeOpRayQueryGetIntersectionObjectRayDirectionKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectRayDirectionKHR(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> ray_query, NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionObjectRayOriginKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionObjectRayOriginKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR() = default;
  ~NodeOpRayQueryGetIntersectionObjectRayOriginKHR() = default;
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR(const NodeOpRayQueryGetIntersectionObjectRayOriginKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR &operator=(const NodeOpRayQueryGetIntersectionObjectRayOriginKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR(NodeOpRayQueryGetIntersectionObjectRayOriginKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR &operator=(NodeOpRayQueryGetIntersectionObjectRayOriginKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectRayOriginKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionObjectToWorldKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionObjectToWorldKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionObjectToWorldKHR() = default;
  ~NodeOpRayQueryGetIntersectionObjectToWorldKHR() = default;
  NodeOpRayQueryGetIntersectionObjectToWorldKHR(const NodeOpRayQueryGetIntersectionObjectToWorldKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectToWorldKHR &operator=(const NodeOpRayQueryGetIntersectionObjectToWorldKHR &) = delete;
  NodeOpRayQueryGetIntersectionObjectToWorldKHR(NodeOpRayQueryGetIntersectionObjectToWorldKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectToWorldKHR &operator=(NodeOpRayQueryGetIntersectionObjectToWorldKHR &&) = delete;
  NodeOpRayQueryGetIntersectionObjectToWorldKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionPrimitiveIndexKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionPrimitiveIndexKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR() = default;
  ~NodeOpRayQueryGetIntersectionPrimitiveIndexKHR() = default;
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR(const NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &operator=(const NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &) = delete;
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR(NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &operator=(NodeOpRayQueryGetIntersectionPrimitiveIndexKHR &&) = delete;
  NodeOpRayQueryGetIntersectionPrimitiveIndexKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionTKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionTKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionTKHR() = default;
  ~NodeOpRayQueryGetIntersectionTKHR() = default;
  NodeOpRayQueryGetIntersectionTKHR(const NodeOpRayQueryGetIntersectionTKHR &) = delete;
  NodeOpRayQueryGetIntersectionTKHR &operator=(const NodeOpRayQueryGetIntersectionTKHR &) = delete;
  NodeOpRayQueryGetIntersectionTKHR(NodeOpRayQueryGetIntersectionTKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTKHR &operator=(NodeOpRayQueryGetIntersectionTKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionTriangleVertexPositionsKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR() = default;
  ~NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR() = default;
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR(const NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &) = delete;
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &operator=(
    const NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &) = delete;
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR(NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &operator=(
    NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> ray_query, NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionTypeKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionTypeKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionTypeKHR() = default;
  ~NodeOpRayQueryGetIntersectionTypeKHR() = default;
  NodeOpRayQueryGetIntersectionTypeKHR(const NodeOpRayQueryGetIntersectionTypeKHR &) = delete;
  NodeOpRayQueryGetIntersectionTypeKHR &operator=(const NodeOpRayQueryGetIntersectionTypeKHR &) = delete;
  NodeOpRayQueryGetIntersectionTypeKHR(NodeOpRayQueryGetIntersectionTypeKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTypeKHR &operator=(NodeOpRayQueryGetIntersectionTypeKHR &&) = delete;
  NodeOpRayQueryGetIntersectionTypeKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionWorldToObjectKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionWorldToObjectKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  NodePointer<NodeId> intersection;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
    visitor(intersection);
  }
  NodeOpRayQueryGetIntersectionWorldToObjectKHR() = default;
  ~NodeOpRayQueryGetIntersectionWorldToObjectKHR() = default;
  NodeOpRayQueryGetIntersectionWorldToObjectKHR(const NodeOpRayQueryGetIntersectionWorldToObjectKHR &) = delete;
  NodeOpRayQueryGetIntersectionWorldToObjectKHR &operator=(const NodeOpRayQueryGetIntersectionWorldToObjectKHR &) = delete;
  NodeOpRayQueryGetIntersectionWorldToObjectKHR(NodeOpRayQueryGetIntersectionWorldToObjectKHR &&) = delete;
  NodeOpRayQueryGetIntersectionWorldToObjectKHR &operator=(NodeOpRayQueryGetIntersectionWorldToObjectKHR &&) = delete;
  NodeOpRayQueryGetIntersectionWorldToObjectKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query,
    NodePointer<NodeId> intersection)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
    this->intersection = intersection;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReadPipeBlockingINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpReadPipeBlockingINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReadPipeBlockingINTEL() = default;
  ~NodeOpReadPipeBlockingINTEL() = default;
  NodeOpReadPipeBlockingINTEL(const NodeOpReadPipeBlockingINTEL &) = delete;
  NodeOpReadPipeBlockingINTEL &operator=(const NodeOpReadPipeBlockingINTEL &) = delete;
  NodeOpReadPipeBlockingINTEL(NodeOpReadPipeBlockingINTEL &&) = delete;
  NodeOpReadPipeBlockingINTEL &operator=(NodeOpReadPipeBlockingINTEL &&) = delete;
  NodeOpReadPipeBlockingINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReportIntersectionKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpReportIntersectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hit;
  NodePointer<NodeId> hitKind;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hit);
    visitor(hitKind);
  }
  NodeOpReportIntersectionKHR() = default;
  ~NodeOpReportIntersectionKHR() = default;
  NodeOpReportIntersectionKHR(const NodeOpReportIntersectionKHR &) = delete;
  NodeOpReportIntersectionKHR &operator=(const NodeOpReportIntersectionKHR &) = delete;
  NodeOpReportIntersectionKHR(NodeOpReportIntersectionKHR &&) = delete;
  NodeOpReportIntersectionKHR &operator=(NodeOpReportIntersectionKHR &&) = delete;
  NodeOpReportIntersectionKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit,
    NodePointer<NodeId> hit_kind)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hit = hit;
    this->hitKind = hit_kind;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReportIntersectionNV
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpReportIntersectionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hit;
  NodePointer<NodeId> hitKind;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hit);
    visitor(hitKind);
  }
  NodeOpReportIntersectionNV() = default;
  ~NodeOpReportIntersectionNV() = default;
  NodeOpReportIntersectionNV(const NodeOpReportIntersectionNV &) = delete;
  NodeOpReportIntersectionNV &operator=(const NodeOpReportIntersectionNV &) = delete;
  NodeOpReportIntersectionNV(NodeOpReportIntersectionNV &&) = delete;
  NodeOpReportIntersectionNV &operator=(NodeOpReportIntersectionNV &&) = delete;
  NodeOpReportIntersectionNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit,
    NodePointer<NodeId> hit_kind)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hit = hit;
    this->hitKind = hit_kind;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSDiv
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSDiv;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSDiv() = default;
  ~NodeOpSDiv() = default;
  NodeOpSDiv(const NodeOpSDiv &) = delete;
  NodeOpSDiv &operator=(const NodeOpSDiv &) = delete;
  NodeOpSDiv(NodeOpSDiv &&) = delete;
  NodeOpSDiv &operator=(NodeOpSDiv &&) = delete;
  NodeOpSDiv(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSDot
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSDot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpSDot() = default;
  ~NodeOpSDot() = default;
  NodeOpSDot(const NodeOpSDot &) = delete;
  NodeOpSDot &operator=(const NodeOpSDot &) = delete;
  NodeOpSDot(NodeOpSDot &&) = delete;
  NodeOpSDot &operator=(NodeOpSDot &&) = delete;
  NodeOpSDot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSDotKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSDotKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpSDotKHR() = default;
  ~NodeOpSDotKHR() = default;
  NodeOpSDotKHR(const NodeOpSDotKHR &) = delete;
  NodeOpSDotKHR &operator=(const NodeOpSDotKHR &) = delete;
  NodeOpSDotKHR(NodeOpSDotKHR &&) = delete;
  NodeOpSDotKHR &operator=(NodeOpSDotKHR &&) = delete;
  NodeOpSDotKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSGreaterThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSGreaterThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSGreaterThan() = default;
  ~NodeOpSGreaterThan() = default;
  NodeOpSGreaterThan(const NodeOpSGreaterThan &) = delete;
  NodeOpSGreaterThan &operator=(const NodeOpSGreaterThan &) = delete;
  NodeOpSGreaterThan(NodeOpSGreaterThan &&) = delete;
  NodeOpSGreaterThan &operator=(NodeOpSGreaterThan &&) = delete;
  NodeOpSGreaterThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSGreaterThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSGreaterThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSGreaterThanEqual() = default;
  ~NodeOpSGreaterThanEqual() = default;
  NodeOpSGreaterThanEqual(const NodeOpSGreaterThanEqual &) = delete;
  NodeOpSGreaterThanEqual &operator=(const NodeOpSGreaterThanEqual &) = delete;
  NodeOpSGreaterThanEqual(NodeOpSGreaterThanEqual &&) = delete;
  NodeOpSGreaterThanEqual &operator=(NodeOpSGreaterThanEqual &&) = delete;
  NodeOpSGreaterThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSLessThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSLessThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSLessThan() = default;
  ~NodeOpSLessThan() = default;
  NodeOpSLessThan(const NodeOpSLessThan &) = delete;
  NodeOpSLessThan &operator=(const NodeOpSLessThan &) = delete;
  NodeOpSLessThan(NodeOpSLessThan &&) = delete;
  NodeOpSLessThan &operator=(NodeOpSLessThan &&) = delete;
  NodeOpSLessThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSLessThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSLessThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSLessThanEqual() = default;
  ~NodeOpSLessThanEqual() = default;
  NodeOpSLessThanEqual(const NodeOpSLessThanEqual &) = delete;
  NodeOpSLessThanEqual &operator=(const NodeOpSLessThanEqual &) = delete;
  NodeOpSLessThanEqual(NodeOpSLessThanEqual &&) = delete;
  NodeOpSLessThanEqual &operator=(NodeOpSLessThanEqual &&) = delete;
  NodeOpSLessThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSMod
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSMod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSMod() = default;
  ~NodeOpSMod() = default;
  NodeOpSMod(const NodeOpSMod &) = delete;
  NodeOpSMod &operator=(const NodeOpSMod &) = delete;
  NodeOpSMod(NodeOpSMod &&) = delete;
  NodeOpSMod &operator=(NodeOpSMod &&) = delete;
  NodeOpSMod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSMulExtended
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSMulExtended;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSMulExtended() = default;
  ~NodeOpSMulExtended() = default;
  NodeOpSMulExtended(const NodeOpSMulExtended &) = delete;
  NodeOpSMulExtended &operator=(const NodeOpSMulExtended &) = delete;
  NodeOpSMulExtended(NodeOpSMulExtended &&) = delete;
  NodeOpSMulExtended &operator=(NodeOpSMulExtended &&) = delete;
  NodeOpSMulExtended(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSRem
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSRem;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpSRem() = default;
  ~NodeOpSRem() = default;
  NodeOpSRem(const NodeOpSRem &) = delete;
  NodeOpSRem &operator=(const NodeOpSRem &) = delete;
  NodeOpSRem(NodeOpSRem &&) = delete;
  NodeOpSRem &operator=(NodeOpSRem &&) = delete;
  NodeOpSRem(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSUDot
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSUDot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpSUDot() = default;
  ~NodeOpSUDot() = default;
  NodeOpSUDot(const NodeOpSUDot &) = delete;
  NodeOpSUDot &operator=(const NodeOpSUDot &) = delete;
  NodeOpSUDot(NodeOpSUDot &&) = delete;
  NodeOpSUDot &operator=(NodeOpSUDot &&) = delete;
  NodeOpSUDot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSUDotKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSUDotKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpSUDotKHR() = default;
  ~NodeOpSUDotKHR() = default;
  NodeOpSUDotKHR(const NodeOpSUDotKHR &) = delete;
  NodeOpSUDotKHR &operator=(const NodeOpSUDotKHR &) = delete;
  NodeOpSUDotKHR(NodeOpSUDotKHR &&) = delete;
  NodeOpSUDotKHR &operator=(NodeOpSUDotKHR &&) = delete;
  NodeOpSUDotKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpShiftLeftLogical
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpShiftLeftLogical;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> shift;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(shift);
  }
  NodeOpShiftLeftLogical() = default;
  ~NodeOpShiftLeftLogical() = default;
  NodeOpShiftLeftLogical(const NodeOpShiftLeftLogical &) = delete;
  NodeOpShiftLeftLogical &operator=(const NodeOpShiftLeftLogical &) = delete;
  NodeOpShiftLeftLogical(NodeOpShiftLeftLogical &&) = delete;
  NodeOpShiftLeftLogical &operator=(NodeOpShiftLeftLogical &&) = delete;
  NodeOpShiftLeftLogical(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> shift)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->shift = shift;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpShiftRightArithmetic
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpShiftRightArithmetic;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> shift;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(shift);
  }
  NodeOpShiftRightArithmetic() = default;
  ~NodeOpShiftRightArithmetic() = default;
  NodeOpShiftRightArithmetic(const NodeOpShiftRightArithmetic &) = delete;
  NodeOpShiftRightArithmetic &operator=(const NodeOpShiftRightArithmetic &) = delete;
  NodeOpShiftRightArithmetic(NodeOpShiftRightArithmetic &&) = delete;
  NodeOpShiftRightArithmetic &operator=(NodeOpShiftRightArithmetic &&) = delete;
  NodeOpShiftRightArithmetic(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base,
    NodePointer<NodeId> shift)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->shift = shift;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpShiftRightLogical
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpShiftRightLogical;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> shift;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(shift);
  }
  NodeOpShiftRightLogical() = default;
  ~NodeOpShiftRightLogical() = default;
  NodeOpShiftRightLogical(const NodeOpShiftRightLogical &) = delete;
  NodeOpShiftRightLogical &operator=(const NodeOpShiftRightLogical &) = delete;
  NodeOpShiftRightLogical(NodeOpShiftRightLogical &&) = delete;
  NodeOpShiftRightLogical &operator=(NodeOpShiftRightLogical &&) = delete;
  NodeOpShiftRightLogical(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> shift)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->shift = shift;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetBorderReachedINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetBorderReachedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> imageSelect;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(imageSelect);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetBorderReachedINTEL() = default;
  ~NodeOpSubgroupAvcImeGetBorderReachedINTEL() = default;
  NodeOpSubgroupAvcImeGetBorderReachedINTEL(const NodeOpSubgroupAvcImeGetBorderReachedINTEL &) = delete;
  NodeOpSubgroupAvcImeGetBorderReachedINTEL &operator=(const NodeOpSubgroupAvcImeGetBorderReachedINTEL &) = delete;
  NodeOpSubgroupAvcImeGetBorderReachedINTEL(NodeOpSubgroupAvcImeGetBorderReachedINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetBorderReachedINTEL &operator=(NodeOpSubgroupAvcImeGetBorderReachedINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetBorderReachedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image_select,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->imageSelect = image_select;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
  }
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
  }
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
  }
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeRefWindowSizeINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeRefWindowSizeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> searchWindowConfig;
  NodePointer<NodeId> dualRef;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(searchWindowConfig);
    visitor(dualRef);
  }
  NodeOpSubgroupAvcImeRefWindowSizeINTEL() = default;
  ~NodeOpSubgroupAvcImeRefWindowSizeINTEL() = default;
  NodeOpSubgroupAvcImeRefWindowSizeINTEL(const NodeOpSubgroupAvcImeRefWindowSizeINTEL &) = delete;
  NodeOpSubgroupAvcImeRefWindowSizeINTEL &operator=(const NodeOpSubgroupAvcImeRefWindowSizeINTEL &) = delete;
  NodeOpSubgroupAvcImeRefWindowSizeINTEL(NodeOpSubgroupAvcImeRefWindowSizeINTEL &&) = delete;
  NodeOpSubgroupAvcImeRefWindowSizeINTEL &operator=(NodeOpSubgroupAvcImeRefWindowSizeINTEL &&) = delete;
  NodeOpSubgroupAvcImeRefWindowSizeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> search_window_config, NodePointer<NodeId> dual_ref)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->searchWindowConfig = search_window_config;
    this->dualRef = dual_ref;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> threshold;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(threshold);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL() = default;
  ~NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL() = default;
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(
    const NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &) = delete;
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &operator=(
    const NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &) = delete;
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &operator=(
    NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> threshold, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->threshold = threshold;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetMaxMotionVectorCountINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> maxMotionVectorCount;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(maxMotionVectorCount);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL() = default;
  ~NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL() = default;
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL(const NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &) = delete;
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &operator=(const NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &) = delete;
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL(NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &operator=(NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> max_motion_vector_count, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->maxMotionVectorCount = max_motion_vector_count;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetWeightedSadINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetWeightedSadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packedSadWeights;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedSadWeights);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetWeightedSadINTEL() = default;
  ~NodeOpSubgroupAvcImeSetWeightedSadINTEL() = default;
  NodeOpSubgroupAvcImeSetWeightedSadINTEL(const NodeOpSubgroupAvcImeSetWeightedSadINTEL &) = delete;
  NodeOpSubgroupAvcImeSetWeightedSadINTEL &operator=(const NodeOpSubgroupAvcImeSetWeightedSadINTEL &) = delete;
  NodeOpSubgroupAvcImeSetWeightedSadINTEL(NodeOpSubgroupAvcImeSetWeightedSadINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetWeightedSadINTEL &operator=(NodeOpSubgroupAvcImeSetWeightedSadINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetWeightedSadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_sad_weights, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedSadWeights = packed_sad_weights;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(
    const NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(
    NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(const NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(
    const NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(
    NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(const NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &operator=(NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(const NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sliceType;
  NodePointer<NodeId> qp;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sliceType);
    visitor(qp);
  }
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(const NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> slice_type, NodePointer<NodeId> qp)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sliceType = slice_type;
    this->qp = qp;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> referenceBasePenalty;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(referenceBasePenalty);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(
    const NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &operator=(
    const NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &operator=(
    NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> reference_base_penalty, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->referenceBasePenalty = reference_base_penalty;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetInterDirectionPenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> directionCost;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(directionCost);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL() = default;
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL(const NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &operator=(const NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL(NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &operator=(NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> direction_cost, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->directionCost = direction_cost;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetInterShapePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packedShapePenalty;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedShapePenalty);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL() = default;
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL(const NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &operator=(const NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL(NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &operator=(NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_shape_penalty, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedShapePenalty = packed_shape_penalty;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> referenceFieldPolarity;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(referenceFieldPolarity);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL() = default;
  ~NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL() = default;
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(
    const NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &) = delete;
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &operator=(
    const NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &) = delete;
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(
    NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &operator=(
    NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> reference_field_polarity, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->referenceFieldPolarity = reference_field_polarity;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sourceFieldPolarity;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sourceFieldPolarity);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL() = default;
  ~NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL() = default;
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(
    const NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &) = delete;
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &operator=(
    const NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &) = delete;
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &operator=(
    NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> source_field_polarity, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sourceFieldPolarity = source_field_polarity;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicEvaluateIpeINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicEvaluateIpeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicEvaluateIpeINTEL() = default;
  ~NodeOpSubgroupAvcSicEvaluateIpeINTEL() = default;
  NodeOpSubgroupAvcSicEvaluateIpeINTEL(const NodeOpSubgroupAvcSicEvaluateIpeINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateIpeINTEL &operator=(const NodeOpSubgroupAvcSicEvaluateIpeINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateIpeINTEL(NodeOpSubgroupAvcSicEvaluateIpeINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateIpeINTEL &operator=(NodeOpSubgroupAvcSicEvaluateIpeINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateIpeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> src_image,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetMotionVectorMaskINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> skipBlockPartitionType;
  NodePointer<NodeId> direction;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(skipBlockPartitionType);
    visitor(direction);
  }
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL() = default;
  ~NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL() = default;
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL(const NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &) = delete;
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &operator=(const NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &) = delete;
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL(NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &operator=(NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> skip_block_partition_type, NodePointer<NodeId> direction)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->skipBlockPartitionType = skip_block_partition_type;
    this->direction = direction;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> blockBasedSkipType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(blockBasedSkipType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL() = default;
  ~NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL() = default;
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(const NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &) = delete;
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &operator=(const NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &) = delete;
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &operator=(NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> block_based_skip_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->blockBasedSkipType = block_based_skip_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> chromaModeBasePenalty;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(chromaModeBasePenalty);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL() = default;
  ~NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL() = default;
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(const NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &operator=(
    const NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &operator=(
    NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> chroma_mode_base_penalty, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->chromaModeBasePenalty = chroma_mode_base_penalty;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packedShapePenalty;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedShapePenalty);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL() = default;
  ~NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL() = default;
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(const NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &operator=(const NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &operator=(NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_shape_penalty, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedShapePenalty = packed_shape_penalty;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packedSadCoefficients;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedSadCoefficients);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL() = default;
  ~NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL() = default;
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(const NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &) = delete;
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &operator=(
    const NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &) = delete;
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &operator=(NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_sad_coefficients, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedSadCoefficients = packed_sad_coefficients;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupReadInvocationKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupReadInvocationKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  NodePointer<NodeId> index;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
    visitor(index);
  }
  NodeOpSubgroupReadInvocationKHR() = default;
  ~NodeOpSubgroupReadInvocationKHR() = default;
  NodeOpSubgroupReadInvocationKHR(const NodeOpSubgroupReadInvocationKHR &) = delete;
  NodeOpSubgroupReadInvocationKHR &operator=(const NodeOpSubgroupReadInvocationKHR &) = delete;
  NodeOpSubgroupReadInvocationKHR(NodeOpSubgroupReadInvocationKHR &&) = delete;
  NodeOpSubgroupReadInvocationKHR &operator=(NodeOpSubgroupReadInvocationKHR &&) = delete;
  NodeOpSubgroupReadInvocationKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value,
    NodePointer<NodeId> index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
    this->index = index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupShuffleINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupShuffleINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> data;
  NodePointer<NodeId> invocationId;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(data);
    visitor(invocationId);
  }
  NodeOpSubgroupShuffleINTEL() = default;
  ~NodeOpSubgroupShuffleINTEL() = default;
  NodeOpSubgroupShuffleINTEL(const NodeOpSubgroupShuffleINTEL &) = delete;
  NodeOpSubgroupShuffleINTEL &operator=(const NodeOpSubgroupShuffleINTEL &) = delete;
  NodeOpSubgroupShuffleINTEL(NodeOpSubgroupShuffleINTEL &&) = delete;
  NodeOpSubgroupShuffleINTEL &operator=(NodeOpSubgroupShuffleINTEL &&) = delete;
  NodeOpSubgroupShuffleINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> data,
    NodePointer<NodeId> invocation_id)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->data = data;
    this->invocationId = invocation_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupShuffleXorINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpSubgroupShuffleXorINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> data;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(data);
    visitor(value);
  }
  NodeOpSubgroupShuffleXorINTEL() = default;
  ~NodeOpSubgroupShuffleXorINTEL() = default;
  NodeOpSubgroupShuffleXorINTEL(const NodeOpSubgroupShuffleXorINTEL &) = delete;
  NodeOpSubgroupShuffleXorINTEL &operator=(const NodeOpSubgroupShuffleXorINTEL &) = delete;
  NodeOpSubgroupShuffleXorINTEL(NodeOpSubgroupShuffleXorINTEL &&) = delete;
  NodeOpSubgroupShuffleXorINTEL &operator=(NodeOpSubgroupShuffleXorINTEL &&) = delete;
  NodeOpSubgroupShuffleXorINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> data,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->data = data;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUAddSatINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUAddSatINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUAddSatINTEL() = default;
  ~NodeOpUAddSatINTEL() = default;
  NodeOpUAddSatINTEL(const NodeOpUAddSatINTEL &) = delete;
  NodeOpUAddSatINTEL &operator=(const NodeOpUAddSatINTEL &) = delete;
  NodeOpUAddSatINTEL(NodeOpUAddSatINTEL &&) = delete;
  NodeOpUAddSatINTEL &operator=(NodeOpUAddSatINTEL &&) = delete;
  NodeOpUAddSatINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUAverageINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUAverageINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUAverageINTEL() = default;
  ~NodeOpUAverageINTEL() = default;
  NodeOpUAverageINTEL(const NodeOpUAverageINTEL &) = delete;
  NodeOpUAverageINTEL &operator=(const NodeOpUAverageINTEL &) = delete;
  NodeOpUAverageINTEL(NodeOpUAverageINTEL &&) = delete;
  NodeOpUAverageINTEL &operator=(NodeOpUAverageINTEL &&) = delete;
  NodeOpUAverageINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUAverageRoundedINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUAverageRoundedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUAverageRoundedINTEL() = default;
  ~NodeOpUAverageRoundedINTEL() = default;
  NodeOpUAverageRoundedINTEL(const NodeOpUAverageRoundedINTEL &) = delete;
  NodeOpUAverageRoundedINTEL &operator=(const NodeOpUAverageRoundedINTEL &) = delete;
  NodeOpUAverageRoundedINTEL(NodeOpUAverageRoundedINTEL &&) = delete;
  NodeOpUAverageRoundedINTEL &operator=(NodeOpUAverageRoundedINTEL &&) = delete;
  NodeOpUAverageRoundedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUDiv
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUDiv;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUDiv() = default;
  ~NodeOpUDiv() = default;
  NodeOpUDiv(const NodeOpUDiv &) = delete;
  NodeOpUDiv &operator=(const NodeOpUDiv &) = delete;
  NodeOpUDiv(NodeOpUDiv &&) = delete;
  NodeOpUDiv &operator=(NodeOpUDiv &&) = delete;
  NodeOpUDiv(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUDot
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUDot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpUDot() = default;
  ~NodeOpUDot() = default;
  NodeOpUDot(const NodeOpUDot &) = delete;
  NodeOpUDot &operator=(const NodeOpUDot &) = delete;
  NodeOpUDot(NodeOpUDot &&) = delete;
  NodeOpUDot &operator=(NodeOpUDot &&) = delete;
  NodeOpUDot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUDotKHR
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUDotKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpUDotKHR() = default;
  ~NodeOpUDotKHR() = default;
  NodeOpUDotKHR(const NodeOpUDotKHR &) = delete;
  NodeOpUDotKHR &operator=(const NodeOpUDotKHR &) = delete;
  NodeOpUDotKHR(NodeOpUDotKHR &&) = delete;
  NodeOpUDotKHR &operator=(NodeOpUDotKHR &&) = delete;
  NodeOpUDotKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUGreaterThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUGreaterThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUGreaterThan() = default;
  ~NodeOpUGreaterThan() = default;
  NodeOpUGreaterThan(const NodeOpUGreaterThan &) = delete;
  NodeOpUGreaterThan &operator=(const NodeOpUGreaterThan &) = delete;
  NodeOpUGreaterThan(NodeOpUGreaterThan &&) = delete;
  NodeOpUGreaterThan &operator=(NodeOpUGreaterThan &&) = delete;
  NodeOpUGreaterThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUGreaterThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUGreaterThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUGreaterThanEqual() = default;
  ~NodeOpUGreaterThanEqual() = default;
  NodeOpUGreaterThanEqual(const NodeOpUGreaterThanEqual &) = delete;
  NodeOpUGreaterThanEqual &operator=(const NodeOpUGreaterThanEqual &) = delete;
  NodeOpUGreaterThanEqual(NodeOpUGreaterThanEqual &&) = delete;
  NodeOpUGreaterThanEqual &operator=(NodeOpUGreaterThanEqual &&) = delete;
  NodeOpUGreaterThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpULessThan
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpULessThan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpULessThan() = default;
  ~NodeOpULessThan() = default;
  NodeOpULessThan(const NodeOpULessThan &) = delete;
  NodeOpULessThan &operator=(const NodeOpULessThan &) = delete;
  NodeOpULessThan(NodeOpULessThan &&) = delete;
  NodeOpULessThan &operator=(NodeOpULessThan &&) = delete;
  NodeOpULessThan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpULessThanEqual
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpULessThanEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpULessThanEqual() = default;
  ~NodeOpULessThanEqual() = default;
  NodeOpULessThanEqual(const NodeOpULessThanEqual &) = delete;
  NodeOpULessThanEqual &operator=(const NodeOpULessThanEqual &) = delete;
  NodeOpULessThanEqual(NodeOpULessThanEqual &&) = delete;
  NodeOpULessThanEqual &operator=(NodeOpULessThanEqual &&) = delete;
  NodeOpULessThanEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUMod
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUMod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUMod() = default;
  ~NodeOpUMod() = default;
  NodeOpUMod(const NodeOpUMod &) = delete;
  NodeOpUMod &operator=(const NodeOpUMod &) = delete;
  NodeOpUMod(NodeOpUMod &&) = delete;
  NodeOpUMod &operator=(NodeOpUMod &&) = delete;
  NodeOpUMod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1, NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUMul32x16INTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUMul32x16INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUMul32x16INTEL() = default;
  ~NodeOpUMul32x16INTEL() = default;
  NodeOpUMul32x16INTEL(const NodeOpUMul32x16INTEL &) = delete;
  NodeOpUMul32x16INTEL &operator=(const NodeOpUMul32x16INTEL &) = delete;
  NodeOpUMul32x16INTEL(NodeOpUMul32x16INTEL &&) = delete;
  NodeOpUMul32x16INTEL &operator=(NodeOpUMul32x16INTEL &&) = delete;
  NodeOpUMul32x16INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUMulExtended
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUMulExtended;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUMulExtended() = default;
  ~NodeOpUMulExtended() = default;
  NodeOpUMulExtended(const NodeOpUMulExtended &) = delete;
  NodeOpUMulExtended &operator=(const NodeOpUMulExtended &) = delete;
  NodeOpUMulExtended(NodeOpUMulExtended &&) = delete;
  NodeOpUMulExtended &operator=(NodeOpUMulExtended &&) = delete;
  NodeOpUMulExtended(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUSubSatINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUSubSatINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand1;
  NodePointer<NodeId> operand2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand1);
    visitor(operand2);
  }
  NodeOpUSubSatINTEL() = default;
  ~NodeOpUSubSatINTEL() = default;
  NodeOpUSubSatINTEL(const NodeOpUSubSatINTEL &) = delete;
  NodeOpUSubSatINTEL &operator=(const NodeOpUSubSatINTEL &) = delete;
  NodeOpUSubSatINTEL(NodeOpUSubSatINTEL &&) = delete;
  NodeOpUSubSatINTEL &operator=(NodeOpUSubSatINTEL &&) = delete;
  NodeOpUSubSatINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand_1,
    NodePointer<NodeId> operand_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand1 = operand_1;
    this->operand2 = operand_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUnordered
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpUnordered;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpUnordered() = default;
  ~NodeOpUnordered() = default;
  NodeOpUnordered(const NodeOpUnordered &) = delete;
  NodeOpUnordered &operator=(const NodeOpUnordered &) = delete;
  NodeOpUnordered(NodeOpUnordered &&) = delete;
  NodeOpUnordered &operator=(NodeOpUnordered &&) = delete;
  NodeOpUnordered(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVectorExtractDynamic
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpVectorExtractDynamic;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  NodePointer<NodeId> index;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
    visitor(index);
  }
  NodeOpVectorExtractDynamic() = default;
  ~NodeOpVectorExtractDynamic() = default;
  NodeOpVectorExtractDynamic(const NodeOpVectorExtractDynamic &) = delete;
  NodeOpVectorExtractDynamic &operator=(const NodeOpVectorExtractDynamic &) = delete;
  NodeOpVectorExtractDynamic(NodeOpVectorExtractDynamic &&) = delete;
  NodeOpVectorExtractDynamic &operator=(NodeOpVectorExtractDynamic &&) = delete;
  NodeOpVectorExtractDynamic(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector,
    NodePointer<NodeId> index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
    this->index = index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVectorShuffle
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpVectorShuffle;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  eastl::vector<LiteralInteger> components;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
  }
  NodeOpVectorShuffle() = default;
  ~NodeOpVectorShuffle() = default;
  NodeOpVectorShuffle(const NodeOpVectorShuffle &) = delete;
  NodeOpVectorShuffle &operator=(const NodeOpVectorShuffle &) = delete;
  NodeOpVectorShuffle(NodeOpVectorShuffle &&) = delete;
  NodeOpVectorShuffle &operator=(NodeOpVectorShuffle &&) = delete;
  NodeOpVectorShuffle(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1,
    NodePointer<NodeId> vector_2, LiteralInteger *components = nullptr, size_t components_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->components.assign(components, components + components_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVectorTimesMatrix
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpVectorTimesMatrix;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  NodePointer<NodeId> matrix;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
    visitor(matrix);
  }
  NodeOpVectorTimesMatrix() = default;
  ~NodeOpVectorTimesMatrix() = default;
  NodeOpVectorTimesMatrix(const NodeOpVectorTimesMatrix &) = delete;
  NodeOpVectorTimesMatrix &operator=(const NodeOpVectorTimesMatrix &) = delete;
  NodeOpVectorTimesMatrix(NodeOpVectorTimesMatrix &&) = delete;
  NodeOpVectorTimesMatrix &operator=(NodeOpVectorTimesMatrix &&) = delete;
  NodeOpVectorTimesMatrix(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector,
    NodePointer<NodeId> matrix)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
    this->matrix = matrix;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVectorTimesScalar
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpVectorTimesScalar;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  NodePointer<NodeId> scalar;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
    visitor(scalar);
  }
  NodeOpVectorTimesScalar() = default;
  ~NodeOpVectorTimesScalar() = default;
  NodeOpVectorTimesScalar(const NodeOpVectorTimesScalar &) = delete;
  NodeOpVectorTimesScalar &operator=(const NodeOpVectorTimesScalar &) = delete;
  NodeOpVectorTimesScalar(NodeOpVectorTimesScalar &&) = delete;
  NodeOpVectorTimesScalar &operator=(NodeOpVectorTimesScalar &&) = delete;
  NodeOpVectorTimesScalar(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector,
    NodePointer<NodeId> scalar)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
    this->scalar = scalar;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVmeImageINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpVmeImageINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> imageType;
  NodePointer<NodeId> sampler;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(imageType);
    visitor(sampler);
  }
  NodeOpVmeImageINTEL() = default;
  ~NodeOpVmeImageINTEL() = default;
  NodeOpVmeImageINTEL(const NodeOpVmeImageINTEL &) = delete;
  NodeOpVmeImageINTEL &operator=(const NodeOpVmeImageINTEL &) = delete;
  NodeOpVmeImageINTEL(NodeOpVmeImageINTEL &&) = delete;
  NodeOpVmeImageINTEL &operator=(NodeOpVmeImageINTEL &&) = delete;
  NodeOpVmeImageINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image_type,
    NodePointer<NodeId> sampler)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->imageType = image_type;
    this->sampler = sampler;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpWritePipeBlockingINTEL
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpWritePipeBlockingINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpWritePipeBlockingINTEL() = default;
  ~NodeOpWritePipeBlockingINTEL() = default;
  NodeOpWritePipeBlockingINTEL(const NodeOpWritePipeBlockingINTEL &) = delete;
  NodeOpWritePipeBlockingINTEL &operator=(const NodeOpWritePipeBlockingINTEL &) = delete;
  NodeOpWritePipeBlockingINTEL(NodeOpWritePipeBlockingINTEL &&) = delete;
  NodeOpWritePipeBlockingINTEL &operator=(NodeOpWritePipeBlockingINTEL &&) = delete;
  NodeOpWritePipeBlockingINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Pow
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Pow;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450Pow() = default;
  ~NodeOpGLSLstd450Pow() = default;
  NodeOpGLSLstd450Pow(const NodeOpGLSLstd450Pow &) = delete;
  NodeOpGLSLstd450Pow &operator=(const NodeOpGLSLstd450Pow &) = delete;
  NodeOpGLSLstd450Pow(NodeOpGLSLstd450Pow &&) = delete;
  NodeOpGLSLstd450Pow &operator=(NodeOpGLSLstd450Pow &&) = delete;
  NodeOpGLSLstd450Pow(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Reflect
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Reflect;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> i;
  NodePointer<NodeId> n;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(i);
    visitor(n);
  }
  NodeOpGLSLstd450Reflect() = default;
  ~NodeOpGLSLstd450Reflect() = default;
  NodeOpGLSLstd450Reflect(const NodeOpGLSLstd450Reflect &) = delete;
  NodeOpGLSLstd450Reflect &operator=(const NodeOpGLSLstd450Reflect &) = delete;
  NodeOpGLSLstd450Reflect(NodeOpGLSLstd450Reflect &&) = delete;
  NodeOpGLSLstd450Reflect &operator=(NodeOpGLSLstd450Reflect &&) = delete;
  NodeOpGLSLstd450Reflect(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> i, NodePointer<NodeId> n)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->i = i;
    this->n = n;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SMax
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SMax;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450SMax() = default;
  ~NodeOpGLSLstd450SMax() = default;
  NodeOpGLSLstd450SMax(const NodeOpGLSLstd450SMax &) = delete;
  NodeOpGLSLstd450SMax &operator=(const NodeOpGLSLstd450SMax &) = delete;
  NodeOpGLSLstd450SMax(NodeOpGLSLstd450SMax &&) = delete;
  NodeOpGLSLstd450SMax &operator=(NodeOpGLSLstd450SMax &&) = delete;
  NodeOpGLSLstd450SMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SMin
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SMin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450SMin() = default;
  ~NodeOpGLSLstd450SMin() = default;
  NodeOpGLSLstd450SMin(const NodeOpGLSLstd450SMin &) = delete;
  NodeOpGLSLstd450SMin &operator=(const NodeOpGLSLstd450SMin &) = delete;
  NodeOpGLSLstd450SMin(NodeOpGLSLstd450SMin &&) = delete;
  NodeOpGLSLstd450SMin &operator=(NodeOpGLSLstd450SMin &&) = delete;
  NodeOpGLSLstd450SMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Step
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Step;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> edge;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(edge);
    visitor(x);
  }
  NodeOpGLSLstd450Step() = default;
  ~NodeOpGLSLstd450Step() = default;
  NodeOpGLSLstd450Step(const NodeOpGLSLstd450Step &) = delete;
  NodeOpGLSLstd450Step &operator=(const NodeOpGLSLstd450Step &) = delete;
  NodeOpGLSLstd450Step(NodeOpGLSLstd450Step &&) = delete;
  NodeOpGLSLstd450Step &operator=(NodeOpGLSLstd450Step &&) = delete;
  NodeOpGLSLstd450Step(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> edge, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->edge = edge;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderBallotSwizzleInvocations
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderBallot extOpCode = AMDShaderBallot::SwizzleInvocationsAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_ballot;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> data;
  NodePointer<NodeId> offset;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(data);
    visitor(offset);
  }
  NodeOpAMDShaderBallotSwizzleInvocations() = default;
  ~NodeOpAMDShaderBallotSwizzleInvocations() = default;
  NodeOpAMDShaderBallotSwizzleInvocations(const NodeOpAMDShaderBallotSwizzleInvocations &) = delete;
  NodeOpAMDShaderBallotSwizzleInvocations &operator=(const NodeOpAMDShaderBallotSwizzleInvocations &) = delete;
  NodeOpAMDShaderBallotSwizzleInvocations(NodeOpAMDShaderBallotSwizzleInvocations &&) = delete;
  NodeOpAMDShaderBallotSwizzleInvocations &operator=(NodeOpAMDShaderBallotSwizzleInvocations &&) = delete;
  NodeOpAMDShaderBallotSwizzleInvocations(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> data,
    NodePointer<NodeId> offset)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->data = data;
    this->offset = offset;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderBallotSwizzleInvocationsMasked
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderBallot extOpCode = AMDShaderBallot::SwizzleInvocationsMaskedAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_ballot;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> data;
  NodePointer<NodeId> mask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(data);
    visitor(mask);
  }
  NodeOpAMDShaderBallotSwizzleInvocationsMasked() = default;
  ~NodeOpAMDShaderBallotSwizzleInvocationsMasked() = default;
  NodeOpAMDShaderBallotSwizzleInvocationsMasked(const NodeOpAMDShaderBallotSwizzleInvocationsMasked &) = delete;
  NodeOpAMDShaderBallotSwizzleInvocationsMasked &operator=(const NodeOpAMDShaderBallotSwizzleInvocationsMasked &) = delete;
  NodeOpAMDShaderBallotSwizzleInvocationsMasked(NodeOpAMDShaderBallotSwizzleInvocationsMasked &&) = delete;
  NodeOpAMDShaderBallotSwizzleInvocationsMasked &operator=(NodeOpAMDShaderBallotSwizzleInvocationsMasked &&) = delete;
  NodeOpAMDShaderBallotSwizzleInvocationsMasked(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> data,
    NodePointer<NodeId> mask)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->data = data;
    this->mask = mask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UMax
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UMax;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450UMax() = default;
  ~NodeOpGLSLstd450UMax() = default;
  NodeOpGLSLstd450UMax(const NodeOpGLSLstd450UMax &) = delete;
  NodeOpGLSLstd450UMax &operator=(const NodeOpGLSLstd450UMax &) = delete;
  NodeOpGLSLstd450UMax(NodeOpGLSLstd450UMax &&) = delete;
  NodeOpGLSLstd450UMax &operator=(NodeOpGLSLstd450UMax &&) = delete;
  NodeOpGLSLstd450UMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UMin
{
  const NodeKind nodeKind = NodeKind::BinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UMin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
  }
  NodeOpGLSLstd450UMin() = default;
  ~NodeOpGLSLstd450UMin() = default;
  NodeOpGLSLstd450UMin(const NodeOpGLSLstd450UMin &) = delete;
  NodeOpGLSLstd450UMin &operator=(const NodeOpGLSLstd450UMin &) = delete;
  NodeOpGLSLstd450UMin(NodeOpGLSLstd450UMin &&) = delete;
  NodeOpGLSLstd450UMin &operator=(NodeOpGLSLstd450UMin &&) = delete;
  NodeOpGLSLstd450UMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeBinaryOperation::visit(NodeBinaryOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::BinaryOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAbsISubINTEL:
        if (visitor(reinterpret_cast<NodeOpAbsISubINTEL *>(node)))
          return true;
        break;
      case Op::OpAbsUSubINTEL:
        if (visitor(reinterpret_cast<NodeOpAbsUSubINTEL *>(node)))
          return true;
        break;
      case Op::OpAsmINTEL:
        if (visitor(reinterpret_cast<NodeOpAsmINTEL *>(node)))
          return true;
        break;
      case Op::OpBitwiseAnd:
        if (visitor(reinterpret_cast<NodeOpBitwiseAnd *>(node)))
          return true;
        break;
      case Op::OpBitwiseOr:
        if (visitor(reinterpret_cast<NodeOpBitwiseOr *>(node)))
          return true;
        break;
      case Op::OpBitwiseXor:
        if (visitor(reinterpret_cast<NodeOpBitwiseXor *>(node)))
          return true;
        break;
      case Op::OpCompositeInsert:
        if (visitor(reinterpret_cast<NodeOpCompositeInsert *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixLoadKHR:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixLoadKHR *>(node)))
          return true;
        break;
      case Op::OpDot:
        if (visitor(reinterpret_cast<NodeOpDot *>(node)))
          return true;
        break;
      case Op::OpExpectKHR:
        if (visitor(reinterpret_cast<NodeOpExpectKHR *>(node)))
          return true;
        break;
      case Op::OpFAdd:
        if (visitor(reinterpret_cast<NodeOpFAdd *>(node)))
          return true;
        break;
      case Op::OpFDiv:
        if (visitor(reinterpret_cast<NodeOpFDiv *>(node)))
          return true;
        break;
      case Op::OpFMod:
        if (visitor(reinterpret_cast<NodeOpFMod *>(node)))
          return true;
        break;
      case Op::OpFMul:
        if (visitor(reinterpret_cast<NodeOpFMul *>(node)))
          return true;
        break;
      case Op::OpFOrdEqual:
        if (visitor(reinterpret_cast<NodeOpFOrdEqual *>(node)))
          return true;
        break;
      case Op::OpFOrdGreaterThan:
        if (visitor(reinterpret_cast<NodeOpFOrdGreaterThan *>(node)))
          return true;
        break;
      case Op::OpFOrdGreaterThanEqual:
        if (visitor(reinterpret_cast<NodeOpFOrdGreaterThanEqual *>(node)))
          return true;
        break;
      case Op::OpFOrdLessThan:
        if (visitor(reinterpret_cast<NodeOpFOrdLessThan *>(node)))
          return true;
        break;
      case Op::OpFOrdLessThanEqual:
        if (visitor(reinterpret_cast<NodeOpFOrdLessThanEqual *>(node)))
          return true;
        break;
      case Op::OpFOrdNotEqual:
        if (visitor(reinterpret_cast<NodeOpFOrdNotEqual *>(node)))
          return true;
        break;
      case Op::OpFPGARegINTEL:
        if (visitor(reinterpret_cast<NodeOpFPGARegINTEL *>(node)))
          return true;
        break;
      case Op::OpFRem:
        if (visitor(reinterpret_cast<NodeOpFRem *>(node)))
          return true;
        break;
      case Op::OpFSub:
        if (visitor(reinterpret_cast<NodeOpFSub *>(node)))
          return true;
        break;
      case Op::OpFUnordEqual:
        if (visitor(reinterpret_cast<NodeOpFUnordEqual *>(node)))
          return true;
        break;
      case Op::OpFUnordGreaterThan:
        if (visitor(reinterpret_cast<NodeOpFUnordGreaterThan *>(node)))
          return true;
        break;
      case Op::OpFUnordGreaterThanEqual:
        if (visitor(reinterpret_cast<NodeOpFUnordGreaterThanEqual *>(node)))
          return true;
        break;
      case Op::OpFUnordLessThan:
        if (visitor(reinterpret_cast<NodeOpFUnordLessThan *>(node)))
          return true;
        break;
      case Op::OpFUnordLessThanEqual:
        if (visitor(reinterpret_cast<NodeOpFUnordLessThanEqual *>(node)))
          return true;
        break;
      case Op::OpFUnordNotEqual:
        if (visitor(reinterpret_cast<NodeOpFUnordNotEqual *>(node)))
          return true;
        break;
      case Op::OpFixedCosINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedCosINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedCosPiINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedCosPiINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedExpINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedExpINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedLogINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedLogINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedRecipINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedRecipINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedRsqrtINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedRsqrtINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedSinCosINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedSinCosINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedSinCosPiINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedSinCosPiINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedSinINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedSinINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedSinPiINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedSinPiINTEL *>(node)))
          return true;
        break;
      case Op::OpFixedSqrtINTEL:
        if (visitor(reinterpret_cast<NodeOpFixedSqrtINTEL *>(node)))
          return true;
        break;
      case Op::OpIAdd:
        if (visitor(reinterpret_cast<NodeOpIAdd *>(node)))
          return true;
        break;
      case Op::OpIAddCarry:
        if (visitor(reinterpret_cast<NodeOpIAddCarry *>(node)))
          return true;
        break;
      case Op::OpIAddSatINTEL:
        if (visitor(reinterpret_cast<NodeOpIAddSatINTEL *>(node)))
          return true;
        break;
      case Op::OpIAverageINTEL:
        if (visitor(reinterpret_cast<NodeOpIAverageINTEL *>(node)))
          return true;
        break;
      case Op::OpIAverageRoundedINTEL:
        if (visitor(reinterpret_cast<NodeOpIAverageRoundedINTEL *>(node)))
          return true;
        break;
      case Op::OpIEqual:
        if (visitor(reinterpret_cast<NodeOpIEqual *>(node)))
          return true;
        break;
      case Op::OpIMul:
        if (visitor(reinterpret_cast<NodeOpIMul *>(node)))
          return true;
        break;
      case Op::OpIMul32x16INTEL:
        if (visitor(reinterpret_cast<NodeOpIMul32x16INTEL *>(node)))
          return true;
        break;
      case Op::OpINotEqual:
        if (visitor(reinterpret_cast<NodeOpINotEqual *>(node)))
          return true;
        break;
      case Op::OpISub:
        if (visitor(reinterpret_cast<NodeOpISub *>(node)))
          return true;
        break;
      case Op::OpISubBorrow:
        if (visitor(reinterpret_cast<NodeOpISubBorrow *>(node)))
          return true;
        break;
      case Op::OpISubSatINTEL:
        if (visitor(reinterpret_cast<NodeOpISubSatINTEL *>(node)))
          return true;
        break;
      case Op::OpLessOrGreater:
        if (visitor(reinterpret_cast<NodeOpLessOrGreater *>(node)))
          return true;
        break;
      case Op::OpLogicalAnd:
        if (visitor(reinterpret_cast<NodeOpLogicalAnd *>(node)))
          return true;
        break;
      case Op::OpLogicalEqual:
        if (visitor(reinterpret_cast<NodeOpLogicalEqual *>(node)))
          return true;
        break;
      case Op::OpLogicalNotEqual:
        if (visitor(reinterpret_cast<NodeOpLogicalNotEqual *>(node)))
          return true;
        break;
      case Op::OpLogicalOr:
        if (visitor(reinterpret_cast<NodeOpLogicalOr *>(node)))
          return true;
        break;
      case Op::OpMatrixTimesMatrix:
        if (visitor(reinterpret_cast<NodeOpMatrixTimesMatrix *>(node)))
          return true;
        break;
      case Op::OpMatrixTimesScalar:
        if (visitor(reinterpret_cast<NodeOpMatrixTimesScalar *>(node)))
          return true;
        break;
      case Op::OpMatrixTimesVector:
        if (visitor(reinterpret_cast<NodeOpMatrixTimesVector *>(node)))
          return true;
        break;
      case Op::OpOrdered:
        if (visitor(reinterpret_cast<NodeOpOrdered *>(node)))
          return true;
        break;
      case Op::OpOuterProduct:
        if (visitor(reinterpret_cast<NodeOpOuterProduct *>(node)))
          return true;
        break;
      case Op::OpPtrDiff:
        if (visitor(reinterpret_cast<NodeOpPtrDiff *>(node)))
          return true;
        break;
      case Op::OpPtrEqual:
        if (visitor(reinterpret_cast<NodeOpPtrEqual *>(node)))
          return true;
        break;
      case Op::OpPtrNotEqual:
        if (visitor(reinterpret_cast<NodeOpPtrNotEqual *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionBarycentricsKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionBarycentricsKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionFrontFaceKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionFrontFaceKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionGeometryIndexKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionGeometryIndexKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionInstanceCustomIndexKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionInstanceIdKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionInstanceIdKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionObjectRayDirectionKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionObjectRayDirectionKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionObjectRayOriginKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionObjectRayOriginKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionObjectToWorldKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionObjectToWorldKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionPrimitiveIndexKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionPrimitiveIndexKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionTKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionTKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionTriangleVertexPositionsKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionTypeKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionTypeKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionWorldToObjectKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionWorldToObjectKHR *>(node)))
          return true;
        break;
      case Op::OpReadPipeBlockingINTEL:
        if (visitor(reinterpret_cast<NodeOpReadPipeBlockingINTEL *>(node)))
          return true;
        break;
      case Op::OpReportIntersectionKHR:
        if (visitor(reinterpret_cast<NodeOpReportIntersectionKHR *>(node)))
          return true;
        break;
      // duplicated OpReportIntersectionNV = 5334
      case Op::OpSDiv:
        if (visitor(reinterpret_cast<NodeOpSDiv *>(node)))
          return true;
        break;
      case Op::OpSDot:
        if (visitor(reinterpret_cast<NodeOpSDot *>(node)))
          return true;
        break;
      // duplicated OpSDotKHR = 4450
      case Op::OpSGreaterThan:
        if (visitor(reinterpret_cast<NodeOpSGreaterThan *>(node)))
          return true;
        break;
      case Op::OpSGreaterThanEqual:
        if (visitor(reinterpret_cast<NodeOpSGreaterThanEqual *>(node)))
          return true;
        break;
      case Op::OpSLessThan:
        if (visitor(reinterpret_cast<NodeOpSLessThan *>(node)))
          return true;
        break;
      case Op::OpSLessThanEqual:
        if (visitor(reinterpret_cast<NodeOpSLessThanEqual *>(node)))
          return true;
        break;
      case Op::OpSMod:
        if (visitor(reinterpret_cast<NodeOpSMod *>(node)))
          return true;
        break;
      case Op::OpSMulExtended:
        if (visitor(reinterpret_cast<NodeOpSMulExtended *>(node)))
          return true;
        break;
      case Op::OpSRem:
        if (visitor(reinterpret_cast<NodeOpSRem *>(node)))
          return true;
        break;
      case Op::OpSUDot:
        if (visitor(reinterpret_cast<NodeOpSUDot *>(node)))
          return true;
        break;
      // duplicated OpSUDotKHR = 4452
      case Op::OpShiftLeftLogical:
        if (visitor(reinterpret_cast<NodeOpShiftLeftLogical *>(node)))
          return true;
        break;
      case Op::OpShiftRightArithmetic:
        if (visitor(reinterpret_cast<NodeOpShiftRightArithmetic *>(node)))
          return true;
        break;
      case Op::OpShiftRightLogical:
        if (visitor(reinterpret_cast<NodeOpShiftRightLogical *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetBorderReachedINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetBorderReachedINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeRefWindowSizeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeRefWindowSizeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetMaxMotionVectorCountINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetWeightedSadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetWeightedSadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetInterDirectionPenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetInterShapePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicEvaluateIpeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicEvaluateIpeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetMotionVectorMaskINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupReadInvocationKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupReadInvocationKHR *>(node)))
          return true;
        break;
      case Op::OpSubgroupShuffleINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupShuffleINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupShuffleXorINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupShuffleXorINTEL *>(node)))
          return true;
        break;
      case Op::OpUAddSatINTEL:
        if (visitor(reinterpret_cast<NodeOpUAddSatINTEL *>(node)))
          return true;
        break;
      case Op::OpUAverageINTEL:
        if (visitor(reinterpret_cast<NodeOpUAverageINTEL *>(node)))
          return true;
        break;
      case Op::OpUAverageRoundedINTEL:
        if (visitor(reinterpret_cast<NodeOpUAverageRoundedINTEL *>(node)))
          return true;
        break;
      case Op::OpUDiv:
        if (visitor(reinterpret_cast<NodeOpUDiv *>(node)))
          return true;
        break;
      case Op::OpUDot:
        if (visitor(reinterpret_cast<NodeOpUDot *>(node)))
          return true;
        break;
      // duplicated OpUDotKHR = 4451
      case Op::OpUGreaterThan:
        if (visitor(reinterpret_cast<NodeOpUGreaterThan *>(node)))
          return true;
        break;
      case Op::OpUGreaterThanEqual:
        if (visitor(reinterpret_cast<NodeOpUGreaterThanEqual *>(node)))
          return true;
        break;
      case Op::OpULessThan:
        if (visitor(reinterpret_cast<NodeOpULessThan *>(node)))
          return true;
        break;
      case Op::OpULessThanEqual:
        if (visitor(reinterpret_cast<NodeOpULessThanEqual *>(node)))
          return true;
        break;
      case Op::OpUMod:
        if (visitor(reinterpret_cast<NodeOpUMod *>(node)))
          return true;
        break;
      case Op::OpUMul32x16INTEL:
        if (visitor(reinterpret_cast<NodeOpUMul32x16INTEL *>(node)))
          return true;
        break;
      case Op::OpUMulExtended:
        if (visitor(reinterpret_cast<NodeOpUMulExtended *>(node)))
          return true;
        break;
      case Op::OpUSubSatINTEL:
        if (visitor(reinterpret_cast<NodeOpUSubSatINTEL *>(node)))
          return true;
        break;
      case Op::OpUnordered:
        if (visitor(reinterpret_cast<NodeOpUnordered *>(node)))
          return true;
        break;
      case Op::OpVectorExtractDynamic:
        if (visitor(reinterpret_cast<NodeOpVectorExtractDynamic *>(node)))
          return true;
        break;
      case Op::OpVectorShuffle:
        if (visitor(reinterpret_cast<NodeOpVectorShuffle *>(node)))
          return true;
        break;
      case Op::OpVectorTimesMatrix:
        if (visitor(reinterpret_cast<NodeOpVectorTimesMatrix *>(node)))
          return true;
        break;
      case Op::OpVectorTimesScalar:
        if (visitor(reinterpret_cast<NodeOpVectorTimesScalar *>(node)))
          return true;
        break;
      case Op::OpVmeImageINTEL:
        if (visitor(reinterpret_cast<NodeOpVmeImageINTEL *>(node)))
          return true;
        break;
      case Op::OpWritePipeBlockingINTEL:
        if (visitor(reinterpret_cast<NodeOpWritePipeBlockingINTEL *>(node)))
          return true;
        break;
      case Op::OpExtInst:
        switch (node->grammarId)
        {
          default: break;
          case ExtendedGrammar::GLSL_std_450:
            switch (static_cast<GLSLstd450>(node->extOpCode))
            {
              default: break;
              case GLSLstd450::Atan2:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Atan2 *>(node)))
                  return true;
                break;
              case GLSLstd450::Cross:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Cross *>(node)))
                  return true;
                break;
              case GLSLstd450::Distance:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Distance *>(node)))
                  return true;
                break;
              case GLSLstd450::FMax:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FMax *>(node)))
                  return true;
                break;
              case GLSLstd450::FMin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FMin *>(node)))
                  return true;
                break;
              case GLSLstd450::Frexp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Frexp *>(node)))
                  return true;
                break;
              case GLSLstd450::InterpolateAtOffset:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450InterpolateAtOffset *>(node)))
                  return true;
                break;
              case GLSLstd450::InterpolateAtSample:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450InterpolateAtSample *>(node)))
                  return true;
                break;
              case GLSLstd450::Ldexp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Ldexp *>(node)))
                  return true;
                break;
              case GLSLstd450::Modf:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Modf *>(node)))
                  return true;
                break;
              case GLSLstd450::NMax:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450NMax *>(node)))
                  return true;
                break;
              case GLSLstd450::NMin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450NMin *>(node)))
                  return true;
                break;
              case GLSLstd450::Pow:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Pow *>(node)))
                  return true;
                break;
              case GLSLstd450::Reflect:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Reflect *>(node)))
                  return true;
                break;
              case GLSLstd450::SMax:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SMax *>(node)))
                  return true;
                break;
              case GLSLstd450::SMin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SMin *>(node)))
                  return true;
                break;
              case GLSLstd450::Step:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Step *>(node)))
                  return true;
                break;
              case GLSLstd450::UMax:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UMax *>(node)))
                  return true;
                break;
              case GLSLstd450::UMin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UMin *>(node)))
                  return true;
                break;
            }
            break;
          case ExtendedGrammar::AMD_shader_explicit_vertex_parameter: // only one instruction for this grammar
            if (static_cast<AMDShaderExplicitVertexParameter>(node->extOpCode) ==
                AMDShaderExplicitVertexParameter::InterpolateAtVertexAMD)
            {
              if (visitor(reinterpret_cast<NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex *>(node)))
                return true;
            }
            break;
          case ExtendedGrammar::AMD_shader_ballot:
            switch (static_cast<AMDShaderBallot>(node->extOpCode))
            {
              default: break;
              case AMDShaderBallot::SwizzleInvocationsAMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderBallotSwizzleInvocations *>(node)))
                  return true;
                break;
              case AMDShaderBallot::SwizzleInvocationsMaskedAMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderBallotSwizzleInvocationsMasked *>(node)))
                  return true;
                break;
            }
            break;
        }
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeConstant : NodeOperation
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeConstant *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpConstant
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstant;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  LiteralContextDependentNumber value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstant() = default;
  ~NodeOpConstant() = default;
  NodeOpConstant(const NodeOpConstant &) = delete;
  NodeOpConstant &operator=(const NodeOpConstant &) = delete;
  NodeOpConstant(NodeOpConstant &&) = delete;
  NodeOpConstant &operator=(NodeOpConstant &&) = delete;
  NodeOpConstant(Id id_result, NodePointer<NodeTypedef> id_result_type, LiteralContextDependentNumber value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantFalse
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstantFalse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstantFalse() = default;
  ~NodeOpConstantFalse() = default;
  NodeOpConstantFalse(const NodeOpConstantFalse &) = delete;
  NodeOpConstantFalse &operator=(const NodeOpConstantFalse &) = delete;
  NodeOpConstantFalse(NodeOpConstantFalse &&) = delete;
  NodeOpConstantFalse &operator=(NodeOpConstantFalse &&) = delete;
  NodeOpConstantFalse(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantFunctionPointerINTEL
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstantFunctionPointerINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> function;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(function);
  }
  NodeOpConstantFunctionPointerINTEL() = default;
  ~NodeOpConstantFunctionPointerINTEL() = default;
  NodeOpConstantFunctionPointerINTEL(const NodeOpConstantFunctionPointerINTEL &) = delete;
  NodeOpConstantFunctionPointerINTEL &operator=(const NodeOpConstantFunctionPointerINTEL &) = delete;
  NodeOpConstantFunctionPointerINTEL(NodeOpConstantFunctionPointerINTEL &&) = delete;
  NodeOpConstantFunctionPointerINTEL &operator=(NodeOpConstantFunctionPointerINTEL &&) = delete;
  NodeOpConstantFunctionPointerINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> function)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->function = function;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantNull
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstantNull;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstantNull() = default;
  ~NodeOpConstantNull() = default;
  NodeOpConstantNull(const NodeOpConstantNull &) = delete;
  NodeOpConstantNull &operator=(const NodeOpConstantNull &) = delete;
  NodeOpConstantNull(NodeOpConstantNull &&) = delete;
  NodeOpConstantNull &operator=(NodeOpConstantNull &&) = delete;
  NodeOpConstantNull(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantPipeStorage
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstantPipeStorage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  LiteralInteger packetSize;
  LiteralInteger packetAlignment;
  LiteralInteger capacity;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstantPipeStorage() = default;
  ~NodeOpConstantPipeStorage() = default;
  NodeOpConstantPipeStorage(const NodeOpConstantPipeStorage &) = delete;
  NodeOpConstantPipeStorage &operator=(const NodeOpConstantPipeStorage &) = delete;
  NodeOpConstantPipeStorage(NodeOpConstantPipeStorage &&) = delete;
  NodeOpConstantPipeStorage &operator=(NodeOpConstantPipeStorage &&) = delete;
  NodeOpConstantPipeStorage(Id id_result, NodePointer<NodeTypedef> id_result_type, LiteralInteger packet_size,
    LiteralInteger packet_alignment, LiteralInteger capacity)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
    this->capacity = capacity;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantTrue
{
  const NodeKind nodeKind = NodeKind::Constant;
  const Op opCode = Op::OpConstantTrue;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstantTrue() = default;
  ~NodeOpConstantTrue() = default;
  NodeOpConstantTrue(const NodeOpConstantTrue &) = delete;
  NodeOpConstantTrue &operator=(const NodeOpConstantTrue &) = delete;
  NodeOpConstantTrue(NodeOpConstantTrue &&) = delete;
  NodeOpConstantTrue &operator=(NodeOpConstantTrue &&) = delete;
  NodeOpConstantTrue(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeConstantComposite : NodeConstant
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeConstantComposite *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpConstantComposite
{
  const NodeKind nodeKind = NodeKind::ConstantComposite;
  const Op opCode = Op::OpConstantComposite;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpConstantComposite() = default;
  ~NodeOpConstantComposite() = default;
  NodeOpConstantComposite(const NodeOpConstantComposite &) = delete;
  NodeOpConstantComposite &operator=(const NodeOpConstantComposite &) = delete;
  NodeOpConstantComposite(NodeOpConstantComposite &&) = delete;
  NodeOpConstantComposite &operator=(NodeOpConstantComposite &&) = delete;
  NodeOpConstantComposite(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> *constituents = nullptr,
    size_t constituents_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConstantCompositeReplicateEXT
{
  const NodeKind nodeKind = NodeKind::ConstantComposite;
  const Op opCode = Op::OpConstantCompositeReplicateEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpConstantCompositeReplicateEXT() = default;
  ~NodeOpConstantCompositeReplicateEXT() = default;
  NodeOpConstantCompositeReplicateEXT(const NodeOpConstantCompositeReplicateEXT &) = delete;
  NodeOpConstantCompositeReplicateEXT &operator=(const NodeOpConstantCompositeReplicateEXT &) = delete;
  NodeOpConstantCompositeReplicateEXT(NodeOpConstantCompositeReplicateEXT &&) = delete;
  NodeOpConstantCompositeReplicateEXT &operator=(NodeOpConstantCompositeReplicateEXT &&) = delete;
  NodeOpConstantCompositeReplicateEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeConstantComposite::visit(NodeConstantComposite *node, T visitor)
{
  if (node->nodeKind == NodeKind::ConstantComposite)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpConstantComposite:
        if (visitor(reinterpret_cast<NodeOpConstantComposite *>(node)))
          return true;
        break;
      case Op::OpConstantCompositeReplicateEXT:
        if (visitor(reinterpret_cast<NodeOpConstantCompositeReplicateEXT *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeConstantSampler : NodeConstant
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeConstantSampler *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpConstantSampler
{
  const NodeKind nodeKind = NodeKind::ConstantSampler;
  const Op opCode = Op::OpConstantSampler;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  SamplerAddressingMode samplerAddressingMode;
  LiteralInteger param;
  SamplerFilterMode samplerFilterMode;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpConstantSampler() = default;
  ~NodeOpConstantSampler() = default;
  NodeOpConstantSampler(const NodeOpConstantSampler &) = delete;
  NodeOpConstantSampler &operator=(const NodeOpConstantSampler &) = delete;
  NodeOpConstantSampler(NodeOpConstantSampler &&) = delete;
  NodeOpConstantSampler &operator=(NodeOpConstantSampler &&) = delete;
  NodeOpConstantSampler(Id id_result, NodePointer<NodeTypedef> id_result_type, SamplerAddressingMode sampler_addressing_mode,
    LiteralInteger param, SamplerFilterMode sampler_filter_mode)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->samplerAddressingMode = sampler_addressing_mode;
    this->param = param;
    this->samplerFilterMode = sampler_filter_mode;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeConstantSampler::visit(NodeConstantSampler *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpConstantSampler *>(node)))
    return true;
  return visitor(node);
}
template <typename T>
inline bool NodeConstant::visit(NodeConstant *node, T visitor)
{
  if (node->nodeKind == NodeKind::Constant)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpConstant:
        if (visitor(reinterpret_cast<NodeOpConstant *>(node)))
          return true;
        break;
      case Op::OpConstantFalse:
        if (visitor(reinterpret_cast<NodeOpConstantFalse *>(node)))
          return true;
        break;
      case Op::OpConstantFunctionPointerINTEL:
        if (visitor(reinterpret_cast<NodeOpConstantFunctionPointerINTEL *>(node)))
          return true;
        break;
      case Op::OpConstantNull:
        if (visitor(reinterpret_cast<NodeOpConstantNull *>(node)))
          return true;
        break;
      case Op::OpConstantPipeStorage:
        if (visitor(reinterpret_cast<NodeOpConstantPipeStorage *>(node)))
          return true;
        break;
      case Op::OpConstantTrue:
        if (visitor(reinterpret_cast<NodeOpConstantTrue *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeConstantComposite::is(node))
    {
      if (NodeConstantComposite::visit(reinterpret_cast<NodeConstantComposite *>(node), visitor))
        return true;
    }
    else if (NodeConstantSampler::is(node))
    {
      if (NodeConstantSampler::visit(reinterpret_cast<NodeConstantSampler *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeFunction : NodeOperation
{
  FunctionControlMask functionControl;
  NodePointer<NodeTypedef> functionType;
  eastl::vector<NodePointer<NodeBlock>> body;
  eastl::vector<NodePointer<NodeVariable>> parameters;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeFunction *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpFunction
{
  const NodeKind nodeKind = NodeKind::Function;
  const Op opCode = Op::OpFunction;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  FunctionControlMask functionControl;
  NodePointer<NodeTypedef> functionType;
  eastl::vector<NodePointer<NodeBlock>> body;
  eastl::vector<NodePointer<NodeVariable>> parameters;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(functionType);
    for (auto &&p : parameters)
      visitor(p);
    for (auto &&b : body)
      visitor(b);
  }
  NodeOpFunction() = default;
  ~NodeOpFunction() = default;
  NodeOpFunction(const NodeOpFunction &) = delete;
  NodeOpFunction &operator=(const NodeOpFunction &) = delete;
  NodeOpFunction(NodeOpFunction &&) = delete;
  NodeOpFunction &operator=(NodeOpFunction &&) = delete;
  NodeOpFunction(Id id_result, NodePointer<NodeTypedef> id_result_type, FunctionControlMask function_control,
    NodePointer<NodeId> function_type)
  {
    resultType = id_result_type;
    resultId = id_result;
    functionControl = function_control;
    functionType = function_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeFunction::visit(NodeFunction *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpFunction *>(node)))
    return true;
  return visitor(node);
}
struct NodeFunctionCall : NodeOperation
{
  NodePointer<NodeOperation> function;
  eastl::vector<NodePointer<NodeOperation>> parameters;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeFunctionCall *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpFunctionCall
{
  const NodeKind nodeKind = NodeKind::FunctionCall;
  const Op opCode = Op::OpFunctionCall;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> function;
  eastl::vector<NodePointer<NodeOperation>> parameters;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(function);
    for (auto &&p : parameters)
      visitor(p);
  }
  NodeOpFunctionCall() = default;
  ~NodeOpFunctionCall() = default;
  NodeOpFunctionCall(const NodeOpFunctionCall &) = delete;
  NodeOpFunctionCall &operator=(const NodeOpFunctionCall &) = delete;
  NodeOpFunctionCall(NodeOpFunctionCall &&) = delete;
  NodeOpFunctionCall &operator=(NodeOpFunctionCall &&) = delete;
  NodeOpFunctionCall(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> function,
    NodePointer<NodeId> *param_3 = nullptr, size_t param_3_count = 0)
  {
    resultType = id_result_type;
    resultId = id_result;
    function = function;
    parameters.assign(param_3, param_3 + param_3_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeFunctionCall::visit(NodeFunctionCall *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpFunctionCall *>(node)))
    return true;
  return visitor(node);
}
struct NodeImageOperation : NodeOperation
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeImageOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpFragmentFetchAMD
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpFragmentFetchAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> fragmentIndex;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    visitor(fragmentIndex);
  }
  NodeOpFragmentFetchAMD() = default;
  ~NodeOpFragmentFetchAMD() = default;
  NodeOpFragmentFetchAMD(const NodeOpFragmentFetchAMD &) = delete;
  NodeOpFragmentFetchAMD &operator=(const NodeOpFragmentFetchAMD &) = delete;
  NodeOpFragmentFetchAMD(NodeOpFragmentFetchAMD &&) = delete;
  NodeOpFragmentFetchAMD &operator=(NodeOpFragmentFetchAMD &&) = delete;
  NodeOpFragmentFetchAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> fragment_index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->fragmentIndex = fragment_index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFragmentMaskFetchAMD
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpFragmentMaskFetchAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
  }
  NodeOpFragmentMaskFetchAMD() = default;
  ~NodeOpFragmentMaskFetchAMD() = default;
  NodeOpFragmentMaskFetchAMD(const NodeOpFragmentMaskFetchAMD &) = delete;
  NodeOpFragmentMaskFetchAMD &operator=(const NodeOpFragmentMaskFetchAMD &) = delete;
  NodeOpFragmentMaskFetchAMD(NodeOpFragmentMaskFetchAMD &&) = delete;
  NodeOpFragmentMaskFetchAMD &operator=(NodeOpFragmentMaskFetchAMD &&) = delete;
  NodeOpFragmentMaskFetchAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImage
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
  }
  NodeOpImage() = default;
  ~NodeOpImage() = default;
  NodeOpImage(const NodeOpImage &) = delete;
  NodeOpImage &operator=(const NodeOpImage &) = delete;
  NodeOpImage(NodeOpImage &&) = delete;
  NodeOpImage &operator=(NodeOpImage &&) = delete;
  NodeOpImage(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageDrefGather
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageDrefGather;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageDrefGather() = default;
  ~NodeOpImageDrefGather() = default;
  NodeOpImageDrefGather(const NodeOpImageDrefGather &) = delete;
  NodeOpImageDrefGather &operator=(const NodeOpImageDrefGather &) = delete;
  NodeOpImageDrefGather(NodeOpImageDrefGather &&) = delete;
  NodeOpImageDrefGather &operator=(NodeOpImageDrefGather &&) = delete;
  NodeOpImageDrefGather(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageFetch
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageFetch;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageFetch() = default;
  ~NodeOpImageFetch() = default;
  NodeOpImageFetch(const NodeOpImageFetch &) = delete;
  NodeOpImageFetch &operator=(const NodeOpImageFetch &) = delete;
  NodeOpImageFetch(NodeOpImageFetch &&) = delete;
  NodeOpImageFetch &operator=(NodeOpImageFetch &&) = delete;
  NodeOpImageFetch(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image, NodePointer<NodeId> coordinate,
    eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageGather
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageGather;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> component;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(component);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageGather() = default;
  ~NodeOpImageGather() = default;
  NodeOpImageGather(const NodeOpImageGather &) = delete;
  NodeOpImageGather &operator=(const NodeOpImageGather &) = delete;
  NodeOpImageGather(NodeOpImageGather &&) = delete;
  NodeOpImageGather &operator=(NodeOpImageGather &&) = delete;
  NodeOpImageGather(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> component, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->component = component;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQueryFormat
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQueryFormat;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
  }
  NodeOpImageQueryFormat() = default;
  ~NodeOpImageQueryFormat() = default;
  NodeOpImageQueryFormat(const NodeOpImageQueryFormat &) = delete;
  NodeOpImageQueryFormat &operator=(const NodeOpImageQueryFormat &) = delete;
  NodeOpImageQueryFormat(NodeOpImageQueryFormat &&) = delete;
  NodeOpImageQueryFormat &operator=(NodeOpImageQueryFormat &&) = delete;
  NodeOpImageQueryFormat(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQueryLevels
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQueryLevels;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
  }
  NodeOpImageQueryLevels() = default;
  ~NodeOpImageQueryLevels() = default;
  NodeOpImageQueryLevels(const NodeOpImageQueryLevels &) = delete;
  NodeOpImageQueryLevels &operator=(const NodeOpImageQueryLevels &) = delete;
  NodeOpImageQueryLevels(NodeOpImageQueryLevels &&) = delete;
  NodeOpImageQueryLevels &operator=(NodeOpImageQueryLevels &&) = delete;
  NodeOpImageQueryLevels(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQueryLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQueryLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
  }
  NodeOpImageQueryLod() = default;
  ~NodeOpImageQueryLod() = default;
  NodeOpImageQueryLod(const NodeOpImageQueryLod &) = delete;
  NodeOpImageQueryLod &operator=(const NodeOpImageQueryLod &) = delete;
  NodeOpImageQueryLod(NodeOpImageQueryLod &&) = delete;
  NodeOpImageQueryLod &operator=(NodeOpImageQueryLod &&) = delete;
  NodeOpImageQueryLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQueryOrder
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQueryOrder;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
  }
  NodeOpImageQueryOrder() = default;
  ~NodeOpImageQueryOrder() = default;
  NodeOpImageQueryOrder(const NodeOpImageQueryOrder &) = delete;
  NodeOpImageQueryOrder &operator=(const NodeOpImageQueryOrder &) = delete;
  NodeOpImageQueryOrder(NodeOpImageQueryOrder &&) = delete;
  NodeOpImageQueryOrder &operator=(NodeOpImageQueryOrder &&) = delete;
  NodeOpImageQueryOrder(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQuerySamples
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQuerySamples;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
  }
  NodeOpImageQuerySamples() = default;
  ~NodeOpImageQuerySamples() = default;
  NodeOpImageQuerySamples(const NodeOpImageQuerySamples &) = delete;
  NodeOpImageQuerySamples &operator=(const NodeOpImageQuerySamples &) = delete;
  NodeOpImageQuerySamples(NodeOpImageQuerySamples &&) = delete;
  NodeOpImageQuerySamples &operator=(NodeOpImageQuerySamples &&) = delete;
  NodeOpImageQuerySamples(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQuerySize
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQuerySize;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
  }
  NodeOpImageQuerySize() = default;
  ~NodeOpImageQuerySize() = default;
  NodeOpImageQuerySize(const NodeOpImageQuerySize &) = delete;
  NodeOpImageQuerySize &operator=(const NodeOpImageQuerySize &) = delete;
  NodeOpImageQuerySize(NodeOpImageQuerySize &&) = delete;
  NodeOpImageQuerySize &operator=(NodeOpImageQuerySize &&) = delete;
  NodeOpImageQuerySize(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageQuerySizeLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageQuerySizeLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> levelOfDetail;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(levelOfDetail);
  }
  NodeOpImageQuerySizeLod() = default;
  ~NodeOpImageQuerySizeLod() = default;
  NodeOpImageQuerySizeLod(const NodeOpImageQuerySizeLod &) = delete;
  NodeOpImageQuerySizeLod &operator=(const NodeOpImageQuerySizeLod &) = delete;
  NodeOpImageQuerySizeLod(NodeOpImageQuerySizeLod &&) = delete;
  NodeOpImageQuerySizeLod &operator=(NodeOpImageQuerySizeLod &&) = delete;
  NodeOpImageQuerySizeLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> level_of_detail)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->levelOfDetail = level_of_detail;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageRead
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageRead;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageRead() = default;
  ~NodeOpImageRead() = default;
  NodeOpImageRead(const NodeOpImageRead &) = delete;
  NodeOpImageRead &operator=(const NodeOpImageRead &) = delete;
  NodeOpImageRead(NodeOpImageRead &&) = delete;
  NodeOpImageRead &operator=(NodeOpImageRead &&) = delete;
  NodeOpImageRead(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image, NodePointer<NodeId> coordinate,
    eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleDrefExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleDrefExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleDrefExplicitLod() = default;
  ~NodeOpImageSampleDrefExplicitLod() = default;
  NodeOpImageSampleDrefExplicitLod(const NodeOpImageSampleDrefExplicitLod &) = delete;
  NodeOpImageSampleDrefExplicitLod &operator=(const NodeOpImageSampleDrefExplicitLod &) = delete;
  NodeOpImageSampleDrefExplicitLod(NodeOpImageSampleDrefExplicitLod &&) = delete;
  NodeOpImageSampleDrefExplicitLod &operator=(NodeOpImageSampleDrefExplicitLod &&) = delete;
  NodeOpImageSampleDrefExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, ImageOperandsMask image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleDrefImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleDrefImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleDrefImplicitLod() = default;
  ~NodeOpImageSampleDrefImplicitLod() = default;
  NodeOpImageSampleDrefImplicitLod(const NodeOpImageSampleDrefImplicitLod &) = delete;
  NodeOpImageSampleDrefImplicitLod &operator=(const NodeOpImageSampleDrefImplicitLod &) = delete;
  NodeOpImageSampleDrefImplicitLod(NodeOpImageSampleDrefImplicitLod &&) = delete;
  NodeOpImageSampleDrefImplicitLod &operator=(NodeOpImageSampleDrefImplicitLod &&) = delete;
  NodeOpImageSampleDrefImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleExplicitLod() = default;
  ~NodeOpImageSampleExplicitLod() = default;
  NodeOpImageSampleExplicitLod(const NodeOpImageSampleExplicitLod &) = delete;
  NodeOpImageSampleExplicitLod &operator=(const NodeOpImageSampleExplicitLod &) = delete;
  NodeOpImageSampleExplicitLod(NodeOpImageSampleExplicitLod &&) = delete;
  NodeOpImageSampleExplicitLod &operator=(NodeOpImageSampleExplicitLod &&) = delete;
  NodeOpImageSampleExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, ImageOperandsMask image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleFootprintNV
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleFootprintNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> granularity;
  NodePointer<NodeId> coarse;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(granularity);
    visitor(coarse);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleFootprintNV() = default;
  ~NodeOpImageSampleFootprintNV() = default;
  NodeOpImageSampleFootprintNV(const NodeOpImageSampleFootprintNV &) = delete;
  NodeOpImageSampleFootprintNV &operator=(const NodeOpImageSampleFootprintNV &) = delete;
  NodeOpImageSampleFootprintNV(NodeOpImageSampleFootprintNV &&) = delete;
  NodeOpImageSampleFootprintNV &operator=(NodeOpImageSampleFootprintNV &&) = delete;
  NodeOpImageSampleFootprintNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> granularity, NodePointer<NodeId> coarse,
    eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->granularity = granularity;
    this->coarse = coarse;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleImplicitLod() = default;
  ~NodeOpImageSampleImplicitLod() = default;
  NodeOpImageSampleImplicitLod(const NodeOpImageSampleImplicitLod &) = delete;
  NodeOpImageSampleImplicitLod &operator=(const NodeOpImageSampleImplicitLod &) = delete;
  NodeOpImageSampleImplicitLod(NodeOpImageSampleImplicitLod &&) = delete;
  NodeOpImageSampleImplicitLod &operator=(NodeOpImageSampleImplicitLod &&) = delete;
  NodeOpImageSampleImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleProjDrefExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleProjDrefExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleProjDrefExplicitLod() = default;
  ~NodeOpImageSampleProjDrefExplicitLod() = default;
  NodeOpImageSampleProjDrefExplicitLod(const NodeOpImageSampleProjDrefExplicitLod &) = delete;
  NodeOpImageSampleProjDrefExplicitLod &operator=(const NodeOpImageSampleProjDrefExplicitLod &) = delete;
  NodeOpImageSampleProjDrefExplicitLod(NodeOpImageSampleProjDrefExplicitLod &&) = delete;
  NodeOpImageSampleProjDrefExplicitLod &operator=(NodeOpImageSampleProjDrefExplicitLod &&) = delete;
  NodeOpImageSampleProjDrefExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, ImageOperandsMask image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleProjDrefImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleProjDrefImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleProjDrefImplicitLod() = default;
  ~NodeOpImageSampleProjDrefImplicitLod() = default;
  NodeOpImageSampleProjDrefImplicitLod(const NodeOpImageSampleProjDrefImplicitLod &) = delete;
  NodeOpImageSampleProjDrefImplicitLod &operator=(const NodeOpImageSampleProjDrefImplicitLod &) = delete;
  NodeOpImageSampleProjDrefImplicitLod(NodeOpImageSampleProjDrefImplicitLod &&) = delete;
  NodeOpImageSampleProjDrefImplicitLod &operator=(NodeOpImageSampleProjDrefImplicitLod &&) = delete;
  NodeOpImageSampleProjDrefImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleProjExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleProjExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleProjExplicitLod() = default;
  ~NodeOpImageSampleProjExplicitLod() = default;
  NodeOpImageSampleProjExplicitLod(const NodeOpImageSampleProjExplicitLod &) = delete;
  NodeOpImageSampleProjExplicitLod &operator=(const NodeOpImageSampleProjExplicitLod &) = delete;
  NodeOpImageSampleProjExplicitLod(NodeOpImageSampleProjExplicitLod &&) = delete;
  NodeOpImageSampleProjExplicitLod &operator=(NodeOpImageSampleProjExplicitLod &&) = delete;
  NodeOpImageSampleProjExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, ImageOperandsMask image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleProjImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSampleProjImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSampleProjImplicitLod() = default;
  ~NodeOpImageSampleProjImplicitLod() = default;
  NodeOpImageSampleProjImplicitLod(const NodeOpImageSampleProjImplicitLod &) = delete;
  NodeOpImageSampleProjImplicitLod &operator=(const NodeOpImageSampleProjImplicitLod &) = delete;
  NodeOpImageSampleProjImplicitLod(NodeOpImageSampleProjImplicitLod &&) = delete;
  NodeOpImageSampleProjImplicitLod &operator=(NodeOpImageSampleProjImplicitLod &&) = delete;
  NodeOpImageSampleProjImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseDrefGather
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseDrefGather;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseDrefGather() = default;
  ~NodeOpImageSparseDrefGather() = default;
  NodeOpImageSparseDrefGather(const NodeOpImageSparseDrefGather &) = delete;
  NodeOpImageSparseDrefGather &operator=(const NodeOpImageSparseDrefGather &) = delete;
  NodeOpImageSparseDrefGather(NodeOpImageSparseDrefGather &&) = delete;
  NodeOpImageSparseDrefGather &operator=(NodeOpImageSparseDrefGather &&) = delete;
  NodeOpImageSparseDrefGather(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseFetch
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseFetch;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseFetch() = default;
  ~NodeOpImageSparseFetch() = default;
  NodeOpImageSparseFetch(const NodeOpImageSparseFetch &) = delete;
  NodeOpImageSparseFetch &operator=(const NodeOpImageSparseFetch &) = delete;
  NodeOpImageSparseFetch(NodeOpImageSparseFetch &&) = delete;
  NodeOpImageSparseFetch &operator=(NodeOpImageSparseFetch &&) = delete;
  NodeOpImageSparseFetch(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseGather
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseGather;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> component;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(component);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseGather() = default;
  ~NodeOpImageSparseGather() = default;
  NodeOpImageSparseGather(const NodeOpImageSparseGather &) = delete;
  NodeOpImageSparseGather &operator=(const NodeOpImageSparseGather &) = delete;
  NodeOpImageSparseGather(NodeOpImageSparseGather &&) = delete;
  NodeOpImageSparseGather &operator=(NodeOpImageSparseGather &&) = delete;
  NodeOpImageSparseGather(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> component, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->component = component;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseRead
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseRead;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseRead() = default;
  ~NodeOpImageSparseRead() = default;
  NodeOpImageSparseRead(const NodeOpImageSparseRead &) = delete;
  NodeOpImageSparseRead &operator=(const NodeOpImageSparseRead &) = delete;
  NodeOpImageSparseRead(NodeOpImageSparseRead &&) = delete;
  NodeOpImageSparseRead &operator=(NodeOpImageSparseRead &&) = delete;
  NodeOpImageSparseRead(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleDrefExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleDrefExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleDrefExplicitLod() = default;
  ~NodeOpImageSparseSampleDrefExplicitLod() = default;
  NodeOpImageSparseSampleDrefExplicitLod(const NodeOpImageSparseSampleDrefExplicitLod &) = delete;
  NodeOpImageSparseSampleDrefExplicitLod &operator=(const NodeOpImageSparseSampleDrefExplicitLod &) = delete;
  NodeOpImageSparseSampleDrefExplicitLod(NodeOpImageSparseSampleDrefExplicitLod &&) = delete;
  NodeOpImageSparseSampleDrefExplicitLod &operator=(NodeOpImageSparseSampleDrefExplicitLod &&) = delete;
  NodeOpImageSparseSampleDrefExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, ImageOperandsMask image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleDrefImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleDrefImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleDrefImplicitLod() = default;
  ~NodeOpImageSparseSampleDrefImplicitLod() = default;
  NodeOpImageSparseSampleDrefImplicitLod(const NodeOpImageSparseSampleDrefImplicitLod &) = delete;
  NodeOpImageSparseSampleDrefImplicitLod &operator=(const NodeOpImageSparseSampleDrefImplicitLod &) = delete;
  NodeOpImageSparseSampleDrefImplicitLod(NodeOpImageSparseSampleDrefImplicitLod &&) = delete;
  NodeOpImageSparseSampleDrefImplicitLod &operator=(NodeOpImageSparseSampleDrefImplicitLod &&) = delete;
  NodeOpImageSparseSampleDrefImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleExplicitLod() = default;
  ~NodeOpImageSparseSampleExplicitLod() = default;
  NodeOpImageSparseSampleExplicitLod(const NodeOpImageSparseSampleExplicitLod &) = delete;
  NodeOpImageSparseSampleExplicitLod &operator=(const NodeOpImageSparseSampleExplicitLod &) = delete;
  NodeOpImageSparseSampleExplicitLod(NodeOpImageSparseSampleExplicitLod &&) = delete;
  NodeOpImageSparseSampleExplicitLod &operator=(NodeOpImageSparseSampleExplicitLod &&) = delete;
  NodeOpImageSparseSampleExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, ImageOperandsMask image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleImplicitLod() = default;
  ~NodeOpImageSparseSampleImplicitLod() = default;
  NodeOpImageSparseSampleImplicitLod(const NodeOpImageSparseSampleImplicitLod &) = delete;
  NodeOpImageSparseSampleImplicitLod &operator=(const NodeOpImageSparseSampleImplicitLod &) = delete;
  NodeOpImageSparseSampleImplicitLod(NodeOpImageSparseSampleImplicitLod &&) = delete;
  NodeOpImageSparseSampleImplicitLod &operator=(NodeOpImageSparseSampleImplicitLod &&) = delete;
  NodeOpImageSparseSampleImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleProjDrefExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleProjDrefExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleProjDrefExplicitLod() = default;
  ~NodeOpImageSparseSampleProjDrefExplicitLod() = default;
  NodeOpImageSparseSampleProjDrefExplicitLod(const NodeOpImageSparseSampleProjDrefExplicitLod &) = delete;
  NodeOpImageSparseSampleProjDrefExplicitLod &operator=(const NodeOpImageSparseSampleProjDrefExplicitLod &) = delete;
  NodeOpImageSparseSampleProjDrefExplicitLod(NodeOpImageSparseSampleProjDrefExplicitLod &&) = delete;
  NodeOpImageSparseSampleProjDrefExplicitLod &operator=(NodeOpImageSparseSampleProjDrefExplicitLod &&) = delete;
  NodeOpImageSparseSampleProjDrefExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, ImageOperandsMask image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleProjDrefImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleProjDrefImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> dRef;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    visitor(dRef);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleProjDrefImplicitLod() = default;
  ~NodeOpImageSparseSampleProjDrefImplicitLod() = default;
  NodeOpImageSparseSampleProjDrefImplicitLod(const NodeOpImageSparseSampleProjDrefImplicitLod &) = delete;
  NodeOpImageSparseSampleProjDrefImplicitLod &operator=(const NodeOpImageSparseSampleProjDrefImplicitLod &) = delete;
  NodeOpImageSparseSampleProjDrefImplicitLod(NodeOpImageSparseSampleProjDrefImplicitLod &&) = delete;
  NodeOpImageSparseSampleProjDrefImplicitLod &operator=(NodeOpImageSparseSampleProjDrefImplicitLod &&) = delete;
  NodeOpImageSparseSampleProjDrefImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> d_ref, eastl::optional<ImageOperandsMask> image_operands,
    NodePointer<NodeId> image_operands_bias = {}, NodePointer<NodeId> image_operands_lod = {},
    NodePointer<NodeId> image_operands_grad_x = {}, NodePointer<NodeId> image_operands_grad_y = {},
    NodePointer<NodeId> image_operands_constOffset = {}, NodePointer<NodeId> image_operands_offset = {},
    NodePointer<NodeId> image_operands_constOffsets = {}, NodePointer<NodeId> image_operands_sample = {},
    NodePointer<NodeId> image_operands_minLod = {}, NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->dRef = d_ref;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleProjExplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleProjExplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  ImageOperandsMask imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleProjExplicitLod() = default;
  ~NodeOpImageSparseSampleProjExplicitLod() = default;
  NodeOpImageSparseSampleProjExplicitLod(const NodeOpImageSparseSampleProjExplicitLod &) = delete;
  NodeOpImageSparseSampleProjExplicitLod &operator=(const NodeOpImageSparseSampleProjExplicitLod &) = delete;
  NodeOpImageSparseSampleProjExplicitLod(NodeOpImageSparseSampleProjExplicitLod &&) = delete;
  NodeOpImageSparseSampleProjExplicitLod &operator=(NodeOpImageSparseSampleProjExplicitLod &&) = delete;
  NodeOpImageSparseSampleProjExplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, ImageOperandsMask image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseSampleProjImplicitLod
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpImageSparseSampleProjImplicitLod;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> sampledImage;
  NodePointer<NodeId> coordinate;
  eastl::optional<ImageOperandsMask> imageOperands;
  // extra values for imageOperands
  NodePointer<NodeId> imageOperandsBias;
  NodePointer<NodeId> imageOperandsLod;
  NodePointer<NodeId> imageOperandsGradX;
  NodePointer<NodeId> imageOperandsGradY;
  NodePointer<NodeId> imageOperandsConstOffset;
  NodePointer<NodeId> imageOperandsOffset;
  NodePointer<NodeId> imageOperandsConstOffsets;
  NodePointer<NodeId> imageOperandsSample;
  NodePointer<NodeId> imageOperandsMinLod;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailable;
  NodePointer<NodeOperation> imageOperandsMakeTexelAvailableKHR;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisible;
  NodePointer<NodeOperation> imageOperandsMakeTexelVisibleKHR;
  NodePointer<NodeId> imageOperandsOffsets;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(sampledImage);
    visitor(coordinate);
    if (imageOperandsBias)
      visitor(imageOperandsBias);
    if (imageOperandsLod)
      visitor(imageOperandsLod);
    if (imageOperandsGradX)
      visitor(imageOperandsGradX);
    if (imageOperandsGradY)
      visitor(imageOperandsGradY);
    if (imageOperandsConstOffset)
      visitor(imageOperandsConstOffset);
    if (imageOperandsOffset)
      visitor(imageOperandsOffset);
    if (imageOperandsConstOffsets)
      visitor(imageOperandsConstOffsets);
    if (imageOperandsSample)
      visitor(imageOperandsSample);
    if (imageOperandsMinLod)
      visitor(imageOperandsMinLod);
    if (imageOperandsMakeTexelAvailable)
      visitor(imageOperandsMakeTexelAvailable);
    if (imageOperandsMakeTexelAvailableKHR)
      visitor(imageOperandsMakeTexelAvailableKHR);
    if (imageOperandsMakeTexelVisible)
      visitor(imageOperandsMakeTexelVisible);
    if (imageOperandsMakeTexelVisibleKHR)
      visitor(imageOperandsMakeTexelVisibleKHR);
    if (imageOperandsOffsets)
      visitor(imageOperandsOffsets);
  }
  NodeOpImageSparseSampleProjImplicitLod() = default;
  ~NodeOpImageSparseSampleProjImplicitLod() = default;
  NodeOpImageSparseSampleProjImplicitLod(const NodeOpImageSparseSampleProjImplicitLod &) = delete;
  NodeOpImageSparseSampleProjImplicitLod &operator=(const NodeOpImageSparseSampleProjImplicitLod &) = delete;
  NodeOpImageSparseSampleProjImplicitLod(NodeOpImageSparseSampleProjImplicitLod &&) = delete;
  NodeOpImageSparseSampleProjImplicitLod &operator=(NodeOpImageSparseSampleProjImplicitLod &&) = delete;
  NodeOpImageSparseSampleProjImplicitLod(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> sampled_image,
    NodePointer<NodeId> coordinate, eastl::optional<ImageOperandsMask> image_operands, NodePointer<NodeId> image_operands_bias = {},
    NodePointer<NodeId> image_operands_lod = {}, NodePointer<NodeId> image_operands_grad_x = {},
    NodePointer<NodeId> image_operands_grad_y = {}, NodePointer<NodeId> image_operands_constOffset = {},
    NodePointer<NodeId> image_operands_offset = {}, NodePointer<NodeId> image_operands_constOffsets = {},
    NodePointer<NodeId> image_operands_sample = {}, NodePointer<NodeId> image_operands_minLod = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailable = {},
    NodePointer<NodeOperation> image_operands_makeTexelAvailableKHR = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisible = {},
    NodePointer<NodeOperation> image_operands_makeTexelVisibleKHR = {}, NodePointer<NodeId> image_operands_offsets = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->sampledImage = sampled_image;
    this->coordinate = coordinate;
    this->imageOperands = image_operands;
    this->imageOperandsBias = image_operands_bias;
    this->imageOperandsLod = image_operands_lod;
    this->imageOperandsGradX = image_operands_grad_x;
    this->imageOperandsGradY = image_operands_grad_y;
    this->imageOperandsConstOffset = image_operands_constOffset;
    this->imageOperandsOffset = image_operands_offset;
    this->imageOperandsConstOffsets = image_operands_constOffsets;
    this->imageOperandsSample = image_operands_sample;
    this->imageOperandsMinLod = image_operands_minLod;
    this->imageOperandsMakeTexelAvailable = image_operands_makeTexelAvailable;
    this->imageOperandsMakeTexelAvailableKHR = image_operands_makeTexelAvailableKHR;
    this->imageOperandsMakeTexelVisible = image_operands_makeTexelVisible;
    this->imageOperandsMakeTexelVisibleKHR = image_operands_makeTexelVisibleKHR;
    this->imageOperandsOffsets = image_operands_offsets;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSampledImage
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpSampledImage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> sampler;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(sampler);
  }
  NodeOpSampledImage() = default;
  ~NodeOpSampledImage() = default;
  NodeOpSampledImage(const NodeOpSampledImage &) = delete;
  NodeOpSampledImage &operator=(const NodeOpSampledImage &) = delete;
  NodeOpSampledImage(NodeOpSampledImage &&) = delete;
  NodeOpSampledImage &operator=(NodeOpSampledImage &&) = delete;
  NodeOpSampledImage(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image, NodePointer<NodeId> sampler)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->sampler = sampler;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupImageBlockReadINTEL
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpSubgroupImageBlockReadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
  }
  NodeOpSubgroupImageBlockReadINTEL() = default;
  ~NodeOpSubgroupImageBlockReadINTEL() = default;
  NodeOpSubgroupImageBlockReadINTEL(const NodeOpSubgroupImageBlockReadINTEL &) = delete;
  NodeOpSubgroupImageBlockReadINTEL &operator=(const NodeOpSubgroupImageBlockReadINTEL &) = delete;
  NodeOpSubgroupImageBlockReadINTEL(NodeOpSubgroupImageBlockReadINTEL &&) = delete;
  NodeOpSubgroupImageBlockReadINTEL &operator=(NodeOpSubgroupImageBlockReadINTEL &&) = delete;
  NodeOpSubgroupImageBlockReadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupImageMediaBlockReadINTEL
{
  const NodeKind nodeKind = NodeKind::ImageOperation;
  const Op opCode = Op::OpSubgroupImageMediaBlockReadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> width;
  NodePointer<NodeId> height;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    visitor(width);
    visitor(height);
  }
  NodeOpSubgroupImageMediaBlockReadINTEL() = default;
  ~NodeOpSubgroupImageMediaBlockReadINTEL() = default;
  NodeOpSubgroupImageMediaBlockReadINTEL(const NodeOpSubgroupImageMediaBlockReadINTEL &) = delete;
  NodeOpSubgroupImageMediaBlockReadINTEL &operator=(const NodeOpSubgroupImageMediaBlockReadINTEL &) = delete;
  NodeOpSubgroupImageMediaBlockReadINTEL(NodeOpSubgroupImageMediaBlockReadINTEL &&) = delete;
  NodeOpSubgroupImageMediaBlockReadINTEL &operator=(NodeOpSubgroupImageMediaBlockReadINTEL &&) = delete;
  NodeOpSubgroupImageMediaBlockReadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> width, NodePointer<NodeId> height)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->width = width;
    this->height = height;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeImageOperation::visit(NodeImageOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::ImageOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpFragmentFetchAMD:
        if (visitor(reinterpret_cast<NodeOpFragmentFetchAMD *>(node)))
          return true;
        break;
      case Op::OpFragmentMaskFetchAMD:
        if (visitor(reinterpret_cast<NodeOpFragmentMaskFetchAMD *>(node)))
          return true;
        break;
      case Op::OpImage:
        if (visitor(reinterpret_cast<NodeOpImage *>(node)))
          return true;
        break;
      case Op::OpImageDrefGather:
        if (visitor(reinterpret_cast<NodeOpImageDrefGather *>(node)))
          return true;
        break;
      case Op::OpImageFetch:
        if (visitor(reinterpret_cast<NodeOpImageFetch *>(node)))
          return true;
        break;
      case Op::OpImageGather:
        if (visitor(reinterpret_cast<NodeOpImageGather *>(node)))
          return true;
        break;
      case Op::OpImageQueryFormat:
        if (visitor(reinterpret_cast<NodeOpImageQueryFormat *>(node)))
          return true;
        break;
      case Op::OpImageQueryLevels:
        if (visitor(reinterpret_cast<NodeOpImageQueryLevels *>(node)))
          return true;
        break;
      case Op::OpImageQueryLod:
        if (visitor(reinterpret_cast<NodeOpImageQueryLod *>(node)))
          return true;
        break;
      case Op::OpImageQueryOrder:
        if (visitor(reinterpret_cast<NodeOpImageQueryOrder *>(node)))
          return true;
        break;
      case Op::OpImageQuerySamples:
        if (visitor(reinterpret_cast<NodeOpImageQuerySamples *>(node)))
          return true;
        break;
      case Op::OpImageQuerySize:
        if (visitor(reinterpret_cast<NodeOpImageQuerySize *>(node)))
          return true;
        break;
      case Op::OpImageQuerySizeLod:
        if (visitor(reinterpret_cast<NodeOpImageQuerySizeLod *>(node)))
          return true;
        break;
      case Op::OpImageRead:
        if (visitor(reinterpret_cast<NodeOpImageRead *>(node)))
          return true;
        break;
      case Op::OpImageSampleDrefExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleDrefExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleDrefImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleDrefImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleFootprintNV:
        if (visitor(reinterpret_cast<NodeOpImageSampleFootprintNV *>(node)))
          return true;
        break;
      case Op::OpImageSampleImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleProjDrefExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleProjDrefExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleProjDrefImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleProjDrefImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleProjExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleProjExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSampleProjImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSampleProjImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseDrefGather:
        if (visitor(reinterpret_cast<NodeOpImageSparseDrefGather *>(node)))
          return true;
        break;
      case Op::OpImageSparseFetch:
        if (visitor(reinterpret_cast<NodeOpImageSparseFetch *>(node)))
          return true;
        break;
      case Op::OpImageSparseGather:
        if (visitor(reinterpret_cast<NodeOpImageSparseGather *>(node)))
          return true;
        break;
      case Op::OpImageSparseRead:
        if (visitor(reinterpret_cast<NodeOpImageSparseRead *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleDrefExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleDrefExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleDrefImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleDrefImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleProjDrefExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleProjDrefExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleProjDrefImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleProjDrefImplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleProjExplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleProjExplicitLod *>(node)))
          return true;
        break;
      case Op::OpImageSparseSampleProjImplicitLod:
        if (visitor(reinterpret_cast<NodeOpImageSparseSampleProjImplicitLod *>(node)))
          return true;
        break;
      case Op::OpSampledImage:
        if (visitor(reinterpret_cast<NodeOpSampledImage *>(node)))
          return true;
        break;
      case Op::OpSubgroupImageBlockReadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupImageBlockReadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupImageMediaBlockReadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupImageMediaBlockReadINTEL *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeMultinaryOperation : NodeOperation
{
  Id pCount;
  // operands can be more, this depends on the opcode
  NodePointer<NodeId> operands[4];
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeMultinaryOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpBitFieldInsert
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpBitFieldInsert;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> base;
  NodePointer<NodeId> insert;
  NodePointer<NodeId> offset;
  NodePointer<NodeId> count;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(insert);
    visitor(offset);
    visitor(count);
  }
  NodeOpBitFieldInsert() = default;
  ~NodeOpBitFieldInsert() = default;
  NodeOpBitFieldInsert(const NodeOpBitFieldInsert &) = delete;
  NodeOpBitFieldInsert &operator=(const NodeOpBitFieldInsert &) = delete;
  NodeOpBitFieldInsert(NodeOpBitFieldInsert &&) = delete;
  NodeOpBitFieldInsert &operator=(NodeOpBitFieldInsert &&) = delete;
  NodeOpBitFieldInsert(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> insert,
    NodePointer<NodeId> offset, NodePointer<NodeId> count)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->insert = insert;
    this->offset = offset;
    this->count = count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEnqueueKernel
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpEnqueueKernel;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 11;
  NodePointer<NodeId> queue;
  NodePointer<NodeId> flags;
  NodePointer<NodeId> ndRange;
  NodePointer<NodeId> numEvents;
  NodePointer<NodeId> waitEvents;
  NodePointer<NodeId> retEvent;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  eastl::vector<NodePointer<NodeId>> localSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(queue);
    visitor(flags);
    visitor(ndRange);
    visitor(numEvents);
    visitor(waitEvents);
    visitor(retEvent);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
    for (auto &&ref : localSize)
      visitor(ref);
  }
  NodeOpEnqueueKernel() = default;
  ~NodeOpEnqueueKernel() = default;
  NodeOpEnqueueKernel(const NodeOpEnqueueKernel &) = delete;
  NodeOpEnqueueKernel &operator=(const NodeOpEnqueueKernel &) = delete;
  NodeOpEnqueueKernel(NodeOpEnqueueKernel &&) = delete;
  NodeOpEnqueueKernel &operator=(NodeOpEnqueueKernel &&) = delete;
  NodeOpEnqueueKernel(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> queue, NodePointer<NodeId> flags,
    NodePointer<NodeId> n_d_range, NodePointer<NodeId> num_events, NodePointer<NodeId> wait_events, NodePointer<NodeId> ret_event,
    NodePointer<NodeId> invoke, NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align,
    NodePointer<NodeId> *local_size = nullptr, size_t local_size_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->queue = queue;
    this->flags = flags;
    this->ndRange = n_d_range;
    this->numEvents = num_events;
    this->waitEvents = wait_events;
    this->retEvent = ret_event;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
    this->localSize.assign(local_size, local_size + local_size_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpEnqueueMarker
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpEnqueueMarker;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> queue;
  NodePointer<NodeId> numEvents;
  NodePointer<NodeId> waitEvents;
  NodePointer<NodeId> retEvent;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(queue);
    visitor(numEvents);
    visitor(waitEvents);
    visitor(retEvent);
  }
  NodeOpEnqueueMarker() = default;
  ~NodeOpEnqueueMarker() = default;
  NodeOpEnqueueMarker(const NodeOpEnqueueMarker &) = delete;
  NodeOpEnqueueMarker &operator=(const NodeOpEnqueueMarker &) = delete;
  NodeOpEnqueueMarker(NodeOpEnqueueMarker &&) = delete;
  NodeOpEnqueueMarker &operator=(NodeOpEnqueueMarker &&) = delete;
  NodeOpEnqueueMarker(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> queue, NodePointer<NodeId> num_events,
    NodePointer<NodeId> wait_events, NodePointer<NodeId> ret_event)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->queue = queue;
    this->numEvents = num_events;
    this->waitEvents = wait_events;
    this->retEvent = ret_event;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFetchMicroTriangleVertexBarycentricNV
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpFetchMicroTriangleVertexBarycentricNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> primitiveIndex;
  NodePointer<NodeId> barycentric;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(accel);
    visitor(instanceId);
    visitor(geometryIndex);
    visitor(primitiveIndex);
    visitor(barycentric);
  }
  NodeOpFetchMicroTriangleVertexBarycentricNV() = default;
  ~NodeOpFetchMicroTriangleVertexBarycentricNV() = default;
  NodeOpFetchMicroTriangleVertexBarycentricNV(const NodeOpFetchMicroTriangleVertexBarycentricNV &) = delete;
  NodeOpFetchMicroTriangleVertexBarycentricNV &operator=(const NodeOpFetchMicroTriangleVertexBarycentricNV &) = delete;
  NodeOpFetchMicroTriangleVertexBarycentricNV(NodeOpFetchMicroTriangleVertexBarycentricNV &&) = delete;
  NodeOpFetchMicroTriangleVertexBarycentricNV &operator=(NodeOpFetchMicroTriangleVertexBarycentricNV &&) = delete;
  NodeOpFetchMicroTriangleVertexBarycentricNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> accel,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> geometry_index, NodePointer<NodeId> primitive_index,
    NodePointer<NodeId> barycentric)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->accel = accel;
    this->instanceId = instance_id;
    this->geometryIndex = geometry_index;
    this->primitiveIndex = primitive_index;
    this->barycentric = barycentric;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFetchMicroTriangleVertexPositionNV
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpFetchMicroTriangleVertexPositionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> accel;
  NodePointer<NodeId> instanceId;
  NodePointer<NodeId> geometryIndex;
  NodePointer<NodeId> primitiveIndex;
  NodePointer<NodeId> barycentric;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(accel);
    visitor(instanceId);
    visitor(geometryIndex);
    visitor(primitiveIndex);
    visitor(barycentric);
  }
  NodeOpFetchMicroTriangleVertexPositionNV() = default;
  ~NodeOpFetchMicroTriangleVertexPositionNV() = default;
  NodeOpFetchMicroTriangleVertexPositionNV(const NodeOpFetchMicroTriangleVertexPositionNV &) = delete;
  NodeOpFetchMicroTriangleVertexPositionNV &operator=(const NodeOpFetchMicroTriangleVertexPositionNV &) = delete;
  NodeOpFetchMicroTriangleVertexPositionNV(NodeOpFetchMicroTriangleVertexPositionNV &&) = delete;
  NodeOpFetchMicroTriangleVertexPositionNV &operator=(NodeOpFetchMicroTriangleVertexPositionNV &&) = delete;
  NodeOpFetchMicroTriangleVertexPositionNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> accel,
    NodePointer<NodeId> instance_id, NodePointer<NodeId> geometry_index, NodePointer<NodeId> primitive_index,
    NodePointer<NodeId> barycentric)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->accel = accel;
    this->instanceId = instance_id;
    this->geometryIndex = geometry_index;
    this->primitiveIndex = primitive_index;
    this->barycentric = barycentric;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelLocalSizeForSubgroupCount
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelLocalSizeForSubgroupCount;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> subgroupCount;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(subgroupCount);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelLocalSizeForSubgroupCount() = default;
  ~NodeOpGetKernelLocalSizeForSubgroupCount() = default;
  NodeOpGetKernelLocalSizeForSubgroupCount(const NodeOpGetKernelLocalSizeForSubgroupCount &) = delete;
  NodeOpGetKernelLocalSizeForSubgroupCount &operator=(const NodeOpGetKernelLocalSizeForSubgroupCount &) = delete;
  NodeOpGetKernelLocalSizeForSubgroupCount(NodeOpGetKernelLocalSizeForSubgroupCount &&) = delete;
  NodeOpGetKernelLocalSizeForSubgroupCount &operator=(NodeOpGetKernelLocalSizeForSubgroupCount &&) = delete;
  NodeOpGetKernelLocalSizeForSubgroupCount(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> subgroup_count,
    NodePointer<NodeId> invoke, NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->subgroupCount = subgroup_count;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelMaxNumSubgroups
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelMaxNumSubgroups;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelMaxNumSubgroups() = default;
  ~NodeOpGetKernelMaxNumSubgroups() = default;
  NodeOpGetKernelMaxNumSubgroups(const NodeOpGetKernelMaxNumSubgroups &) = delete;
  NodeOpGetKernelMaxNumSubgroups &operator=(const NodeOpGetKernelMaxNumSubgroups &) = delete;
  NodeOpGetKernelMaxNumSubgroups(NodeOpGetKernelMaxNumSubgroups &&) = delete;
  NodeOpGetKernelMaxNumSubgroups &operator=(NodeOpGetKernelMaxNumSubgroups &&) = delete;
  NodeOpGetKernelMaxNumSubgroups(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> invoke,
    NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelNDrangeMaxSubGroupSize
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelNDrangeMaxSubGroupSize;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> ndRange;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(ndRange);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelNDrangeMaxSubGroupSize() = default;
  ~NodeOpGetKernelNDrangeMaxSubGroupSize() = default;
  NodeOpGetKernelNDrangeMaxSubGroupSize(const NodeOpGetKernelNDrangeMaxSubGroupSize &) = delete;
  NodeOpGetKernelNDrangeMaxSubGroupSize &operator=(const NodeOpGetKernelNDrangeMaxSubGroupSize &) = delete;
  NodeOpGetKernelNDrangeMaxSubGroupSize(NodeOpGetKernelNDrangeMaxSubGroupSize &&) = delete;
  NodeOpGetKernelNDrangeMaxSubGroupSize &operator=(NodeOpGetKernelNDrangeMaxSubGroupSize &&) = delete;
  NodeOpGetKernelNDrangeMaxSubGroupSize(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> n_d_range,
    NodePointer<NodeId> invoke, NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->ndRange = n_d_range;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelNDrangeSubGroupCount
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelNDrangeSubGroupCount;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> ndRange;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(ndRange);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelNDrangeSubGroupCount() = default;
  ~NodeOpGetKernelNDrangeSubGroupCount() = default;
  NodeOpGetKernelNDrangeSubGroupCount(const NodeOpGetKernelNDrangeSubGroupCount &) = delete;
  NodeOpGetKernelNDrangeSubGroupCount &operator=(const NodeOpGetKernelNDrangeSubGroupCount &) = delete;
  NodeOpGetKernelNDrangeSubGroupCount(NodeOpGetKernelNDrangeSubGroupCount &&) = delete;
  NodeOpGetKernelNDrangeSubGroupCount &operator=(NodeOpGetKernelNDrangeSubGroupCount &&) = delete;
  NodeOpGetKernelNDrangeSubGroupCount(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> n_d_range,
    NodePointer<NodeId> invoke, NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->ndRange = n_d_range;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelPreferredWorkGroupSizeMultiple
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelPreferredWorkGroupSizeMultiple;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelPreferredWorkGroupSizeMultiple() = default;
  ~NodeOpGetKernelPreferredWorkGroupSizeMultiple() = default;
  NodeOpGetKernelPreferredWorkGroupSizeMultiple(const NodeOpGetKernelPreferredWorkGroupSizeMultiple &) = delete;
  NodeOpGetKernelPreferredWorkGroupSizeMultiple &operator=(const NodeOpGetKernelPreferredWorkGroupSizeMultiple &) = delete;
  NodeOpGetKernelPreferredWorkGroupSizeMultiple(NodeOpGetKernelPreferredWorkGroupSizeMultiple &&) = delete;
  NodeOpGetKernelPreferredWorkGroupSizeMultiple &operator=(NodeOpGetKernelPreferredWorkGroupSizeMultiple &&) = delete;
  NodeOpGetKernelPreferredWorkGroupSizeMultiple(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> invoke,
    NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetKernelWorkGroupSize
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpGetKernelWorkGroupSize;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> invoke;
  NodePointer<NodeId> param;
  NodePointer<NodeId> paramSize;
  NodePointer<NodeId> paramAlign;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(invoke);
    visitor(param);
    visitor(paramSize);
    visitor(paramAlign);
  }
  NodeOpGetKernelWorkGroupSize() = default;
  ~NodeOpGetKernelWorkGroupSize() = default;
  NodeOpGetKernelWorkGroupSize(const NodeOpGetKernelWorkGroupSize &) = delete;
  NodeOpGetKernelWorkGroupSize &operator=(const NodeOpGetKernelWorkGroupSize &) = delete;
  NodeOpGetKernelWorkGroupSize(NodeOpGetKernelWorkGroupSize &&) = delete;
  NodeOpGetKernelWorkGroupSize &operator=(NodeOpGetKernelWorkGroupSize &&) = delete;
  NodeOpGetKernelWorkGroupSize(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> invoke,
    NodePointer<NodeId> param, NodePointer<NodeId> param_size, NodePointer<NodeId> param_align)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->invoke = invoke;
    this->param = param;
    this->paramSize = param_size;
    this->paramAlign = param_align;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchGatherSADQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchGatherSADQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> targetSampledImage;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> referenceSampledImage;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(targetSampledImage);
    visitor(targetCoordinates);
    visitor(referenceSampledImage);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchGatherSADQCOM() = default;
  ~NodeOpImageBlockMatchGatherSADQCOM() = default;
  NodeOpImageBlockMatchGatherSADQCOM(const NodeOpImageBlockMatchGatherSADQCOM &) = delete;
  NodeOpImageBlockMatchGatherSADQCOM &operator=(const NodeOpImageBlockMatchGatherSADQCOM &) = delete;
  NodeOpImageBlockMatchGatherSADQCOM(NodeOpImageBlockMatchGatherSADQCOM &&) = delete;
  NodeOpImageBlockMatchGatherSADQCOM &operator=(NodeOpImageBlockMatchGatherSADQCOM &&) = delete;
  NodeOpImageBlockMatchGatherSADQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target_sampled_image,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference_sampled_image, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->targetSampledImage = target_sampled_image;
    this->targetCoordinates = target_coordinates;
    this->referenceSampledImage = reference_sampled_image;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchGatherSSDQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchGatherSSDQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> targetSampledImage;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> referenceSampledImage;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(targetSampledImage);
    visitor(targetCoordinates);
    visitor(referenceSampledImage);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchGatherSSDQCOM() = default;
  ~NodeOpImageBlockMatchGatherSSDQCOM() = default;
  NodeOpImageBlockMatchGatherSSDQCOM(const NodeOpImageBlockMatchGatherSSDQCOM &) = delete;
  NodeOpImageBlockMatchGatherSSDQCOM &operator=(const NodeOpImageBlockMatchGatherSSDQCOM &) = delete;
  NodeOpImageBlockMatchGatherSSDQCOM(NodeOpImageBlockMatchGatherSSDQCOM &&) = delete;
  NodeOpImageBlockMatchGatherSSDQCOM &operator=(NodeOpImageBlockMatchGatherSSDQCOM &&) = delete;
  NodeOpImageBlockMatchGatherSSDQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target_sampled_image,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference_sampled_image, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->targetSampledImage = target_sampled_image;
    this->targetCoordinates = target_coordinates;
    this->referenceSampledImage = reference_sampled_image;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchSADQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchSADQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> target;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> reference;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(target);
    visitor(targetCoordinates);
    visitor(reference);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchSADQCOM() = default;
  ~NodeOpImageBlockMatchSADQCOM() = default;
  NodeOpImageBlockMatchSADQCOM(const NodeOpImageBlockMatchSADQCOM &) = delete;
  NodeOpImageBlockMatchSADQCOM &operator=(const NodeOpImageBlockMatchSADQCOM &) = delete;
  NodeOpImageBlockMatchSADQCOM(NodeOpImageBlockMatchSADQCOM &&) = delete;
  NodeOpImageBlockMatchSADQCOM &operator=(NodeOpImageBlockMatchSADQCOM &&) = delete;
  NodeOpImageBlockMatchSADQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->target = target;
    this->targetCoordinates = target_coordinates;
    this->reference = reference;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchSSDQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchSSDQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> target;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> reference;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(target);
    visitor(targetCoordinates);
    visitor(reference);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchSSDQCOM() = default;
  ~NodeOpImageBlockMatchSSDQCOM() = default;
  NodeOpImageBlockMatchSSDQCOM(const NodeOpImageBlockMatchSSDQCOM &) = delete;
  NodeOpImageBlockMatchSSDQCOM &operator=(const NodeOpImageBlockMatchSSDQCOM &) = delete;
  NodeOpImageBlockMatchSSDQCOM(NodeOpImageBlockMatchSSDQCOM &&) = delete;
  NodeOpImageBlockMatchSSDQCOM &operator=(NodeOpImageBlockMatchSSDQCOM &&) = delete;
  NodeOpImageBlockMatchSSDQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->target = target;
    this->targetCoordinates = target_coordinates;
    this->reference = reference;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchWindowSADQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchWindowSADQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> targetSampledImage;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> referenceSampledImage;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(targetSampledImage);
    visitor(targetCoordinates);
    visitor(referenceSampledImage);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchWindowSADQCOM() = default;
  ~NodeOpImageBlockMatchWindowSADQCOM() = default;
  NodeOpImageBlockMatchWindowSADQCOM(const NodeOpImageBlockMatchWindowSADQCOM &) = delete;
  NodeOpImageBlockMatchWindowSADQCOM &operator=(const NodeOpImageBlockMatchWindowSADQCOM &) = delete;
  NodeOpImageBlockMatchWindowSADQCOM(NodeOpImageBlockMatchWindowSADQCOM &&) = delete;
  NodeOpImageBlockMatchWindowSADQCOM &operator=(NodeOpImageBlockMatchWindowSADQCOM &&) = delete;
  NodeOpImageBlockMatchWindowSADQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target_sampled_image,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference_sampled_image, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->targetSampledImage = target_sampled_image;
    this->targetCoordinates = target_coordinates;
    this->referenceSampledImage = reference_sampled_image;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBlockMatchWindowSSDQCOM
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpImageBlockMatchWindowSSDQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> targetSampledImage;
  NodePointer<NodeId> targetCoordinates;
  NodePointer<NodeId> referenceSampledImage;
  NodePointer<NodeId> referenceCoordinates;
  NodePointer<NodeId> blockSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(targetSampledImage);
    visitor(targetCoordinates);
    visitor(referenceSampledImage);
    visitor(referenceCoordinates);
    visitor(blockSize);
  }
  NodeOpImageBlockMatchWindowSSDQCOM() = default;
  ~NodeOpImageBlockMatchWindowSSDQCOM() = default;
  NodeOpImageBlockMatchWindowSSDQCOM(const NodeOpImageBlockMatchWindowSSDQCOM &) = delete;
  NodeOpImageBlockMatchWindowSSDQCOM &operator=(const NodeOpImageBlockMatchWindowSSDQCOM &) = delete;
  NodeOpImageBlockMatchWindowSSDQCOM(NodeOpImageBlockMatchWindowSSDQCOM &&) = delete;
  NodeOpImageBlockMatchWindowSSDQCOM &operator=(NodeOpImageBlockMatchWindowSSDQCOM &&) = delete;
  NodeOpImageBlockMatchWindowSSDQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> target_sampled_image,
    NodePointer<NodeId> target_coordinates, NodePointer<NodeId> reference_sampled_image, NodePointer<NodeId> reference_coordinates,
    NodePointer<NodeId> block_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->targetSampledImage = target_sampled_image;
    this->targetCoordinates = target_coordinates;
    this->referenceSampledImage = reference_sampled_image;
    this->referenceCoordinates = reference_coordinates;
    this->blockSize = block_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRawAccessChainNV
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpRawAccessChainNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> base;
  NodePointer<NodeId> byteStride;
  NodePointer<NodeId> elementIndex;
  NodePointer<NodeId> byteOffset;
  eastl::optional<RawAccessChainOperandsMask> rawAccessChainOperands;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(byteStride);
    visitor(elementIndex);
    visitor(byteOffset);
  }
  NodeOpRawAccessChainNV() = default;
  ~NodeOpRawAccessChainNV() = default;
  NodeOpRawAccessChainNV(const NodeOpRawAccessChainNV &) = delete;
  NodeOpRawAccessChainNV &operator=(const NodeOpRawAccessChainNV &) = delete;
  NodeOpRawAccessChainNV(NodeOpRawAccessChainNV &&) = delete;
  NodeOpRawAccessChainNV &operator=(NodeOpRawAccessChainNV &&) = delete;
  NodeOpRawAccessChainNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base,
    NodePointer<NodeId> byte_stride, NodePointer<NodeId> element_index, NodePointer<NodeId> byte_offset,
    eastl::optional<RawAccessChainOperandsMask> raw_access_chain_operands = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->byteStride = byte_stride;
    this->elementIndex = element_index;
    this->byteOffset = byte_offset;
    this->rawAccessChainOperands = raw_access_chain_operands;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReadPipe
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpReadPipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(pointer);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReadPipe() = default;
  ~NodeOpReadPipe() = default;
  NodeOpReadPipe(const NodeOpReadPipe &) = delete;
  NodeOpReadPipe &operator=(const NodeOpReadPipe &) = delete;
  NodeOpReadPipe(NodeOpReadPipe &&) = delete;
  NodeOpReadPipe &operator=(NodeOpReadPipe &&) = delete;
  NodeOpReadPipe(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe, NodePointer<NodeId> pointer,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->pointer = pointer;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReserveReadPipePackets
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpReserveReadPipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> numPackets;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(numPackets);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReserveReadPipePackets() = default;
  ~NodeOpReserveReadPipePackets() = default;
  NodeOpReserveReadPipePackets(const NodeOpReserveReadPipePackets &) = delete;
  NodeOpReserveReadPipePackets &operator=(const NodeOpReserveReadPipePackets &) = delete;
  NodeOpReserveReadPipePackets(NodeOpReserveReadPipePackets &&) = delete;
  NodeOpReserveReadPipePackets &operator=(NodeOpReserveReadPipePackets &&) = delete;
  NodeOpReserveReadPipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> num_packets, NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->numPackets = num_packets;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReserveWritePipePackets
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpReserveWritePipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> numPackets;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(numPackets);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReserveWritePipePackets() = default;
  ~NodeOpReserveWritePipePackets() = default;
  NodeOpReserveWritePipePackets(const NodeOpReserveWritePipePackets &) = delete;
  NodeOpReserveWritePipePackets &operator=(const NodeOpReserveWritePipePackets &) = delete;
  NodeOpReserveWritePipePackets(NodeOpReserveWritePipePackets &&) = delete;
  NodeOpReserveWritePipePackets &operator=(NodeOpReserveWritePipePackets &&) = delete;
  NodeOpReserveWritePipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> num_packets, NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->numPackets = num_packets;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReservedReadPipe
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpReservedReadPipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 6;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> index;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(reserveId);
    visitor(index);
    visitor(pointer);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReservedReadPipe() = default;
  ~NodeOpReservedReadPipe() = default;
  NodeOpReservedReadPipe(const NodeOpReservedReadPipe &) = delete;
  NodeOpReservedReadPipe &operator=(const NodeOpReservedReadPipe &) = delete;
  NodeOpReservedReadPipe(NodeOpReservedReadPipe &&) = delete;
  NodeOpReservedReadPipe &operator=(NodeOpReservedReadPipe &&) = delete;
  NodeOpReservedReadPipe(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> reserve_id, NodePointer<NodeId> index, NodePointer<NodeId> pointer, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->index = index;
    this->pointer = pointer;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReservedWritePipe
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpReservedWritePipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 6;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> reserveId;
  NodePointer<NodeId> index;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(reserveId);
    visitor(index);
    visitor(pointer);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpReservedWritePipe() = default;
  ~NodeOpReservedWritePipe() = default;
  NodeOpReservedWritePipe(const NodeOpReservedWritePipe &) = delete;
  NodeOpReservedWritePipe &operator=(const NodeOpReservedWritePipe &) = delete;
  NodeOpReservedWritePipe(NodeOpReservedWritePipe &&) = delete;
  NodeOpReservedWritePipe &operator=(NodeOpReservedWritePipe &&) = delete;
  NodeOpReservedWritePipe(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> reserve_id, NodePointer<NodeId> index, NodePointer<NodeId> pointer, NodePointer<NodeId> packet_size,
    NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->reserveId = reserve_id;
    this->index = index;
    this->pointer = pointer;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcBmeInitializeINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcBmeInitializeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 8;
  NodePointer<NodeId> srcCoord;
  NodePointer<NodeId> motionVectors;
  NodePointer<NodeId> majorShapes;
  NodePointer<NodeId> minorShapes;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> pixelResolution;
  NodePointer<NodeId> bidirectionalWeight;
  NodePointer<NodeId> sadAdjustment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcCoord);
    visitor(motionVectors);
    visitor(majorShapes);
    visitor(minorShapes);
    visitor(direction);
    visitor(pixelResolution);
    visitor(bidirectionalWeight);
    visitor(sadAdjustment);
  }
  NodeOpSubgroupAvcBmeInitializeINTEL() = default;
  ~NodeOpSubgroupAvcBmeInitializeINTEL() = default;
  NodeOpSubgroupAvcBmeInitializeINTEL(const NodeOpSubgroupAvcBmeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcBmeInitializeINTEL &operator=(const NodeOpSubgroupAvcBmeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcBmeInitializeINTEL(NodeOpSubgroupAvcBmeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcBmeInitializeINTEL &operator=(NodeOpSubgroupAvcBmeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcBmeInitializeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> src_coord,
    NodePointer<NodeId> motion_vectors, NodePointer<NodeId> major_shapes, NodePointer<NodeId> minor_shapes,
    NodePointer<NodeId> direction, NodePointer<NodeId> pixel_resolution, NodePointer<NodeId> bidirectional_weight,
    NodePointer<NodeId> sad_adjustment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcCoord = src_coord;
    this->motionVectors = motion_vectors;
    this->majorShapes = major_shapes;
    this->minorShapes = minor_shapes;
    this->direction = direction;
    this->pixelResolution = pixel_resolution;
    this->bidirectionalWeight = bidirectional_weight;
    this->sadAdjustment = sad_adjustment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcFmeInitializeINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcFmeInitializeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 7;
  NodePointer<NodeId> srcCoord;
  NodePointer<NodeId> motionVectors;
  NodePointer<NodeId> majorShapes;
  NodePointer<NodeId> minorShapes;
  NodePointer<NodeId> direction;
  NodePointer<NodeId> pixelResolution;
  NodePointer<NodeId> sadAdjustment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcCoord);
    visitor(motionVectors);
    visitor(majorShapes);
    visitor(minorShapes);
    visitor(direction);
    visitor(pixelResolution);
    visitor(sadAdjustment);
  }
  NodeOpSubgroupAvcFmeInitializeINTEL() = default;
  ~NodeOpSubgroupAvcFmeInitializeINTEL() = default;
  NodeOpSubgroupAvcFmeInitializeINTEL(const NodeOpSubgroupAvcFmeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcFmeInitializeINTEL &operator=(const NodeOpSubgroupAvcFmeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcFmeInitializeINTEL(NodeOpSubgroupAvcFmeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcFmeInitializeINTEL &operator=(NodeOpSubgroupAvcFmeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcFmeInitializeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> src_coord,
    NodePointer<NodeId> motion_vectors, NodePointer<NodeId> major_shapes, NodePointer<NodeId> minor_shapes,
    NodePointer<NodeId> direction, NodePointer<NodeId> pixel_resolution, NodePointer<NodeId> sad_adjustment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcCoord = src_coord;
    this->motionVectors = motion_vectors;
    this->majorShapes = major_shapes;
    this->minorShapes = minor_shapes;
    this->direction = direction;
    this->pixelResolution = pixel_resolution;
    this->sadAdjustment = sad_adjustment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeAdjustRefOffsetINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeAdjustRefOffsetINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> refOffset;
  NodePointer<NodeId> srcCoord;
  NodePointer<NodeId> refWindowSize;
  NodePointer<NodeId> imageSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(refOffset);
    visitor(srcCoord);
    visitor(refWindowSize);
    visitor(imageSize);
  }
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL() = default;
  ~NodeOpSubgroupAvcImeAdjustRefOffsetINTEL() = default;
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL(const NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &) = delete;
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &operator=(const NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &) = delete;
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL(NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &&) = delete;
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &operator=(NodeOpSubgroupAvcImeAdjustRefOffsetINTEL &&) = delete;
  NodeOpSubgroupAvcImeAdjustRefOffsetINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ref_offset,
    NodePointer<NodeId> src_coord, NodePointer<NodeId> ref_window_size, NodePointer<NodeId> image_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->refOffset = ref_offset;
    this->srcCoord = src_coord;
    this->refWindowSize = ref_window_size;
    this->imageSize = image_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithDualReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL(const NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &operator=(const NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL(NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &operator=(NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> streaminComponents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
    visitor(streaminComponents);
  }
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload,
    NodePointer<NodeId> streamin_components)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
    this->streaminComponents = streamin_components;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 5;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> streaminComponents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
    visitor(streaminComponents);
  }
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(
    NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload,
    NodePointer<NodeId> streamin_components)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
    this->streaminComponents = streamin_components;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> streaminComponents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
    visitor(streaminComponents);
  }
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload, NodePointer<NodeId> streamin_components)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
    this->streaminComponents = streamin_components;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> streaminComponents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
    visitor(streaminComponents);
  }
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload, NodePointer<NodeId> streamin_components)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
    this->streaminComponents = streamin_components;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetDualReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetDualReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> fwdRefOffset;
  NodePointer<NodeId> bwdRefOffset;
  NodePointer<NodeId> idSearchWindowConfig;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(fwdRefOffset);
    visitor(bwdRefOffset);
    visitor(idSearchWindowConfig);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetDualReferenceINTEL() = default;
  ~NodeOpSubgroupAvcImeSetDualReferenceINTEL() = default;
  NodeOpSubgroupAvcImeSetDualReferenceINTEL(const NodeOpSubgroupAvcImeSetDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeSetDualReferenceINTEL &operator=(const NodeOpSubgroupAvcImeSetDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeSetDualReferenceINTEL(NodeOpSubgroupAvcImeSetDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetDualReferenceINTEL &operator=(NodeOpSubgroupAvcImeSetDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetDualReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> fwd_ref_offset,
    NodePointer<NodeId> bwd_ref_offset, NodePointer<NodeId> id_search_window_config, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->fwdRefOffset = fwd_ref_offset;
    this->bwdRefOffset = bwd_ref_offset;
    this->idSearchWindowConfig = id_search_window_config;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> packedCostCenterDelta;
  NodePointer<NodeId> packedCostTable;
  NodePointer<NodeId> costPrecision;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedCostCenterDelta);
    visitor(packedCostTable);
    visitor(costPrecision);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL() = default;
  ~NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL() = default;
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(const NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &operator=(
    const NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &operator=(NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_cost_center_delta, NodePointer<NodeId> packed_cost_table, NodePointer<NodeId> cost_precision,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedCostCenterDelta = packed_cost_center_delta;
    this->packedCostTable = packed_cost_table;
    this->costPrecision = cost_precision;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefEvaluateWithDualReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL() = default;
  ~NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL() = default;
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL(const NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &operator=(const NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL(NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &operator=(NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> packedReferenceIds;
  NodePointer<NodeId> packedReferenceFieldPolarities;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(packedReferenceIds);
    visitor(packedReferenceFieldPolarities);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL() = default;
  ~NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL() = default;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(
    const NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &operator=(
    const NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(
    NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &operator=(
    NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> packed_reference_ids, NodePointer<NodeId> packed_reference_field_polarities,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->packedReferenceIds = packed_reference_ids;
    this->packedReferenceFieldPolarities = packed_reference_field_polarities;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicConfigureIpeLumaChromaINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 11;
  NodePointer<NodeId> lumaIntraPartitionMask;
  NodePointer<NodeId> intraNeighbourAvailabilty;
  NodePointer<NodeId> leftEdgeLumaPixels;
  NodePointer<NodeId> upperLeftCornerLumaPixel;
  NodePointer<NodeId> upperEdgeLumaPixels;
  NodePointer<NodeId> upperRightEdgeLumaPixels;
  NodePointer<NodeId> leftEdgeChromaPixels;
  NodePointer<NodeId> upperLeftCornerChromaPixel;
  NodePointer<NodeId> upperEdgeChromaPixels;
  NodePointer<NodeId> sadAdjustment;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(lumaIntraPartitionMask);
    visitor(intraNeighbourAvailabilty);
    visitor(leftEdgeLumaPixels);
    visitor(upperLeftCornerLumaPixel);
    visitor(upperEdgeLumaPixels);
    visitor(upperRightEdgeLumaPixels);
    visitor(leftEdgeChromaPixels);
    visitor(upperLeftCornerChromaPixel);
    visitor(upperEdgeChromaPixels);
    visitor(sadAdjustment);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL() = default;
  ~NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL() = default;
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL(const NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &operator=(const NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL(NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &operator=(NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> luma_intra_partition_mask, NodePointer<NodeId> intra_neighbour_availabilty,
    NodePointer<NodeId> left_edge_luma_pixels, NodePointer<NodeId> upper_left_corner_luma_pixel,
    NodePointer<NodeId> upper_edge_luma_pixels, NodePointer<NodeId> upper_right_edge_luma_pixels,
    NodePointer<NodeId> left_edge_chroma_pixels, NodePointer<NodeId> upper_left_corner_chroma_pixel,
    NodePointer<NodeId> upper_edge_chroma_pixels, NodePointer<NodeId> sad_adjustment, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->lumaIntraPartitionMask = luma_intra_partition_mask;
    this->intraNeighbourAvailabilty = intra_neighbour_availabilty;
    this->leftEdgeLumaPixels = left_edge_luma_pixels;
    this->upperLeftCornerLumaPixel = upper_left_corner_luma_pixel;
    this->upperEdgeLumaPixels = upper_edge_luma_pixels;
    this->upperRightEdgeLumaPixels = upper_right_edge_luma_pixels;
    this->leftEdgeChromaPixels = left_edge_chroma_pixels;
    this->upperLeftCornerChromaPixel = upper_left_corner_chroma_pixel;
    this->upperEdgeChromaPixels = upper_edge_chroma_pixels;
    this->sadAdjustment = sad_adjustment;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicConfigureIpeLumaINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicConfigureIpeLumaINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 8;
  NodePointer<NodeId> lumaIntraPartitionMask;
  NodePointer<NodeId> intraNeighbourAvailabilty;
  NodePointer<NodeId> leftEdgeLumaPixels;
  NodePointer<NodeId> upperLeftCornerLumaPixel;
  NodePointer<NodeId> upperEdgeLumaPixels;
  NodePointer<NodeId> upperRightEdgeLumaPixels;
  NodePointer<NodeId> sadAdjustment;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(lumaIntraPartitionMask);
    visitor(intraNeighbourAvailabilty);
    visitor(leftEdgeLumaPixels);
    visitor(upperLeftCornerLumaPixel);
    visitor(upperEdgeLumaPixels);
    visitor(upperRightEdgeLumaPixels);
    visitor(sadAdjustment);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL() = default;
  ~NodeOpSubgroupAvcSicConfigureIpeLumaINTEL() = default;
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL(const NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &operator=(const NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL(NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &operator=(NodeOpSubgroupAvcSicConfigureIpeLumaINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureIpeLumaINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> luma_intra_partition_mask, NodePointer<NodeId> intra_neighbour_availabilty,
    NodePointer<NodeId> left_edge_luma_pixels, NodePointer<NodeId> upper_left_corner_luma_pixel,
    NodePointer<NodeId> upper_edge_luma_pixels, NodePointer<NodeId> upper_right_edge_luma_pixels, NodePointer<NodeId> sad_adjustment,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->lumaIntraPartitionMask = luma_intra_partition_mask;
    this->intraNeighbourAvailabilty = intra_neighbour_availabilty;
    this->leftEdgeLumaPixels = left_edge_luma_pixels;
    this->upperLeftCornerLumaPixel = upper_left_corner_luma_pixel;
    this->upperEdgeLumaPixels = upper_edge_luma_pixels;
    this->upperRightEdgeLumaPixels = upper_right_edge_luma_pixels;
    this->sadAdjustment = sad_adjustment;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicConfigureSkcINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicConfigureSkcINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 6;
  NodePointer<NodeId> skipBlockPartitionType;
  NodePointer<NodeId> skipMotionVectorMask;
  NodePointer<NodeId> motionVectors;
  NodePointer<NodeId> bidirectionalWeight;
  NodePointer<NodeId> sadAdjustment;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(skipBlockPartitionType);
    visitor(skipMotionVectorMask);
    visitor(motionVectors);
    visitor(bidirectionalWeight);
    visitor(sadAdjustment);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicConfigureSkcINTEL() = default;
  ~NodeOpSubgroupAvcSicConfigureSkcINTEL() = default;
  NodeOpSubgroupAvcSicConfigureSkcINTEL(const NodeOpSubgroupAvcSicConfigureSkcINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureSkcINTEL &operator=(const NodeOpSubgroupAvcSicConfigureSkcINTEL &) = delete;
  NodeOpSubgroupAvcSicConfigureSkcINTEL(NodeOpSubgroupAvcSicConfigureSkcINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureSkcINTEL &operator=(NodeOpSubgroupAvcSicConfigureSkcINTEL &&) = delete;
  NodeOpSubgroupAvcSicConfigureSkcINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> skip_block_partition_type, NodePointer<NodeId> skip_motion_vector_mask, NodePointer<NodeId> motion_vectors,
    NodePointer<NodeId> bidirectional_weight, NodePointer<NodeId> sad_adjustment, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->skipBlockPartitionType = skip_block_partition_type;
    this->skipMotionVectorMask = skip_motion_vector_mask;
    this->motionVectors = motion_vectors;
    this->bidirectionalWeight = bidirectional_weight;
    this->sadAdjustment = sad_adjustment;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicEvaluateWithDualReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> fwdRefImage;
  NodePointer<NodeId> bwdRefImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(fwdRefImage);
    visitor(bwdRefImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL() = default;
  ~NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL() = default;
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL(const NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &operator=(const NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL(NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &operator=(NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> fwd_ref_image, NodePointer<NodeId> bwd_ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->fwdRefImage = fwd_ref_image;
    this->bwdRefImage = bwd_ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> packedReferenceIds;
  NodePointer<NodeId> packedReferenceFieldPolarities;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(packedReferenceIds);
    visitor(packedReferenceFieldPolarities);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL() = default;
  ~NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL() = default;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(
    const NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &operator=(
    const NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(
    NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &operator=(
    NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> packed_reference_ids, NodePointer<NodeId> packed_reference_field_polarities,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->packedReferenceIds = packed_reference_ids;
    this->packedReferenceFieldPolarities = packed_reference_field_polarities;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> lumaModePenalty;
  NodePointer<NodeId> lumaPackedNeighborModes;
  NodePointer<NodeId> lumaPackedNonDcPenalty;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(lumaModePenalty);
    visitor(lumaPackedNeighborModes);
    visitor(lumaPackedNonDcPenalty);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL() = default;
  ~NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL() = default;
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(const NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &operator=(
    const NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &operator=(NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> luma_mode_penalty, NodePointer<NodeId> luma_packed_neighbor_modes,
    NodePointer<NodeId> luma_packed_non_dc_penalty, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->lumaModePenalty = luma_mode_penalty;
    this->lumaPackedNeighborModes = luma_packed_neighbor_modes;
    this->lumaPackedNonDcPenalty = luma_packed_non_dc_penalty;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpWritePipe
{
  const NodeKind nodeKind = NodeKind::MultinaryOperation;
  const Op opCode = Op::OpWritePipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  const Id pCount = 4;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(pointer);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpWritePipe() = default;
  ~NodeOpWritePipe() = default;
  NodeOpWritePipe(const NodeOpWritePipe &) = delete;
  NodeOpWritePipe &operator=(const NodeOpWritePipe &) = delete;
  NodeOpWritePipe(NodeOpWritePipe &&) = delete;
  NodeOpWritePipe &operator=(NodeOpWritePipe &&) = delete;
  NodeOpWritePipe(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe, NodePointer<NodeId> pointer,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->pointer = pointer;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeMultinaryOperation::visit(NodeMultinaryOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::MultinaryOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpBitFieldInsert:
        if (visitor(reinterpret_cast<NodeOpBitFieldInsert *>(node)))
          return true;
        break;
      case Op::OpEnqueueKernel:
        if (visitor(reinterpret_cast<NodeOpEnqueueKernel *>(node)))
          return true;
        break;
      case Op::OpEnqueueMarker:
        if (visitor(reinterpret_cast<NodeOpEnqueueMarker *>(node)))
          return true;
        break;
      case Op::OpFetchMicroTriangleVertexBarycentricNV:
        if (visitor(reinterpret_cast<NodeOpFetchMicroTriangleVertexBarycentricNV *>(node)))
          return true;
        break;
      case Op::OpFetchMicroTriangleVertexPositionNV:
        if (visitor(reinterpret_cast<NodeOpFetchMicroTriangleVertexPositionNV *>(node)))
          return true;
        break;
      case Op::OpGetKernelLocalSizeForSubgroupCount:
        if (visitor(reinterpret_cast<NodeOpGetKernelLocalSizeForSubgroupCount *>(node)))
          return true;
        break;
      case Op::OpGetKernelMaxNumSubgroups:
        if (visitor(reinterpret_cast<NodeOpGetKernelMaxNumSubgroups *>(node)))
          return true;
        break;
      case Op::OpGetKernelNDrangeMaxSubGroupSize:
        if (visitor(reinterpret_cast<NodeOpGetKernelNDrangeMaxSubGroupSize *>(node)))
          return true;
        break;
      case Op::OpGetKernelNDrangeSubGroupCount:
        if (visitor(reinterpret_cast<NodeOpGetKernelNDrangeSubGroupCount *>(node)))
          return true;
        break;
      case Op::OpGetKernelPreferredWorkGroupSizeMultiple:
        if (visitor(reinterpret_cast<NodeOpGetKernelPreferredWorkGroupSizeMultiple *>(node)))
          return true;
        break;
      case Op::OpGetKernelWorkGroupSize:
        if (visitor(reinterpret_cast<NodeOpGetKernelWorkGroupSize *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchGatherSADQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchGatherSADQCOM *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchGatherSSDQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchGatherSSDQCOM *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchSADQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchSADQCOM *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchSSDQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchSSDQCOM *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchWindowSADQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchWindowSADQCOM *>(node)))
          return true;
        break;
      case Op::OpImageBlockMatchWindowSSDQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBlockMatchWindowSSDQCOM *>(node)))
          return true;
        break;
      case Op::OpRawAccessChainNV:
        if (visitor(reinterpret_cast<NodeOpRawAccessChainNV *>(node)))
          return true;
        break;
      case Op::OpReadPipe:
        if (visitor(reinterpret_cast<NodeOpReadPipe *>(node)))
          return true;
        break;
      case Op::OpReserveReadPipePackets:
        if (visitor(reinterpret_cast<NodeOpReserveReadPipePackets *>(node)))
          return true;
        break;
      case Op::OpReserveWritePipePackets:
        if (visitor(reinterpret_cast<NodeOpReserveWritePipePackets *>(node)))
          return true;
        break;
      case Op::OpReservedReadPipe:
        if (visitor(reinterpret_cast<NodeOpReservedReadPipe *>(node)))
          return true;
        break;
      case Op::OpReservedWritePipe:
        if (visitor(reinterpret_cast<NodeOpReservedWritePipe *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcBmeInitializeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcBmeInitializeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcFmeInitializeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcFmeInitializeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeAdjustRefOffsetINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeAdjustRefOffsetINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithDualReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetDualReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetDualReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefEvaluateWithDualReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicConfigureIpeLumaChromaINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicConfigureIpeLumaINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicConfigureIpeLumaINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicConfigureSkcINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicConfigureSkcINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicEvaluateWithDualReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL *>(node)))
          return true;
        break;
      case Op::OpWritePipe:
        if (visitor(reinterpret_cast<NodeOpWritePipe *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodePhi : NodeOperation
{
  struct SourceInfo
  {
    NodePointer<NodeBlock> block;
    NodePointer<NodeOperation> source;
  };
  eastl::vector<SourceInfo> sources;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodePhi *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpPhi
{
  const NodeKind nodeKind = NodeKind::Phi;
  const Op opCode = Op::OpPhi;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  struct SourceInfo
  {
    NodePointer<NodeBlock> block;
    NodePointer<NodeOperation> source;
  };
  eastl::vector<SourceInfo> sources;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&s : sources)
    {
      visitor(s.block);
      visitor(s.source);
    }
  }
  NodeOpPhi() = default;
  ~NodeOpPhi() = default;
  NodeOpPhi(const NodeOpPhi &) = delete;
  NodeOpPhi &operator=(const NodeOpPhi &) = delete;
  NodeOpPhi(NodeOpPhi &&) = delete;
  NodeOpPhi &operator=(NodeOpPhi &&) = delete;
  NodeOpPhi(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePairIdRefIdRef *variable_parent = nullptr,
    size_t variable_parent_count = 0)
  {
    resultId = id_result;
    resultType = id_result_type;
    sources.reserve(variable_parent_count);
    for (int i = 0; i < variable_parent_count; ++i)
    {
      SourceInfo info;
      info.source = variable_parent[i].first;
      info.block = variable_parent[i].second;
      sources.push_back(info);
    }
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodePhi::visit(NodePhi *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpPhi *>(node)))
    return true;
  return visitor(node);
}
struct NodeScopedOperation : NodeOperation
{
  NodePointer<NodeOperation> scope;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeScopedOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpGroupAll
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupAll;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(predicate);
  }
  NodeOpGroupAll() = default;
  ~NodeOpGroupAll() = default;
  NodeOpGroupAll(const NodeOpGroupAll &) = delete;
  NodeOpGroupAll &operator=(const NodeOpGroupAll &) = delete;
  NodeOpGroupAll(NodeOpGroupAll &&) = delete;
  NodeOpGroupAll &operator=(NodeOpGroupAll &&) = delete;
  NodeOpGroupAll(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupAny
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupAny;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(predicate);
  }
  NodeOpGroupAny() = default;
  ~NodeOpGroupAny() = default;
  NodeOpGroupAny(const NodeOpGroupAny &) = delete;
  NodeOpGroupAny &operator=(const NodeOpGroupAny &) = delete;
  NodeOpGroupAny(NodeOpGroupAny &&) = delete;
  NodeOpGroupAny &operator=(NodeOpGroupAny &&) = delete;
  NodeOpGroupAny(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupAsyncCopy
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupAsyncCopy;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> destination;
  NodePointer<NodeId> source;
  NodePointer<NodeId> numElements;
  NodePointer<NodeId> stride;
  NodePointer<NodeId> event;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(destination);
    visitor(source);
    visitor(numElements);
    visitor(stride);
    visitor(event);
  }
  NodeOpGroupAsyncCopy() = default;
  ~NodeOpGroupAsyncCopy() = default;
  NodeOpGroupAsyncCopy(const NodeOpGroupAsyncCopy &) = delete;
  NodeOpGroupAsyncCopy &operator=(const NodeOpGroupAsyncCopy &) = delete;
  NodeOpGroupAsyncCopy(NodeOpGroupAsyncCopy &&) = delete;
  NodeOpGroupAsyncCopy &operator=(NodeOpGroupAsyncCopy &&) = delete;
  NodeOpGroupAsyncCopy(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> destination, NodePointer<NodeId> source, NodePointer<NodeId> num_elements, NodePointer<NodeId> stride,
    NodePointer<NodeId> event)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->destination = destination;
    this->source = source;
    this->numElements = num_elements;
    this->stride = stride;
    this->event = event;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupBroadcast
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupBroadcast;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> localId;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(localId);
  }
  NodeOpGroupBroadcast() = default;
  ~NodeOpGroupBroadcast() = default;
  NodeOpGroupBroadcast(const NodeOpGroupBroadcast &) = delete;
  NodeOpGroupBroadcast &operator=(const NodeOpGroupBroadcast &) = delete;
  NodeOpGroupBroadcast(NodeOpGroupBroadcast &&) = delete;
  NodeOpGroupBroadcast &operator=(NodeOpGroupBroadcast &&) = delete;
  NodeOpGroupBroadcast(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> local_id)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->localId = local_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformAll
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformAll;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(predicate);
  }
  NodeOpGroupNonUniformAll() = default;
  ~NodeOpGroupNonUniformAll() = default;
  NodeOpGroupNonUniformAll(const NodeOpGroupNonUniformAll &) = delete;
  NodeOpGroupNonUniformAll &operator=(const NodeOpGroupNonUniformAll &) = delete;
  NodeOpGroupNonUniformAll(NodeOpGroupNonUniformAll &&) = delete;
  NodeOpGroupNonUniformAll &operator=(NodeOpGroupNonUniformAll &&) = delete;
  NodeOpGroupNonUniformAll(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformAllEqual
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformAllEqual;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformAllEqual() = default;
  ~NodeOpGroupNonUniformAllEqual() = default;
  NodeOpGroupNonUniformAllEqual(const NodeOpGroupNonUniformAllEqual &) = delete;
  NodeOpGroupNonUniformAllEqual &operator=(const NodeOpGroupNonUniformAllEqual &) = delete;
  NodeOpGroupNonUniformAllEqual(NodeOpGroupNonUniformAllEqual &&) = delete;
  NodeOpGroupNonUniformAllEqual &operator=(NodeOpGroupNonUniformAllEqual &&) = delete;
  NodeOpGroupNonUniformAllEqual(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformAny
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformAny;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(predicate);
  }
  NodeOpGroupNonUniformAny() = default;
  ~NodeOpGroupNonUniformAny() = default;
  NodeOpGroupNonUniformAny(const NodeOpGroupNonUniformAny &) = delete;
  NodeOpGroupNonUniformAny &operator=(const NodeOpGroupNonUniformAny &) = delete;
  NodeOpGroupNonUniformAny(NodeOpGroupNonUniformAny &&) = delete;
  NodeOpGroupNonUniformAny &operator=(NodeOpGroupNonUniformAny &&) = delete;
  NodeOpGroupNonUniformAny(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBallot
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBallot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(predicate);
  }
  NodeOpGroupNonUniformBallot() = default;
  ~NodeOpGroupNonUniformBallot() = default;
  NodeOpGroupNonUniformBallot(const NodeOpGroupNonUniformBallot &) = delete;
  NodeOpGroupNonUniformBallot &operator=(const NodeOpGroupNonUniformBallot &) = delete;
  NodeOpGroupNonUniformBallot(NodeOpGroupNonUniformBallot &&) = delete;
  NodeOpGroupNonUniformBallot &operator=(NodeOpGroupNonUniformBallot &&) = delete;
  NodeOpGroupNonUniformBallot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBallotBitExtract
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBallotBitExtract;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> index;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(index);
  }
  NodeOpGroupNonUniformBallotBitExtract() = default;
  ~NodeOpGroupNonUniformBallotBitExtract() = default;
  NodeOpGroupNonUniformBallotBitExtract(const NodeOpGroupNonUniformBallotBitExtract &) = delete;
  NodeOpGroupNonUniformBallotBitExtract &operator=(const NodeOpGroupNonUniformBallotBitExtract &) = delete;
  NodeOpGroupNonUniformBallotBitExtract(NodeOpGroupNonUniformBallotBitExtract &&) = delete;
  NodeOpGroupNonUniformBallotBitExtract &operator=(NodeOpGroupNonUniformBallotBitExtract &&) = delete;
  NodeOpGroupNonUniformBallotBitExtract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->index = index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBallotFindLSB
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBallotFindLSB;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformBallotFindLSB() = default;
  ~NodeOpGroupNonUniformBallotFindLSB() = default;
  NodeOpGroupNonUniformBallotFindLSB(const NodeOpGroupNonUniformBallotFindLSB &) = delete;
  NodeOpGroupNonUniformBallotFindLSB &operator=(const NodeOpGroupNonUniformBallotFindLSB &) = delete;
  NodeOpGroupNonUniformBallotFindLSB(NodeOpGroupNonUniformBallotFindLSB &&) = delete;
  NodeOpGroupNonUniformBallotFindLSB &operator=(NodeOpGroupNonUniformBallotFindLSB &&) = delete;
  NodeOpGroupNonUniformBallotFindLSB(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBallotFindMSB
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBallotFindMSB;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformBallotFindMSB() = default;
  ~NodeOpGroupNonUniformBallotFindMSB() = default;
  NodeOpGroupNonUniformBallotFindMSB(const NodeOpGroupNonUniformBallotFindMSB &) = delete;
  NodeOpGroupNonUniformBallotFindMSB &operator=(const NodeOpGroupNonUniformBallotFindMSB &) = delete;
  NodeOpGroupNonUniformBallotFindMSB(NodeOpGroupNonUniformBallotFindMSB &&) = delete;
  NodeOpGroupNonUniformBallotFindMSB &operator=(NodeOpGroupNonUniformBallotFindMSB &&) = delete;
  NodeOpGroupNonUniformBallotFindMSB(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBroadcast
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBroadcast;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> id;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(id);
  }
  NodeOpGroupNonUniformBroadcast() = default;
  ~NodeOpGroupNonUniformBroadcast() = default;
  NodeOpGroupNonUniformBroadcast(const NodeOpGroupNonUniformBroadcast &) = delete;
  NodeOpGroupNonUniformBroadcast &operator=(const NodeOpGroupNonUniformBroadcast &) = delete;
  NodeOpGroupNonUniformBroadcast(NodeOpGroupNonUniformBroadcast &&) = delete;
  NodeOpGroupNonUniformBroadcast &operator=(NodeOpGroupNonUniformBroadcast &&) = delete;
  NodeOpGroupNonUniformBroadcast(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> id)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->id = id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBroadcastFirst
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformBroadcastFirst;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformBroadcastFirst() = default;
  ~NodeOpGroupNonUniformBroadcastFirst() = default;
  NodeOpGroupNonUniformBroadcastFirst(const NodeOpGroupNonUniformBroadcastFirst &) = delete;
  NodeOpGroupNonUniformBroadcastFirst &operator=(const NodeOpGroupNonUniformBroadcastFirst &) = delete;
  NodeOpGroupNonUniformBroadcastFirst(NodeOpGroupNonUniformBroadcastFirst &&) = delete;
  NodeOpGroupNonUniformBroadcastFirst &operator=(NodeOpGroupNonUniformBroadcastFirst &&) = delete;
  NodeOpGroupNonUniformBroadcastFirst(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformElect
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformElect;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
  }
  NodeOpGroupNonUniformElect() = default;
  ~NodeOpGroupNonUniformElect() = default;
  NodeOpGroupNonUniformElect(const NodeOpGroupNonUniformElect &) = delete;
  NodeOpGroupNonUniformElect &operator=(const NodeOpGroupNonUniformElect &) = delete;
  NodeOpGroupNonUniformElect(NodeOpGroupNonUniformElect &&) = delete;
  NodeOpGroupNonUniformElect &operator=(NodeOpGroupNonUniformElect &&) = delete;
  NodeOpGroupNonUniformElect(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformInverseBallot
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformInverseBallot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformInverseBallot() = default;
  ~NodeOpGroupNonUniformInverseBallot() = default;
  NodeOpGroupNonUniformInverseBallot(const NodeOpGroupNonUniformInverseBallot &) = delete;
  NodeOpGroupNonUniformInverseBallot &operator=(const NodeOpGroupNonUniformInverseBallot &) = delete;
  NodeOpGroupNonUniformInverseBallot(NodeOpGroupNonUniformInverseBallot &&) = delete;
  NodeOpGroupNonUniformInverseBallot &operator=(NodeOpGroupNonUniformInverseBallot &&) = delete;
  NodeOpGroupNonUniformInverseBallot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformQuadBroadcast
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformQuadBroadcast;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> index;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(index);
  }
  NodeOpGroupNonUniformQuadBroadcast() = default;
  ~NodeOpGroupNonUniformQuadBroadcast() = default;
  NodeOpGroupNonUniformQuadBroadcast(const NodeOpGroupNonUniformQuadBroadcast &) = delete;
  NodeOpGroupNonUniformQuadBroadcast &operator=(const NodeOpGroupNonUniformQuadBroadcast &) = delete;
  NodeOpGroupNonUniformQuadBroadcast(NodeOpGroupNonUniformQuadBroadcast &&) = delete;
  NodeOpGroupNonUniformQuadBroadcast &operator=(NodeOpGroupNonUniformQuadBroadcast &&) = delete;
  NodeOpGroupNonUniformQuadBroadcast(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->index = index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformQuadSwap
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformQuadSwap;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> direction;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(direction);
  }
  NodeOpGroupNonUniformQuadSwap() = default;
  ~NodeOpGroupNonUniformQuadSwap() = default;
  NodeOpGroupNonUniformQuadSwap(const NodeOpGroupNonUniformQuadSwap &) = delete;
  NodeOpGroupNonUniformQuadSwap &operator=(const NodeOpGroupNonUniformQuadSwap &) = delete;
  NodeOpGroupNonUniformQuadSwap(NodeOpGroupNonUniformQuadSwap &&) = delete;
  NodeOpGroupNonUniformQuadSwap &operator=(NodeOpGroupNonUniformQuadSwap &&) = delete;
  NodeOpGroupNonUniformQuadSwap(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> direction)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->direction = direction;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformRotateKHR
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformRotateKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> delta;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(delta);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformRotateKHR() = default;
  ~NodeOpGroupNonUniformRotateKHR() = default;
  NodeOpGroupNonUniformRotateKHR(const NodeOpGroupNonUniformRotateKHR &) = delete;
  NodeOpGroupNonUniformRotateKHR &operator=(const NodeOpGroupNonUniformRotateKHR &) = delete;
  NodeOpGroupNonUniformRotateKHR(NodeOpGroupNonUniformRotateKHR &&) = delete;
  NodeOpGroupNonUniformRotateKHR &operator=(NodeOpGroupNonUniformRotateKHR &&) = delete;
  NodeOpGroupNonUniformRotateKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> delta, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->delta = delta;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformShuffle
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformShuffle;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> id;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(id);
  }
  NodeOpGroupNonUniformShuffle() = default;
  ~NodeOpGroupNonUniformShuffle() = default;
  NodeOpGroupNonUniformShuffle(const NodeOpGroupNonUniformShuffle &) = delete;
  NodeOpGroupNonUniformShuffle &operator=(const NodeOpGroupNonUniformShuffle &) = delete;
  NodeOpGroupNonUniformShuffle(NodeOpGroupNonUniformShuffle &&) = delete;
  NodeOpGroupNonUniformShuffle &operator=(NodeOpGroupNonUniformShuffle &&) = delete;
  NodeOpGroupNonUniformShuffle(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> id)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->id = id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformShuffleDown
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformShuffleDown;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> delta;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(delta);
  }
  NodeOpGroupNonUniformShuffleDown() = default;
  ~NodeOpGroupNonUniformShuffleDown() = default;
  NodeOpGroupNonUniformShuffleDown(const NodeOpGroupNonUniformShuffleDown &) = delete;
  NodeOpGroupNonUniformShuffleDown &operator=(const NodeOpGroupNonUniformShuffleDown &) = delete;
  NodeOpGroupNonUniformShuffleDown(NodeOpGroupNonUniformShuffleDown &&) = delete;
  NodeOpGroupNonUniformShuffleDown &operator=(NodeOpGroupNonUniformShuffleDown &&) = delete;
  NodeOpGroupNonUniformShuffleDown(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> delta)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->delta = delta;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformShuffleUp
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformShuffleUp;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> delta;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(delta);
  }
  NodeOpGroupNonUniformShuffleUp() = default;
  ~NodeOpGroupNonUniformShuffleUp() = default;
  NodeOpGroupNonUniformShuffleUp(const NodeOpGroupNonUniformShuffleUp &) = delete;
  NodeOpGroupNonUniformShuffleUp &operator=(const NodeOpGroupNonUniformShuffleUp &) = delete;
  NodeOpGroupNonUniformShuffleUp(NodeOpGroupNonUniformShuffleUp &&) = delete;
  NodeOpGroupNonUniformShuffleUp &operator=(NodeOpGroupNonUniformShuffleUp &&) = delete;
  NodeOpGroupNonUniformShuffleUp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> delta)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->delta = delta;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformShuffleXor
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupNonUniformShuffleXor;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> value;
  NodePointer<NodeId> mask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    visitor(mask);
  }
  NodeOpGroupNonUniformShuffleXor() = default;
  ~NodeOpGroupNonUniformShuffleXor() = default;
  NodeOpGroupNonUniformShuffleXor(const NodeOpGroupNonUniformShuffleXor &) = delete;
  NodeOpGroupNonUniformShuffleXor &operator=(const NodeOpGroupNonUniformShuffleXor &) = delete;
  NodeOpGroupNonUniformShuffleXor(NodeOpGroupNonUniformShuffleXor &&) = delete;
  NodeOpGroupNonUniformShuffleXor &operator=(NodeOpGroupNonUniformShuffleXor &&) = delete;
  NodeOpGroupNonUniformShuffleXor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> value, NodePointer<NodeId> mask)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->value = value;
    this->mask = mask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupReserveReadPipePackets
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupReserveReadPipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> numPackets;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(pipe);
    visitor(numPackets);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGroupReserveReadPipePackets() = default;
  ~NodeOpGroupReserveReadPipePackets() = default;
  NodeOpGroupReserveReadPipePackets(const NodeOpGroupReserveReadPipePackets &) = delete;
  NodeOpGroupReserveReadPipePackets &operator=(const NodeOpGroupReserveReadPipePackets &) = delete;
  NodeOpGroupReserveReadPipePackets(NodeOpGroupReserveReadPipePackets &&) = delete;
  NodeOpGroupReserveReadPipePackets &operator=(NodeOpGroupReserveReadPipePackets &&) = delete;
  NodeOpGroupReserveReadPipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> pipe, NodePointer<NodeId> num_packets, NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->pipe = pipe;
    this->numPackets = num_packets;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupReserveWritePipePackets
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpGroupReserveWritePipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> numPackets;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(pipe);
    visitor(numPackets);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGroupReserveWritePipePackets() = default;
  ~NodeOpGroupReserveWritePipePackets() = default;
  NodeOpGroupReserveWritePipePackets(const NodeOpGroupReserveWritePipePackets &) = delete;
  NodeOpGroupReserveWritePipePackets &operator=(const NodeOpGroupReserveWritePipePackets &) = delete;
  NodeOpGroupReserveWritePipePackets(NodeOpGroupReserveWritePipePackets &&) = delete;
  NodeOpGroupReserveWritePipePackets &operator=(NodeOpGroupReserveWritePipePackets &&) = delete;
  NodeOpGroupReserveWritePipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> pipe, NodePointer<NodeId> num_packets, NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->pipe = pipe;
    this->numPackets = num_packets;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpReadClockKHR
{
  const NodeKind nodeKind = NodeKind::ScopedOperation;
  const Op opCode = Op::OpReadClockKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> scope;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(scope);
  }
  NodeOpReadClockKHR() = default;
  ~NodeOpReadClockKHR() = default;
  NodeOpReadClockKHR(const NodeOpReadClockKHR &) = delete;
  NodeOpReadClockKHR &operator=(const NodeOpReadClockKHR &) = delete;
  NodeOpReadClockKHR(NodeOpReadClockKHR &&) = delete;
  NodeOpReadClockKHR &operator=(NodeOpReadClockKHR &&) = delete;
  NodeOpReadClockKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> scope)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->scope = scope;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeGroupedOperation : NodeScopedOperation
{
  GroupOperation groupOperation;
  NodePointer<NodeOperation> value;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeGroupedOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpGroupBitwiseAndKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupBitwiseAndKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupBitwiseAndKHR() = default;
  ~NodeOpGroupBitwiseAndKHR() = default;
  NodeOpGroupBitwiseAndKHR(const NodeOpGroupBitwiseAndKHR &) = delete;
  NodeOpGroupBitwiseAndKHR &operator=(const NodeOpGroupBitwiseAndKHR &) = delete;
  NodeOpGroupBitwiseAndKHR(NodeOpGroupBitwiseAndKHR &&) = delete;
  NodeOpGroupBitwiseAndKHR &operator=(NodeOpGroupBitwiseAndKHR &&) = delete;
  NodeOpGroupBitwiseAndKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupBitwiseOrKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupBitwiseOrKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupBitwiseOrKHR() = default;
  ~NodeOpGroupBitwiseOrKHR() = default;
  NodeOpGroupBitwiseOrKHR(const NodeOpGroupBitwiseOrKHR &) = delete;
  NodeOpGroupBitwiseOrKHR &operator=(const NodeOpGroupBitwiseOrKHR &) = delete;
  NodeOpGroupBitwiseOrKHR(NodeOpGroupBitwiseOrKHR &&) = delete;
  NodeOpGroupBitwiseOrKHR &operator=(NodeOpGroupBitwiseOrKHR &&) = delete;
  NodeOpGroupBitwiseOrKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupBitwiseXorKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupBitwiseXorKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupBitwiseXorKHR() = default;
  ~NodeOpGroupBitwiseXorKHR() = default;
  NodeOpGroupBitwiseXorKHR(const NodeOpGroupBitwiseXorKHR &) = delete;
  NodeOpGroupBitwiseXorKHR &operator=(const NodeOpGroupBitwiseXorKHR &) = delete;
  NodeOpGroupBitwiseXorKHR(NodeOpGroupBitwiseXorKHR &&) = delete;
  NodeOpGroupBitwiseXorKHR &operator=(NodeOpGroupBitwiseXorKHR &&) = delete;
  NodeOpGroupBitwiseXorKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFAdd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFAdd() = default;
  ~NodeOpGroupFAdd() = default;
  NodeOpGroupFAdd(const NodeOpGroupFAdd &) = delete;
  NodeOpGroupFAdd &operator=(const NodeOpGroupFAdd &) = delete;
  NodeOpGroupFAdd(NodeOpGroupFAdd &&) = delete;
  NodeOpGroupFAdd &operator=(NodeOpGroupFAdd &&) = delete;
  NodeOpGroupFAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFAddNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFAddNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFAddNonUniformAMD() = default;
  ~NodeOpGroupFAddNonUniformAMD() = default;
  NodeOpGroupFAddNonUniformAMD(const NodeOpGroupFAddNonUniformAMD &) = delete;
  NodeOpGroupFAddNonUniformAMD &operator=(const NodeOpGroupFAddNonUniformAMD &) = delete;
  NodeOpGroupFAddNonUniformAMD(NodeOpGroupFAddNonUniformAMD &&) = delete;
  NodeOpGroupFAddNonUniformAMD &operator=(NodeOpGroupFAddNonUniformAMD &&) = delete;
  NodeOpGroupFAddNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFMax() = default;
  ~NodeOpGroupFMax() = default;
  NodeOpGroupFMax(const NodeOpGroupFMax &) = delete;
  NodeOpGroupFMax &operator=(const NodeOpGroupFMax &) = delete;
  NodeOpGroupFMax(NodeOpGroupFMax &&) = delete;
  NodeOpGroupFMax &operator=(NodeOpGroupFMax &&) = delete;
  NodeOpGroupFMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFMaxNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFMaxNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFMaxNonUniformAMD() = default;
  ~NodeOpGroupFMaxNonUniformAMD() = default;
  NodeOpGroupFMaxNonUniformAMD(const NodeOpGroupFMaxNonUniformAMD &) = delete;
  NodeOpGroupFMaxNonUniformAMD &operator=(const NodeOpGroupFMaxNonUniformAMD &) = delete;
  NodeOpGroupFMaxNonUniformAMD(NodeOpGroupFMaxNonUniformAMD &&) = delete;
  NodeOpGroupFMaxNonUniformAMD &operator=(NodeOpGroupFMaxNonUniformAMD &&) = delete;
  NodeOpGroupFMaxNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFMin() = default;
  ~NodeOpGroupFMin() = default;
  NodeOpGroupFMin(const NodeOpGroupFMin &) = delete;
  NodeOpGroupFMin &operator=(const NodeOpGroupFMin &) = delete;
  NodeOpGroupFMin(NodeOpGroupFMin &&) = delete;
  NodeOpGroupFMin &operator=(NodeOpGroupFMin &&) = delete;
  NodeOpGroupFMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFMinNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFMinNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFMinNonUniformAMD() = default;
  ~NodeOpGroupFMinNonUniformAMD() = default;
  NodeOpGroupFMinNonUniformAMD(const NodeOpGroupFMinNonUniformAMD &) = delete;
  NodeOpGroupFMinNonUniformAMD &operator=(const NodeOpGroupFMinNonUniformAMD &) = delete;
  NodeOpGroupFMinNonUniformAMD(NodeOpGroupFMinNonUniformAMD &&) = delete;
  NodeOpGroupFMinNonUniformAMD &operator=(NodeOpGroupFMinNonUniformAMD &&) = delete;
  NodeOpGroupFMinNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupFMulKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupFMulKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupFMulKHR() = default;
  ~NodeOpGroupFMulKHR() = default;
  NodeOpGroupFMulKHR(const NodeOpGroupFMulKHR &) = delete;
  NodeOpGroupFMulKHR &operator=(const NodeOpGroupFMulKHR &) = delete;
  NodeOpGroupFMulKHR(NodeOpGroupFMulKHR &&) = delete;
  NodeOpGroupFMulKHR &operator=(NodeOpGroupFMulKHR &&) = delete;
  NodeOpGroupFMulKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupIAdd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupIAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupIAdd() = default;
  ~NodeOpGroupIAdd() = default;
  NodeOpGroupIAdd(const NodeOpGroupIAdd &) = delete;
  NodeOpGroupIAdd &operator=(const NodeOpGroupIAdd &) = delete;
  NodeOpGroupIAdd(NodeOpGroupIAdd &&) = delete;
  NodeOpGroupIAdd &operator=(NodeOpGroupIAdd &&) = delete;
  NodeOpGroupIAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupIAddNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupIAddNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupIAddNonUniformAMD() = default;
  ~NodeOpGroupIAddNonUniformAMD() = default;
  NodeOpGroupIAddNonUniformAMD(const NodeOpGroupIAddNonUniformAMD &) = delete;
  NodeOpGroupIAddNonUniformAMD &operator=(const NodeOpGroupIAddNonUniformAMD &) = delete;
  NodeOpGroupIAddNonUniformAMD(NodeOpGroupIAddNonUniformAMD &&) = delete;
  NodeOpGroupIAddNonUniformAMD &operator=(NodeOpGroupIAddNonUniformAMD &&) = delete;
  NodeOpGroupIAddNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupIMulKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupIMulKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupIMulKHR() = default;
  ~NodeOpGroupIMulKHR() = default;
  NodeOpGroupIMulKHR(const NodeOpGroupIMulKHR &) = delete;
  NodeOpGroupIMulKHR &operator=(const NodeOpGroupIMulKHR &) = delete;
  NodeOpGroupIMulKHR(NodeOpGroupIMulKHR &&) = delete;
  NodeOpGroupIMulKHR &operator=(NodeOpGroupIMulKHR &&) = delete;
  NodeOpGroupIMulKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupLogicalAndKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupLogicalAndKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupLogicalAndKHR() = default;
  ~NodeOpGroupLogicalAndKHR() = default;
  NodeOpGroupLogicalAndKHR(const NodeOpGroupLogicalAndKHR &) = delete;
  NodeOpGroupLogicalAndKHR &operator=(const NodeOpGroupLogicalAndKHR &) = delete;
  NodeOpGroupLogicalAndKHR(NodeOpGroupLogicalAndKHR &&) = delete;
  NodeOpGroupLogicalAndKHR &operator=(NodeOpGroupLogicalAndKHR &&) = delete;
  NodeOpGroupLogicalAndKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupLogicalOrKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupLogicalOrKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupLogicalOrKHR() = default;
  ~NodeOpGroupLogicalOrKHR() = default;
  NodeOpGroupLogicalOrKHR(const NodeOpGroupLogicalOrKHR &) = delete;
  NodeOpGroupLogicalOrKHR &operator=(const NodeOpGroupLogicalOrKHR &) = delete;
  NodeOpGroupLogicalOrKHR(NodeOpGroupLogicalOrKHR &&) = delete;
  NodeOpGroupLogicalOrKHR &operator=(NodeOpGroupLogicalOrKHR &&) = delete;
  NodeOpGroupLogicalOrKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupLogicalXorKHR
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupLogicalXorKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupLogicalXorKHR() = default;
  ~NodeOpGroupLogicalXorKHR() = default;
  NodeOpGroupLogicalXorKHR(const NodeOpGroupLogicalXorKHR &) = delete;
  NodeOpGroupLogicalXorKHR &operator=(const NodeOpGroupLogicalXorKHR &) = delete;
  NodeOpGroupLogicalXorKHR(NodeOpGroupLogicalXorKHR &&) = delete;
  NodeOpGroupLogicalXorKHR &operator=(NodeOpGroupLogicalXorKHR &&) = delete;
  NodeOpGroupLogicalXorKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBallotBitCount
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformBallotBitCount;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
  }
  NodeOpGroupNonUniformBallotBitCount() = default;
  ~NodeOpGroupNonUniformBallotBitCount() = default;
  NodeOpGroupNonUniformBallotBitCount(const NodeOpGroupNonUniformBallotBitCount &) = delete;
  NodeOpGroupNonUniformBallotBitCount &operator=(const NodeOpGroupNonUniformBallotBitCount &) = delete;
  NodeOpGroupNonUniformBallotBitCount(NodeOpGroupNonUniformBallotBitCount &&) = delete;
  NodeOpGroupNonUniformBallotBitCount &operator=(NodeOpGroupNonUniformBallotBitCount &&) = delete;
  NodeOpGroupNonUniformBallotBitCount(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBitwiseAnd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformBitwiseAnd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformBitwiseAnd() = default;
  ~NodeOpGroupNonUniformBitwiseAnd() = default;
  NodeOpGroupNonUniformBitwiseAnd(const NodeOpGroupNonUniformBitwiseAnd &) = delete;
  NodeOpGroupNonUniformBitwiseAnd &operator=(const NodeOpGroupNonUniformBitwiseAnd &) = delete;
  NodeOpGroupNonUniformBitwiseAnd(NodeOpGroupNonUniformBitwiseAnd &&) = delete;
  NodeOpGroupNonUniformBitwiseAnd &operator=(NodeOpGroupNonUniformBitwiseAnd &&) = delete;
  NodeOpGroupNonUniformBitwiseAnd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBitwiseOr
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformBitwiseOr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformBitwiseOr() = default;
  ~NodeOpGroupNonUniformBitwiseOr() = default;
  NodeOpGroupNonUniformBitwiseOr(const NodeOpGroupNonUniformBitwiseOr &) = delete;
  NodeOpGroupNonUniformBitwiseOr &operator=(const NodeOpGroupNonUniformBitwiseOr &) = delete;
  NodeOpGroupNonUniformBitwiseOr(NodeOpGroupNonUniformBitwiseOr &&) = delete;
  NodeOpGroupNonUniformBitwiseOr &operator=(NodeOpGroupNonUniformBitwiseOr &&) = delete;
  NodeOpGroupNonUniformBitwiseOr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformBitwiseXor
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformBitwiseXor;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformBitwiseXor() = default;
  ~NodeOpGroupNonUniformBitwiseXor() = default;
  NodeOpGroupNonUniformBitwiseXor(const NodeOpGroupNonUniformBitwiseXor &) = delete;
  NodeOpGroupNonUniformBitwiseXor &operator=(const NodeOpGroupNonUniformBitwiseXor &) = delete;
  NodeOpGroupNonUniformBitwiseXor(NodeOpGroupNonUniformBitwiseXor &&) = delete;
  NodeOpGroupNonUniformBitwiseXor &operator=(NodeOpGroupNonUniformBitwiseXor &&) = delete;
  NodeOpGroupNonUniformBitwiseXor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformFAdd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformFAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformFAdd() = default;
  ~NodeOpGroupNonUniformFAdd() = default;
  NodeOpGroupNonUniformFAdd(const NodeOpGroupNonUniformFAdd &) = delete;
  NodeOpGroupNonUniformFAdd &operator=(const NodeOpGroupNonUniformFAdd &) = delete;
  NodeOpGroupNonUniformFAdd(NodeOpGroupNonUniformFAdd &&) = delete;
  NodeOpGroupNonUniformFAdd &operator=(NodeOpGroupNonUniformFAdd &&) = delete;
  NodeOpGroupNonUniformFAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformFMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformFMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformFMax() = default;
  ~NodeOpGroupNonUniformFMax() = default;
  NodeOpGroupNonUniformFMax(const NodeOpGroupNonUniformFMax &) = delete;
  NodeOpGroupNonUniformFMax &operator=(const NodeOpGroupNonUniformFMax &) = delete;
  NodeOpGroupNonUniformFMax(NodeOpGroupNonUniformFMax &&) = delete;
  NodeOpGroupNonUniformFMax &operator=(NodeOpGroupNonUniformFMax &&) = delete;
  NodeOpGroupNonUniformFMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformFMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformFMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformFMin() = default;
  ~NodeOpGroupNonUniformFMin() = default;
  NodeOpGroupNonUniformFMin(const NodeOpGroupNonUniformFMin &) = delete;
  NodeOpGroupNonUniformFMin &operator=(const NodeOpGroupNonUniformFMin &) = delete;
  NodeOpGroupNonUniformFMin(NodeOpGroupNonUniformFMin &&) = delete;
  NodeOpGroupNonUniformFMin &operator=(NodeOpGroupNonUniformFMin &&) = delete;
  NodeOpGroupNonUniformFMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformFMul
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformFMul;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformFMul() = default;
  ~NodeOpGroupNonUniformFMul() = default;
  NodeOpGroupNonUniformFMul(const NodeOpGroupNonUniformFMul &) = delete;
  NodeOpGroupNonUniformFMul &operator=(const NodeOpGroupNonUniformFMul &) = delete;
  NodeOpGroupNonUniformFMul(NodeOpGroupNonUniformFMul &&) = delete;
  NodeOpGroupNonUniformFMul &operator=(NodeOpGroupNonUniformFMul &&) = delete;
  NodeOpGroupNonUniformFMul(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformIAdd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformIAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformIAdd() = default;
  ~NodeOpGroupNonUniformIAdd() = default;
  NodeOpGroupNonUniformIAdd(const NodeOpGroupNonUniformIAdd &) = delete;
  NodeOpGroupNonUniformIAdd &operator=(const NodeOpGroupNonUniformIAdd &) = delete;
  NodeOpGroupNonUniformIAdd(NodeOpGroupNonUniformIAdd &&) = delete;
  NodeOpGroupNonUniformIAdd &operator=(NodeOpGroupNonUniformIAdd &&) = delete;
  NodeOpGroupNonUniformIAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformIMul
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformIMul;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformIMul() = default;
  ~NodeOpGroupNonUniformIMul() = default;
  NodeOpGroupNonUniformIMul(const NodeOpGroupNonUniformIMul &) = delete;
  NodeOpGroupNonUniformIMul &operator=(const NodeOpGroupNonUniformIMul &) = delete;
  NodeOpGroupNonUniformIMul(NodeOpGroupNonUniformIMul &&) = delete;
  NodeOpGroupNonUniformIMul &operator=(NodeOpGroupNonUniformIMul &&) = delete;
  NodeOpGroupNonUniformIMul(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformLogicalAnd
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformLogicalAnd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformLogicalAnd() = default;
  ~NodeOpGroupNonUniformLogicalAnd() = default;
  NodeOpGroupNonUniformLogicalAnd(const NodeOpGroupNonUniformLogicalAnd &) = delete;
  NodeOpGroupNonUniformLogicalAnd &operator=(const NodeOpGroupNonUniformLogicalAnd &) = delete;
  NodeOpGroupNonUniformLogicalAnd(NodeOpGroupNonUniformLogicalAnd &&) = delete;
  NodeOpGroupNonUniformLogicalAnd &operator=(NodeOpGroupNonUniformLogicalAnd &&) = delete;
  NodeOpGroupNonUniformLogicalAnd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformLogicalOr
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformLogicalOr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformLogicalOr() = default;
  ~NodeOpGroupNonUniformLogicalOr() = default;
  NodeOpGroupNonUniformLogicalOr(const NodeOpGroupNonUniformLogicalOr &) = delete;
  NodeOpGroupNonUniformLogicalOr &operator=(const NodeOpGroupNonUniformLogicalOr &) = delete;
  NodeOpGroupNonUniformLogicalOr(NodeOpGroupNonUniformLogicalOr &&) = delete;
  NodeOpGroupNonUniformLogicalOr &operator=(NodeOpGroupNonUniformLogicalOr &&) = delete;
  NodeOpGroupNonUniformLogicalOr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformLogicalXor
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformLogicalXor;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformLogicalXor() = default;
  ~NodeOpGroupNonUniformLogicalXor() = default;
  NodeOpGroupNonUniformLogicalXor(const NodeOpGroupNonUniformLogicalXor &) = delete;
  NodeOpGroupNonUniformLogicalXor &operator=(const NodeOpGroupNonUniformLogicalXor &) = delete;
  NodeOpGroupNonUniformLogicalXor(NodeOpGroupNonUniformLogicalXor &&) = delete;
  NodeOpGroupNonUniformLogicalXor &operator=(NodeOpGroupNonUniformLogicalXor &&) = delete;
  NodeOpGroupNonUniformLogicalXor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformSMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformSMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformSMax() = default;
  ~NodeOpGroupNonUniformSMax() = default;
  NodeOpGroupNonUniformSMax(const NodeOpGroupNonUniformSMax &) = delete;
  NodeOpGroupNonUniformSMax &operator=(const NodeOpGroupNonUniformSMax &) = delete;
  NodeOpGroupNonUniformSMax(NodeOpGroupNonUniformSMax &&) = delete;
  NodeOpGroupNonUniformSMax &operator=(NodeOpGroupNonUniformSMax &&) = delete;
  NodeOpGroupNonUniformSMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformSMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformSMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformSMin() = default;
  ~NodeOpGroupNonUniformSMin() = default;
  NodeOpGroupNonUniformSMin(const NodeOpGroupNonUniformSMin &) = delete;
  NodeOpGroupNonUniformSMin &operator=(const NodeOpGroupNonUniformSMin &) = delete;
  NodeOpGroupNonUniformSMin(NodeOpGroupNonUniformSMin &&) = delete;
  NodeOpGroupNonUniformSMin &operator=(NodeOpGroupNonUniformSMin &&) = delete;
  NodeOpGroupNonUniformSMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformUMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformUMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformUMax() = default;
  ~NodeOpGroupNonUniformUMax() = default;
  NodeOpGroupNonUniformUMax(const NodeOpGroupNonUniformUMax &) = delete;
  NodeOpGroupNonUniformUMax &operator=(const NodeOpGroupNonUniformUMax &) = delete;
  NodeOpGroupNonUniformUMax(NodeOpGroupNonUniformUMax &&) = delete;
  NodeOpGroupNonUniformUMax &operator=(NodeOpGroupNonUniformUMax &&) = delete;
  NodeOpGroupNonUniformUMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformUMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupNonUniformUMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> value;
  eastl::optional<NodePointer<NodeId>> clusterSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(value);
    if (clusterSize)
      visitor(*clusterSize);
  }
  NodeOpGroupNonUniformUMin() = default;
  ~NodeOpGroupNonUniformUMin() = default;
  NodeOpGroupNonUniformUMin(const NodeOpGroupNonUniformUMin &) = delete;
  NodeOpGroupNonUniformUMin &operator=(const NodeOpGroupNonUniformUMin &) = delete;
  NodeOpGroupNonUniformUMin(NodeOpGroupNonUniformUMin &&) = delete;
  NodeOpGroupNonUniformUMin &operator=(NodeOpGroupNonUniformUMin &&) = delete;
  NodeOpGroupNonUniformUMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> value, eastl::optional<NodePointer<NodeId>> cluster_size = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->value = value;
    this->clusterSize = cluster_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupSMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupSMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupSMax() = default;
  ~NodeOpGroupSMax() = default;
  NodeOpGroupSMax(const NodeOpGroupSMax &) = delete;
  NodeOpGroupSMax &operator=(const NodeOpGroupSMax &) = delete;
  NodeOpGroupSMax(NodeOpGroupSMax &&) = delete;
  NodeOpGroupSMax &operator=(NodeOpGroupSMax &&) = delete;
  NodeOpGroupSMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupSMaxNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupSMaxNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupSMaxNonUniformAMD() = default;
  ~NodeOpGroupSMaxNonUniformAMD() = default;
  NodeOpGroupSMaxNonUniformAMD(const NodeOpGroupSMaxNonUniformAMD &) = delete;
  NodeOpGroupSMaxNonUniformAMD &operator=(const NodeOpGroupSMaxNonUniformAMD &) = delete;
  NodeOpGroupSMaxNonUniformAMD(NodeOpGroupSMaxNonUniformAMD &&) = delete;
  NodeOpGroupSMaxNonUniformAMD &operator=(NodeOpGroupSMaxNonUniformAMD &&) = delete;
  NodeOpGroupSMaxNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupSMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupSMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupSMin() = default;
  ~NodeOpGroupSMin() = default;
  NodeOpGroupSMin(const NodeOpGroupSMin &) = delete;
  NodeOpGroupSMin &operator=(const NodeOpGroupSMin &) = delete;
  NodeOpGroupSMin(NodeOpGroupSMin &&) = delete;
  NodeOpGroupSMin &operator=(NodeOpGroupSMin &&) = delete;
  NodeOpGroupSMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupSMinNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupSMinNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupSMinNonUniformAMD() = default;
  ~NodeOpGroupSMinNonUniformAMD() = default;
  NodeOpGroupSMinNonUniformAMD(const NodeOpGroupSMinNonUniformAMD &) = delete;
  NodeOpGroupSMinNonUniformAMD &operator=(const NodeOpGroupSMinNonUniformAMD &) = delete;
  NodeOpGroupSMinNonUniformAMD(NodeOpGroupSMinNonUniformAMD &&) = delete;
  NodeOpGroupSMinNonUniformAMD &operator=(NodeOpGroupSMinNonUniformAMD &&) = delete;
  NodeOpGroupSMinNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupUMax
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupUMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupUMax() = default;
  ~NodeOpGroupUMax() = default;
  NodeOpGroupUMax(const NodeOpGroupUMax &) = delete;
  NodeOpGroupUMax &operator=(const NodeOpGroupUMax &) = delete;
  NodeOpGroupUMax(NodeOpGroupUMax &&) = delete;
  NodeOpGroupUMax &operator=(NodeOpGroupUMax &&) = delete;
  NodeOpGroupUMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupUMaxNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupUMaxNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupUMaxNonUniformAMD() = default;
  ~NodeOpGroupUMaxNonUniformAMD() = default;
  NodeOpGroupUMaxNonUniformAMD(const NodeOpGroupUMaxNonUniformAMD &) = delete;
  NodeOpGroupUMaxNonUniformAMD &operator=(const NodeOpGroupUMaxNonUniformAMD &) = delete;
  NodeOpGroupUMaxNonUniformAMD(NodeOpGroupUMaxNonUniformAMD &&) = delete;
  NodeOpGroupUMaxNonUniformAMD &operator=(NodeOpGroupUMaxNonUniformAMD &&) = delete;
  NodeOpGroupUMaxNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupUMin
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupUMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupUMin() = default;
  ~NodeOpGroupUMin() = default;
  NodeOpGroupUMin(const NodeOpGroupUMin &) = delete;
  NodeOpGroupUMin &operator=(const NodeOpGroupUMin &) = delete;
  NodeOpGroupUMin(NodeOpGroupUMin &&) = delete;
  NodeOpGroupUMin &operator=(NodeOpGroupUMin &&) = delete;
  NodeOpGroupUMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupUMinNonUniformAMD
{
  const NodeKind nodeKind = NodeKind::GroupedOperation;
  const Op opCode = Op::OpGroupUMinNonUniformAMD;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> execution;
  GroupOperation operation;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(execution);
    visitor(x);
  }
  NodeOpGroupUMinNonUniformAMD() = default;
  ~NodeOpGroupUMinNonUniformAMD() = default;
  NodeOpGroupUMinNonUniformAMD(const NodeOpGroupUMinNonUniformAMD &) = delete;
  NodeOpGroupUMinNonUniformAMD &operator=(const NodeOpGroupUMinNonUniformAMD &) = delete;
  NodeOpGroupUMinNonUniformAMD(NodeOpGroupUMinNonUniformAMD &&) = delete;
  NodeOpGroupUMinNonUniformAMD &operator=(NodeOpGroupUMinNonUniformAMD &&) = delete;
  NodeOpGroupUMinNonUniformAMD(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> execution,
    GroupOperation operation, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->execution = execution;
    this->operation = operation;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeGroupedOperation::visit(NodeGroupedOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::GroupedOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpGroupBitwiseAndKHR:
        if (visitor(reinterpret_cast<NodeOpGroupBitwiseAndKHR *>(node)))
          return true;
        break;
      case Op::OpGroupBitwiseOrKHR:
        if (visitor(reinterpret_cast<NodeOpGroupBitwiseOrKHR *>(node)))
          return true;
        break;
      case Op::OpGroupBitwiseXorKHR:
        if (visitor(reinterpret_cast<NodeOpGroupBitwiseXorKHR *>(node)))
          return true;
        break;
      case Op::OpGroupFAdd:
        if (visitor(reinterpret_cast<NodeOpGroupFAdd *>(node)))
          return true;
        break;
      case Op::OpGroupFAddNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupFAddNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupFMax:
        if (visitor(reinterpret_cast<NodeOpGroupFMax *>(node)))
          return true;
        break;
      case Op::OpGroupFMaxNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupFMaxNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupFMin:
        if (visitor(reinterpret_cast<NodeOpGroupFMin *>(node)))
          return true;
        break;
      case Op::OpGroupFMinNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupFMinNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupFMulKHR:
        if (visitor(reinterpret_cast<NodeOpGroupFMulKHR *>(node)))
          return true;
        break;
      case Op::OpGroupIAdd:
        if (visitor(reinterpret_cast<NodeOpGroupIAdd *>(node)))
          return true;
        break;
      case Op::OpGroupIAddNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupIAddNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupIMulKHR:
        if (visitor(reinterpret_cast<NodeOpGroupIMulKHR *>(node)))
          return true;
        break;
      case Op::OpGroupLogicalAndKHR:
        if (visitor(reinterpret_cast<NodeOpGroupLogicalAndKHR *>(node)))
          return true;
        break;
      case Op::OpGroupLogicalOrKHR:
        if (visitor(reinterpret_cast<NodeOpGroupLogicalOrKHR *>(node)))
          return true;
        break;
      case Op::OpGroupLogicalXorKHR:
        if (visitor(reinterpret_cast<NodeOpGroupLogicalXorKHR *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBallotBitCount:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBallotBitCount *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBitwiseAnd:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBitwiseAnd *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBitwiseOr:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBitwiseOr *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBitwiseXor:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBitwiseXor *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformFAdd:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformFAdd *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformFMax:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformFMax *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformFMin:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformFMin *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformFMul:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformFMul *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformIAdd:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformIAdd *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformIMul:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformIMul *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformLogicalAnd:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformLogicalAnd *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformLogicalOr:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformLogicalOr *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformLogicalXor:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformLogicalXor *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformSMax:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformSMax *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformSMin:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformSMin *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformUMax:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformUMax *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformUMin:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformUMin *>(node)))
          return true;
        break;
      case Op::OpGroupSMax:
        if (visitor(reinterpret_cast<NodeOpGroupSMax *>(node)))
          return true;
        break;
      case Op::OpGroupSMaxNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupSMaxNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupSMin:
        if (visitor(reinterpret_cast<NodeOpGroupSMin *>(node)))
          return true;
        break;
      case Op::OpGroupSMinNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupSMinNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupUMax:
        if (visitor(reinterpret_cast<NodeOpGroupUMax *>(node)))
          return true;
        break;
      case Op::OpGroupUMaxNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupUMaxNonUniformAMD *>(node)))
          return true;
        break;
      case Op::OpGroupUMin:
        if (visitor(reinterpret_cast<NodeOpGroupUMin *>(node)))
          return true;
        break;
      case Op::OpGroupUMinNonUniformAMD:
        if (visitor(reinterpret_cast<NodeOpGroupUMinNonUniformAMD *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
template <typename T>
inline bool NodeScopedOperation::visit(NodeScopedOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::ScopedOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpGroupAll:
        if (visitor(reinterpret_cast<NodeOpGroupAll *>(node)))
          return true;
        break;
      case Op::OpGroupAny:
        if (visitor(reinterpret_cast<NodeOpGroupAny *>(node)))
          return true;
        break;
      case Op::OpGroupAsyncCopy:
        if (visitor(reinterpret_cast<NodeOpGroupAsyncCopy *>(node)))
          return true;
        break;
      case Op::OpGroupBroadcast:
        if (visitor(reinterpret_cast<NodeOpGroupBroadcast *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformAll:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformAll *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformAllEqual:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformAllEqual *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformAny:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformAny *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBallot:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBallot *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBallotBitExtract:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBallotBitExtract *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBallotFindLSB:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBallotFindLSB *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBallotFindMSB:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBallotFindMSB *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBroadcast:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBroadcast *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformBroadcastFirst:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformBroadcastFirst *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformElect:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformElect *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformInverseBallot:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformInverseBallot *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformQuadBroadcast:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformQuadBroadcast *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformQuadSwap:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformQuadSwap *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformRotateKHR:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformRotateKHR *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformShuffle:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformShuffle *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformShuffleDown:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformShuffleDown *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformShuffleUp:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformShuffleUp *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformShuffleXor:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformShuffleXor *>(node)))
          return true;
        break;
      case Op::OpGroupReserveReadPipePackets:
        if (visitor(reinterpret_cast<NodeOpGroupReserveReadPipePackets *>(node)))
          return true;
        break;
      case Op::OpGroupReserveWritePipePackets:
        if (visitor(reinterpret_cast<NodeOpGroupReserveWritePipePackets *>(node)))
          return true;
        break;
      case Op::OpReadClockKHR:
        if (visitor(reinterpret_cast<NodeOpReadClockKHR *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeGroupedOperation::is(node))
    {
      if (NodeGroupedOperation::visit(reinterpret_cast<NodeGroupedOperation *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeSpecConstant : NodeOperation
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeSpecConstant *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpSpecConstant
{
  const NodeKind nodeKind = NodeKind::SpecConstant;
  const Op opCode = Op::OpSpecConstant;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  LiteralContextDependentNumber value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSpecConstant() = default;
  ~NodeOpSpecConstant() = default;
  NodeOpSpecConstant(const NodeOpSpecConstant &) = delete;
  NodeOpSpecConstant &operator=(const NodeOpSpecConstant &) = delete;
  NodeOpSpecConstant(NodeOpSpecConstant &&) = delete;
  NodeOpSpecConstant &operator=(NodeOpSpecConstant &&) = delete;
  NodeOpSpecConstant(Id id_result, NodePointer<NodeTypedef> id_result_type, LiteralContextDependentNumber value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSpecConstantFalse
{
  const NodeKind nodeKind = NodeKind::SpecConstant;
  const Op opCode = Op::OpSpecConstantFalse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSpecConstantFalse() = default;
  ~NodeOpSpecConstantFalse() = default;
  NodeOpSpecConstantFalse(const NodeOpSpecConstantFalse &) = delete;
  NodeOpSpecConstantFalse &operator=(const NodeOpSpecConstantFalse &) = delete;
  NodeOpSpecConstantFalse(NodeOpSpecConstantFalse &&) = delete;
  NodeOpSpecConstantFalse &operator=(NodeOpSpecConstantFalse &&) = delete;
  NodeOpSpecConstantFalse(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSpecConstantTrue
{
  const NodeKind nodeKind = NodeKind::SpecConstant;
  const Op opCode = Op::OpSpecConstantTrue;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpSpecConstantTrue() = default;
  ~NodeOpSpecConstantTrue() = default;
  NodeOpSpecConstantTrue(const NodeOpSpecConstantTrue &) = delete;
  NodeOpSpecConstantTrue &operator=(const NodeOpSpecConstantTrue &) = delete;
  NodeOpSpecConstantTrue(NodeOpSpecConstantTrue &&) = delete;
  NodeOpSpecConstantTrue &operator=(NodeOpSpecConstantTrue &&) = delete;
  NodeOpSpecConstantTrue(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeSpecConstantComposite : NodeSpecConstant
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeSpecConstantComposite *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpSpecConstantComposite
{
  const NodeKind nodeKind = NodeKind::SpecConstantComposite;
  const Op opCode = Op::OpSpecConstantComposite;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  eastl::vector<NodePointer<NodeId>> constituents;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    for (auto &&ref : constituents)
      visitor(ref);
  }
  NodeOpSpecConstantComposite() = default;
  ~NodeOpSpecConstantComposite() = default;
  NodeOpSpecConstantComposite(const NodeOpSpecConstantComposite &) = delete;
  NodeOpSpecConstantComposite &operator=(const NodeOpSpecConstantComposite &) = delete;
  NodeOpSpecConstantComposite(NodeOpSpecConstantComposite &&) = delete;
  NodeOpSpecConstantComposite &operator=(NodeOpSpecConstantComposite &&) = delete;
  NodeOpSpecConstantComposite(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> *constituents = nullptr,
    size_t constituents_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->constituents.assign(constituents, constituents + constituents_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSpecConstantCompositeReplicateEXT
{
  const NodeKind nodeKind = NodeKind::SpecConstantComposite;
  const Op opCode = Op::OpSpecConstantCompositeReplicateEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpSpecConstantCompositeReplicateEXT() = default;
  ~NodeOpSpecConstantCompositeReplicateEXT() = default;
  NodeOpSpecConstantCompositeReplicateEXT(const NodeOpSpecConstantCompositeReplicateEXT &) = delete;
  NodeOpSpecConstantCompositeReplicateEXT &operator=(const NodeOpSpecConstantCompositeReplicateEXT &) = delete;
  NodeOpSpecConstantCompositeReplicateEXT(NodeOpSpecConstantCompositeReplicateEXT &&) = delete;
  NodeOpSpecConstantCompositeReplicateEXT &operator=(NodeOpSpecConstantCompositeReplicateEXT &&) = delete;
  NodeOpSpecConstantCompositeReplicateEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeSpecConstantComposite::visit(NodeSpecConstantComposite *node, T visitor)
{
  if (node->nodeKind == NodeKind::SpecConstantComposite)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpSpecConstantComposite:
        if (visitor(reinterpret_cast<NodeOpSpecConstantComposite *>(node)))
          return true;
        break;
      case Op::OpSpecConstantCompositeReplicateEXT:
        if (visitor(reinterpret_cast<NodeOpSpecConstantCompositeReplicateEXT *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeSpecConstantOperation : NodeSpecConstant
{
  NodePointer<NodeOperation> specOp;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeSpecConstantOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpSpecConstantOp
{
  const NodeKind nodeKind = NodeKind::SpecConstantOperation;
  const Op opCode = Op::OpSpecConstantOp;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeOperation> specOp;
  template <typename T>
  void visitRefs(T visitor)
  {
    specOp->visitRefs(visitor);
  }
  NodeOpSpecConstantOp() = default;
  ~NodeOpSpecConstantOp() = default;
  NodeOpSpecConstantOp(const NodeOpSpecConstantOp &) = delete;
  NodeOpSpecConstantOp &operator=(const NodeOpSpecConstantOp &) = delete;
  NodeOpSpecConstantOp(NodeOpSpecConstantOp &&) = delete;
  NodeOpSpecConstantOp &operator=(NodeOpSpecConstantOp &&) = delete;
  NodeOpSpecConstantOp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeOperation> spec_op)
  {
    resultId = id_result;
    resultType = id_result_type;
    specOp = spec_op;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeSpecConstantOperation::visit(NodeSpecConstantOperation *node, T visitor)
{
  // simplified case where this node has no children and only one instruction
  if (visitor(reinterpret_cast<NodeOpSpecConstantOp *>(node)))
    return true;
  return visitor(node);
}
template <typename T>
inline bool NodeSpecConstant::visit(NodeSpecConstant *node, T visitor)
{
  if (node->nodeKind == NodeKind::SpecConstant)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpSpecConstant:
        if (visitor(reinterpret_cast<NodeOpSpecConstant *>(node)))
          return true;
        break;
      case Op::OpSpecConstantFalse:
        if (visitor(reinterpret_cast<NodeOpSpecConstantFalse *>(node)))
          return true;
        break;
      case Op::OpSpecConstantTrue:
        if (visitor(reinterpret_cast<NodeOpSpecConstantTrue *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeSpecConstantComposite::is(node))
    {
      if (NodeSpecConstantComposite::visit(reinterpret_cast<NodeSpecConstantComposite *>(node), visitor))
        return true;
    }
    else if (NodeSpecConstantOperation::is(node))
    {
      if (NodeSpecConstantOperation::visit(reinterpret_cast<NodeSpecConstantOperation *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeTrinaryOperation : NodeOperation
{
  NodePointer<NodeId> first;
  NodePointer<NodeId> second;
  NodePointer<NodeId> third;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeTrinaryOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpGLSLstd450FClamp
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FClamp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> minVal;
  NodePointer<NodeId> maxVal;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(minVal);
    visitor(maxVal);
  }
  NodeOpGLSLstd450FClamp() = default;
  ~NodeOpGLSLstd450FClamp() = default;
  NodeOpGLSLstd450FClamp(const NodeOpGLSLstd450FClamp &) = delete;
  NodeOpGLSLstd450FClamp &operator=(const NodeOpGLSLstd450FClamp &) = delete;
  NodeOpGLSLstd450FClamp(NodeOpGLSLstd450FClamp &&) = delete;
  NodeOpGLSLstd450FClamp &operator=(NodeOpGLSLstd450FClamp &&) = delete;
  NodeOpGLSLstd450FClamp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> min_val,
    NodePointer<NodeId> max_val)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->minVal = min_val;
    this->maxVal = max_val;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxFMax3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::FMax3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxFMax3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxFMax3() = default;
  NodeOpAMDShaderTrinaryMinmaxFMax3(const NodeOpAMDShaderTrinaryMinmaxFMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMax3 &operator=(const NodeOpAMDShaderTrinaryMinmaxFMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMax3(NodeOpAMDShaderTrinaryMinmaxFMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMax3 &operator=(NodeOpAMDShaderTrinaryMinmaxFMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMax3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxFMid3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::FMid3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxFMid3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxFMid3() = default;
  NodeOpAMDShaderTrinaryMinmaxFMid3(const NodeOpAMDShaderTrinaryMinmaxFMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMid3 &operator=(const NodeOpAMDShaderTrinaryMinmaxFMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMid3(NodeOpAMDShaderTrinaryMinmaxFMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMid3 &operator=(NodeOpAMDShaderTrinaryMinmaxFMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMid3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxFMin3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::FMin3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxFMin3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxFMin3() = default;
  NodeOpAMDShaderTrinaryMinmaxFMin3(const NodeOpAMDShaderTrinaryMinmaxFMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMin3 &operator=(const NodeOpAMDShaderTrinaryMinmaxFMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMin3(NodeOpAMDShaderTrinaryMinmaxFMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMin3 &operator=(NodeOpAMDShaderTrinaryMinmaxFMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxFMin3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FMix
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FMix;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> a;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(a);
  }
  NodeOpGLSLstd450FMix() = default;
  ~NodeOpGLSLstd450FMix() = default;
  NodeOpGLSLstd450FMix(const NodeOpGLSLstd450FMix &) = delete;
  NodeOpGLSLstd450FMix &operator=(const NodeOpGLSLstd450FMix &) = delete;
  NodeOpGLSLstd450FMix(NodeOpGLSLstd450FMix &&) = delete;
  NodeOpGLSLstd450FMix &operator=(NodeOpGLSLstd450FMix &&) = delete;
  NodeOpGLSLstd450FMix(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y,
    NodePointer<NodeId> a)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->a = a;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FaceForward
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FaceForward;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> n;
  NodePointer<NodeId> i;
  NodePointer<NodeId> nref;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(n);
    visitor(i);
    visitor(nref);
  }
  NodeOpGLSLstd450FaceForward() = default;
  ~NodeOpGLSLstd450FaceForward() = default;
  NodeOpGLSLstd450FaceForward(const NodeOpGLSLstd450FaceForward &) = delete;
  NodeOpGLSLstd450FaceForward &operator=(const NodeOpGLSLstd450FaceForward &) = delete;
  NodeOpGLSLstd450FaceForward(NodeOpGLSLstd450FaceForward &&) = delete;
  NodeOpGLSLstd450FaceForward &operator=(NodeOpGLSLstd450FaceForward &&) = delete;
  NodeOpGLSLstd450FaceForward(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> n, NodePointer<NodeId> i,
    NodePointer<NodeId> nref)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->n = n;
    this->i = i;
    this->nref = nref;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Fma
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Fma;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  NodePointer<NodeId> b;
  NodePointer<NodeId> c;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
    visitor(c);
  }
  NodeOpGLSLstd450Fma() = default;
  ~NodeOpGLSLstd450Fma() = default;
  NodeOpGLSLstd450Fma(const NodeOpGLSLstd450Fma &) = delete;
  NodeOpGLSLstd450Fma &operator=(const NodeOpGLSLstd450Fma &) = delete;
  NodeOpGLSLstd450Fma(NodeOpGLSLstd450Fma &&) = delete;
  NodeOpGLSLstd450Fma &operator=(NodeOpGLSLstd450Fma &&) = delete;
  NodeOpGLSLstd450Fma(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, NodePointer<NodeId> b,
    NodePointer<NodeId> c)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->b = b;
    this->c = c;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450IMix
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::IMix;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> a;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(a);
  }
  NodeOpGLSLstd450IMix() = default;
  ~NodeOpGLSLstd450IMix() = default;
  NodeOpGLSLstd450IMix(const NodeOpGLSLstd450IMix &) = delete;
  NodeOpGLSLstd450IMix &operator=(const NodeOpGLSLstd450IMix &) = delete;
  NodeOpGLSLstd450IMix(NodeOpGLSLstd450IMix &&) = delete;
  NodeOpGLSLstd450IMix &operator=(NodeOpGLSLstd450IMix &&) = delete;
  NodeOpGLSLstd450IMix(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> y,
    NodePointer<NodeId> a)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->a = a;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450NClamp
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::NClamp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> minVal;
  NodePointer<NodeId> maxVal;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(minVal);
    visitor(maxVal);
  }
  NodeOpGLSLstd450NClamp() = default;
  ~NodeOpGLSLstd450NClamp() = default;
  NodeOpGLSLstd450NClamp(const NodeOpGLSLstd450NClamp &) = delete;
  NodeOpGLSLstd450NClamp &operator=(const NodeOpGLSLstd450NClamp &) = delete;
  NodeOpGLSLstd450NClamp(NodeOpGLSLstd450NClamp &&) = delete;
  NodeOpGLSLstd450NClamp &operator=(NodeOpGLSLstd450NClamp &&) = delete;
  NodeOpGLSLstd450NClamp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> min_val,
    NodePointer<NodeId> max_val)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->minVal = min_val;
    this->maxVal = max_val;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitFieldSExtract
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpBitFieldSExtract;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> offset;
  NodePointer<NodeId> count;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(offset);
    visitor(count);
  }
  NodeOpBitFieldSExtract() = default;
  ~NodeOpBitFieldSExtract() = default;
  NodeOpBitFieldSExtract(const NodeOpBitFieldSExtract &) = delete;
  NodeOpBitFieldSExtract &operator=(const NodeOpBitFieldSExtract &) = delete;
  NodeOpBitFieldSExtract(NodeOpBitFieldSExtract &&) = delete;
  NodeOpBitFieldSExtract &operator=(NodeOpBitFieldSExtract &&) = delete;
  NodeOpBitFieldSExtract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> offset,
    NodePointer<NodeId> count)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->offset = offset;
    this->count = count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitFieldUExtract
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpBitFieldUExtract;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> offset;
  NodePointer<NodeId> count;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(offset);
    visitor(count);
  }
  NodeOpBitFieldUExtract() = default;
  ~NodeOpBitFieldUExtract() = default;
  NodeOpBitFieldUExtract(const NodeOpBitFieldUExtract &) = delete;
  NodeOpBitFieldUExtract &operator=(const NodeOpBitFieldUExtract &) = delete;
  NodeOpBitFieldUExtract(NodeOpBitFieldUExtract &&) = delete;
  NodeOpBitFieldUExtract &operator=(NodeOpBitFieldUExtract &&) = delete;
  NodeOpBitFieldUExtract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> offset,
    NodePointer<NodeId> count)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->offset = offset;
    this->count = count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBuildNDRange
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpBuildNDRange;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> globalWorkSize;
  NodePointer<NodeId> localWorkSize;
  NodePointer<NodeId> globalWorkOffset;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(globalWorkSize);
    visitor(localWorkSize);
    visitor(globalWorkOffset);
  }
  NodeOpBuildNDRange() = default;
  ~NodeOpBuildNDRange() = default;
  NodeOpBuildNDRange(const NodeOpBuildNDRange &) = delete;
  NodeOpBuildNDRange &operator=(const NodeOpBuildNDRange &) = delete;
  NodeOpBuildNDRange(NodeOpBuildNDRange &&) = delete;
  NodeOpBuildNDRange &operator=(NodeOpBuildNDRange &&) = delete;
  NodeOpBuildNDRange(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> global_work_size,
    NodePointer<NodeId> local_work_size, NodePointer<NodeId> global_work_offset)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->globalWorkSize = global_work_size;
    this->localWorkSize = local_work_size;
    this->globalWorkOffset = global_work_offset;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixLoadNV
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpCooperativeMatrixLoadNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeId> stride;
  NodePointer<NodeId> columnMajor;
  eastl::optional<MemoryAccessMask> memoryAccess;
  // extra values for memoryAccess
  LiteralInteger memoryAccessAligned;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailable;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccessMakePointerVisible;
  NodePointer<NodeOperation> memoryAccessMakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccessAliasScopeINTELMask;
  NodePointer<NodeId> memoryAccessNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(stride);
    visitor(columnMajor);
    if (memoryAccessMakePointerAvailable)
      visitor(memoryAccessMakePointerAvailable);
    if (memoryAccessMakePointerAvailableKHR)
      visitor(memoryAccessMakePointerAvailableKHR);
    if (memoryAccessMakePointerVisible)
      visitor(memoryAccessMakePointerVisible);
    if (memoryAccessMakePointerVisibleKHR)
      visitor(memoryAccessMakePointerVisibleKHR);
    if (memoryAccessAliasScopeINTELMask)
      visitor(memoryAccessAliasScopeINTELMask);
    if (memoryAccessNoAliasINTELMask)
      visitor(memoryAccessNoAliasINTELMask);
  }
  NodeOpCooperativeMatrixLoadNV() = default;
  ~NodeOpCooperativeMatrixLoadNV() = default;
  NodeOpCooperativeMatrixLoadNV(const NodeOpCooperativeMatrixLoadNV &) = delete;
  NodeOpCooperativeMatrixLoadNV &operator=(const NodeOpCooperativeMatrixLoadNV &) = delete;
  NodeOpCooperativeMatrixLoadNV(NodeOpCooperativeMatrixLoadNV &&) = delete;
  NodeOpCooperativeMatrixLoadNV &operator=(NodeOpCooperativeMatrixLoadNV &&) = delete;
  NodeOpCooperativeMatrixLoadNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeId> stride, NodePointer<NodeId> column_major, eastl::optional<MemoryAccessMask> memory_access,
    eastl::optional<LiteralInteger> memory_access_aligned = {}, NodePointer<NodeOperation> memory_access_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access_noAliasINTELMask = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->stride = stride;
    this->columnMajor = column_major;
    this->memoryAccess = memory_access;
    if (memory_access_aligned)
      this->memoryAccessAligned = *memory_access_aligned;
    this->memoryAccessMakePointerAvailable = memory_access_makePointerAvailable;
    this->memoryAccessMakePointerAvailableKHR = memory_access_makePointerAvailableKHR;
    this->memoryAccessMakePointerVisible = memory_access_makePointerVisible;
    this->memoryAccessMakePointerVisibleKHR = memory_access_makePointerVisibleKHR;
    this->memoryAccessAliasScopeINTELMask = memory_access_aliasScopeINTELMask;
    this->memoryAccessNoAliasINTELMask = memory_access_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixMulAddKHR
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpCooperativeMatrixMulAddKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  NodePointer<NodeId> b;
  NodePointer<NodeId> c;
  eastl::optional<CooperativeMatrixOperandsMask> cooperativeMatrixOperands;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
    visitor(c);
  }
  NodeOpCooperativeMatrixMulAddKHR() = default;
  ~NodeOpCooperativeMatrixMulAddKHR() = default;
  NodeOpCooperativeMatrixMulAddKHR(const NodeOpCooperativeMatrixMulAddKHR &) = delete;
  NodeOpCooperativeMatrixMulAddKHR &operator=(const NodeOpCooperativeMatrixMulAddKHR &) = delete;
  NodeOpCooperativeMatrixMulAddKHR(NodeOpCooperativeMatrixMulAddKHR &&) = delete;
  NodeOpCooperativeMatrixMulAddKHR &operator=(NodeOpCooperativeMatrixMulAddKHR &&) = delete;
  NodeOpCooperativeMatrixMulAddKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, NodePointer<NodeId> b,
    NodePointer<NodeId> c, eastl::optional<CooperativeMatrixOperandsMask> cooperative_matrix_operands = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->b = b;
    this->c = c;
    this->cooperativeMatrixOperands = cooperative_matrix_operands;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixMulAddNV
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpCooperativeMatrixMulAddNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  NodePointer<NodeId> b;
  NodePointer<NodeId> c;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
    visitor(c);
  }
  NodeOpCooperativeMatrixMulAddNV() = default;
  ~NodeOpCooperativeMatrixMulAddNV() = default;
  NodeOpCooperativeMatrixMulAddNV(const NodeOpCooperativeMatrixMulAddNV &) = delete;
  NodeOpCooperativeMatrixMulAddNV &operator=(const NodeOpCooperativeMatrixMulAddNV &) = delete;
  NodeOpCooperativeMatrixMulAddNV(NodeOpCooperativeMatrixMulAddNV &&) = delete;
  NodeOpCooperativeMatrixMulAddNV &operator=(NodeOpCooperativeMatrixMulAddNV &&) = delete;
  NodeOpCooperativeMatrixMulAddNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, NodePointer<NodeId> b,
    NodePointer<NodeId> c)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->b = b;
    this->c = c;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetMaxPipePackets
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpGetMaxPipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGetMaxPipePackets() = default;
  ~NodeOpGetMaxPipePackets() = default;
  NodeOpGetMaxPipePackets(const NodeOpGetMaxPipePackets &) = delete;
  NodeOpGetMaxPipePackets &operator=(const NodeOpGetMaxPipePackets &) = delete;
  NodeOpGetMaxPipePackets(NodeOpGetMaxPipePackets &&) = delete;
  NodeOpGetMaxPipePackets &operator=(NodeOpGetMaxPipePackets &&) = delete;
  NodeOpGetMaxPipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGetNumPipePackets
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpGetNumPipePackets;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pipe;
  NodePointer<NodeId> packetSize;
  NodePointer<NodeId> packetAlignment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipe);
    visitor(packetSize);
    visitor(packetAlignment);
  }
  NodeOpGetNumPipePackets() = default;
  ~NodeOpGetNumPipePackets() = default;
  NodeOpGetNumPipePackets(const NodeOpGetNumPipePackets &) = delete;
  NodeOpGetNumPipePackets &operator=(const NodeOpGetNumPipePackets &) = delete;
  NodeOpGetNumPipePackets(NodeOpGetNumPipePackets &&) = delete;
  NodeOpGetNumPipePackets &operator=(NodeOpGetNumPipePackets &&) = delete;
  NodeOpGetNumPipePackets(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe,
    NodePointer<NodeId> packet_size, NodePointer<NodeId> packet_alignment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipe = pipe;
    this->packetSize = packet_size;
    this->packetAlignment = packet_alignment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageBoxFilterQCOM
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpImageBoxFilterQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> texture;
  NodePointer<NodeId> coordinates;
  NodePointer<NodeId> boxSize;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(texture);
    visitor(coordinates);
    visitor(boxSize);
  }
  NodeOpImageBoxFilterQCOM() = default;
  ~NodeOpImageBoxFilterQCOM() = default;
  NodeOpImageBoxFilterQCOM(const NodeOpImageBoxFilterQCOM &) = delete;
  NodeOpImageBoxFilterQCOM &operator=(const NodeOpImageBoxFilterQCOM &) = delete;
  NodeOpImageBoxFilterQCOM(NodeOpImageBoxFilterQCOM &&) = delete;
  NodeOpImageBoxFilterQCOM &operator=(NodeOpImageBoxFilterQCOM &&) = delete;
  NodeOpImageBoxFilterQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> texture,
    NodePointer<NodeId> coordinates, NodePointer<NodeId> box_size)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->texture = texture;
    this->coordinates = coordinates;
    this->boxSize = box_size;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSampleWeightedQCOM
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpImageSampleWeightedQCOM;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> texture;
  NodePointer<NodeId> coordinates;
  NodePointer<NodeId> weights;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(texture);
    visitor(coordinates);
    visitor(weights);
  }
  NodeOpImageSampleWeightedQCOM() = default;
  ~NodeOpImageSampleWeightedQCOM() = default;
  NodeOpImageSampleWeightedQCOM(const NodeOpImageSampleWeightedQCOM &) = delete;
  NodeOpImageSampleWeightedQCOM &operator=(const NodeOpImageSampleWeightedQCOM &) = delete;
  NodeOpImageSampleWeightedQCOM(NodeOpImageSampleWeightedQCOM &&) = delete;
  NodeOpImageSampleWeightedQCOM &operator=(NodeOpImageSampleWeightedQCOM &&) = delete;
  NodeOpImageSampleWeightedQCOM(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> texture,
    NodePointer<NodeId> coordinates, NodePointer<NodeId> weights)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->texture = texture;
    this->coordinates = coordinates;
    this->weights = weights;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSDotAccSat
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSDotAccSat;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpSDotAccSat() = default;
  ~NodeOpSDotAccSat() = default;
  NodeOpSDotAccSat(const NodeOpSDotAccSat &) = delete;
  NodeOpSDotAccSat &operator=(const NodeOpSDotAccSat &) = delete;
  NodeOpSDotAccSat(NodeOpSDotAccSat &&) = delete;
  NodeOpSDotAccSat &operator=(NodeOpSDotAccSat &&) = delete;
  NodeOpSDotAccSat(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSDotAccSatKHR
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSDotAccSatKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpSDotAccSatKHR() = default;
  ~NodeOpSDotAccSatKHR() = default;
  NodeOpSDotAccSatKHR(const NodeOpSDotAccSatKHR &) = delete;
  NodeOpSDotAccSatKHR &operator=(const NodeOpSDotAccSatKHR &) = delete;
  NodeOpSDotAccSatKHR(NodeOpSDotAccSatKHR &&) = delete;
  NodeOpSDotAccSatKHR &operator=(NodeOpSDotAccSatKHR &&) = delete;
  NodeOpSDotAccSatKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1,
    NodePointer<NodeId> vector_2, NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSUDotAccSat
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSUDotAccSat;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpSUDotAccSat() = default;
  ~NodeOpSUDotAccSat() = default;
  NodeOpSUDotAccSat(const NodeOpSUDotAccSat &) = delete;
  NodeOpSUDotAccSat &operator=(const NodeOpSUDotAccSat &) = delete;
  NodeOpSUDotAccSat(NodeOpSUDotAccSat &&) = delete;
  NodeOpSUDotAccSat &operator=(NodeOpSUDotAccSat &&) = delete;
  NodeOpSUDotAccSat(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSUDotAccSatKHR
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSUDotAccSatKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpSUDotAccSatKHR() = default;
  ~NodeOpSUDotAccSatKHR() = default;
  NodeOpSUDotAccSatKHR(const NodeOpSUDotAccSatKHR &) = delete;
  NodeOpSUDotAccSatKHR &operator=(const NodeOpSUDotAccSatKHR &) = delete;
  NodeOpSUDotAccSatKHR(NodeOpSUDotAccSatKHR &&) = delete;
  NodeOpSUDotAccSatKHR &operator=(NodeOpSUDotAccSatKHR &&) = delete;
  NodeOpSUDotAccSatKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1,
    NodePointer<NodeId> vector_2, NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSelect
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSelect;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> condition;
  NodePointer<NodeId> object1;
  NodePointer<NodeId> object2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(condition);
    visitor(object1);
    visitor(object2);
  }
  NodeOpSelect() = default;
  ~NodeOpSelect() = default;
  NodeOpSelect(const NodeOpSelect &) = delete;
  NodeOpSelect &operator=(const NodeOpSelect &) = delete;
  NodeOpSelect(NodeOpSelect &&) = delete;
  NodeOpSelect &operator=(NodeOpSelect &&) = delete;
  NodeOpSelect(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> condition, NodePointer<NodeId> object_1,
    NodePointer<NodeId> object_2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->condition = condition;
    this->object1 = object_1;
    this->object2 = object_2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &operator=(NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL() = default;
  ~NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL() = default;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &operator=(
    const NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &operator=(
    NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  NodePointer<NodeId> direction;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
    visitor(direction);
  }
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape, NodePointer<NodeId> direction)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
    this->direction = direction;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  NodePointer<NodeId> direction;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
    visitor(direction);
  }
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape, NodePointer<NodeId> direction)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
    this->direction = direction;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  NodePointer<NodeId> majorShape;
  NodePointer<NodeId> direction;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
    visitor(majorShape);
    visitor(direction);
  }
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL() = default;
  ~NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL() = default;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &operator=(
    const NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &operator=(
    NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload, NodePointer<NodeId> major_shape, NodePointer<NodeId> direction)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
    this->majorShape = major_shape;
    this->direction = direction;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeInitializeINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeInitializeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcCoord;
  NodePointer<NodeId> partitionMask;
  NodePointer<NodeId> sadAdjustment;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcCoord);
    visitor(partitionMask);
    visitor(sadAdjustment);
  }
  NodeOpSubgroupAvcImeInitializeINTEL() = default;
  ~NodeOpSubgroupAvcImeInitializeINTEL() = default;
  NodeOpSubgroupAvcImeInitializeINTEL(const NodeOpSubgroupAvcImeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcImeInitializeINTEL &operator=(const NodeOpSubgroupAvcImeInitializeINTEL &) = delete;
  NodeOpSubgroupAvcImeInitializeINTEL(NodeOpSubgroupAvcImeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcImeInitializeINTEL &operator=(NodeOpSubgroupAvcImeInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcImeInitializeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> src_coord,
    NodePointer<NodeId> partition_mask, NodePointer<NodeId> s_a_d_adjustment)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcCoord = src_coord;
    this->partitionMask = partition_mask;
    this->sadAdjustment = s_a_d_adjustment;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetSingleReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetSingleReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> refOffset;
  NodePointer<NodeId> searchWindowConfig;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(refOffset);
    visitor(searchWindowConfig);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL() = default;
  ~NodeOpSubgroupAvcImeSetSingleReferenceINTEL() = default;
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL(const NodeOpSubgroupAvcImeSetSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL &operator=(const NodeOpSubgroupAvcImeSetSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL(NodeOpSubgroupAvcImeSetSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL &operator=(NodeOpSubgroupAvcImeSetSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetSingleReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ref_offset,
    NodePointer<NodeId> search_window_config, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->refOffset = ref_offset;
    this->searchWindowConfig = search_window_config;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> packedReferenceIds;
  NodePointer<NodeId> packedReferenceParameterFieldPolarities;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(packedReferenceIds);
    visitor(packedReferenceParameterFieldPolarities);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL() = default;
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(
    const NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &operator=(
    const NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(
    NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &operator=(
    NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> packed_reference_ids, NodePointer<NodeId> packed_reference_parameter_field_polarities,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->packedReferenceIds = packed_reference_ids;
    this->packedReferenceParameterFieldPolarities = packed_reference_parameter_field_polarities;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> forwardReferenceFieldPolarity;
  NodePointer<NodeId> backwardReferenceFieldPolarity;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(forwardReferenceFieldPolarity);
    visitor(backwardReferenceFieldPolarity);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL() = default;
  ~NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL() = default;
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(
    const NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &) = delete;
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &operator=(
    const NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &) = delete;
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(
    NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &operator=(
    NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> forward_reference_field_polarity, NodePointer<NodeId> backward_reference_field_polarity,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->forwardReferenceFieldPolarity = forward_reference_field_polarity;
    this->backwardReferenceFieldPolarity = backward_reference_field_polarity;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> packedReferenceIds;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(packedReferenceIds);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL() = default;
  ~NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL() = default;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(const NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &operator=(const NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &operator=(NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> packed_reference_ids, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->packedReferenceIds = packed_reference_ids;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL() = default;
  ~NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL() = default;
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(const NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &operator=(
    const NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &operator=(NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> packedReferenceIds;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(packedReferenceIds);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL() = default;
  ~NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL() = default;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(const NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &operator=(const NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &operator=(NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> packed_reference_ids, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->packedReferenceIds = packed_reference_ids;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcImage;
  NodePointer<NodeId> refImage;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcImage);
    visitor(refImage);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL() = default;
  ~NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL() = default;
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(const NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &operator=(
    const NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &) = delete;
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &operator=(NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL &&) = delete;
  NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> src_image, NodePointer<NodeId> ref_image, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcImage = src_image;
    this->refImage = ref_image;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupShuffleDownINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupShuffleDownINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> current;
  NodePointer<NodeId> next;
  NodePointer<NodeId> delta;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(current);
    visitor(next);
    visitor(delta);
  }
  NodeOpSubgroupShuffleDownINTEL() = default;
  ~NodeOpSubgroupShuffleDownINTEL() = default;
  NodeOpSubgroupShuffleDownINTEL(const NodeOpSubgroupShuffleDownINTEL &) = delete;
  NodeOpSubgroupShuffleDownINTEL &operator=(const NodeOpSubgroupShuffleDownINTEL &) = delete;
  NodeOpSubgroupShuffleDownINTEL(NodeOpSubgroupShuffleDownINTEL &&) = delete;
  NodeOpSubgroupShuffleDownINTEL &operator=(NodeOpSubgroupShuffleDownINTEL &&) = delete;
  NodeOpSubgroupShuffleDownINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> current,
    NodePointer<NodeId> next, NodePointer<NodeId> delta)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->current = current;
    this->next = next;
    this->delta = delta;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupShuffleUpINTEL
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpSubgroupShuffleUpINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> previous;
  NodePointer<NodeId> current;
  NodePointer<NodeId> delta;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(previous);
    visitor(current);
    visitor(delta);
  }
  NodeOpSubgroupShuffleUpINTEL() = default;
  ~NodeOpSubgroupShuffleUpINTEL() = default;
  NodeOpSubgroupShuffleUpINTEL(const NodeOpSubgroupShuffleUpINTEL &) = delete;
  NodeOpSubgroupShuffleUpINTEL &operator=(const NodeOpSubgroupShuffleUpINTEL &) = delete;
  NodeOpSubgroupShuffleUpINTEL(NodeOpSubgroupShuffleUpINTEL &&) = delete;
  NodeOpSubgroupShuffleUpINTEL &operator=(NodeOpSubgroupShuffleUpINTEL &&) = delete;
  NodeOpSubgroupShuffleUpINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> previous,
    NodePointer<NodeId> current, NodePointer<NodeId> delta)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->previous = previous;
    this->current = current;
    this->delta = delta;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUDotAccSat
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpUDotAccSat;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpUDotAccSat() = default;
  ~NodeOpUDotAccSat() = default;
  NodeOpUDotAccSat(const NodeOpUDotAccSat &) = delete;
  NodeOpUDotAccSat &operator=(const NodeOpUDotAccSat &) = delete;
  NodeOpUDotAccSat(NodeOpUDotAccSat &&) = delete;
  NodeOpUDotAccSat &operator=(NodeOpUDotAccSat &&) = delete;
  NodeOpUDotAccSat(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1, NodePointer<NodeId> vector_2,
    NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUDotAccSatKHR
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpUDotAccSatKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector1;
  NodePointer<NodeId> vector2;
  NodePointer<NodeId> accumulator;
  eastl::optional<PackedVectorFormat> packedVectorFormat;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector1);
    visitor(vector2);
    visitor(accumulator);
  }
  NodeOpUDotAccSatKHR() = default;
  ~NodeOpUDotAccSatKHR() = default;
  NodeOpUDotAccSatKHR(const NodeOpUDotAccSatKHR &) = delete;
  NodeOpUDotAccSatKHR &operator=(const NodeOpUDotAccSatKHR &) = delete;
  NodeOpUDotAccSatKHR(NodeOpUDotAccSatKHR &&) = delete;
  NodeOpUDotAccSatKHR &operator=(NodeOpUDotAccSatKHR &&) = delete;
  NodeOpUDotAccSatKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector_1,
    NodePointer<NodeId> vector_2, NodePointer<NodeId> accumulator, eastl::optional<PackedVectorFormat> packed_vector_format = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector1 = vector_1;
    this->vector2 = vector_2;
    this->accumulator = accumulator;
    this->packedVectorFormat = packed_vector_format;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVectorInsertDynamic
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpVectorInsertDynamic;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  NodePointer<NodeId> component;
  NodePointer<NodeId> index;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
    visitor(component);
    visitor(index);
  }
  NodeOpVectorInsertDynamic() = default;
  ~NodeOpVectorInsertDynamic() = default;
  NodeOpVectorInsertDynamic(const NodeOpVectorInsertDynamic &) = delete;
  NodeOpVectorInsertDynamic &operator=(const NodeOpVectorInsertDynamic &) = delete;
  NodeOpVectorInsertDynamic(NodeOpVectorInsertDynamic &&) = delete;
  NodeOpVectorInsertDynamic &operator=(NodeOpVectorInsertDynamic &&) = delete;
  NodeOpVectorInsertDynamic(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector,
    NodePointer<NodeId> component, NodePointer<NodeId> index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
    this->component = component;
    this->index = index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Refract
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Refract;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> i;
  NodePointer<NodeId> n;
  NodePointer<NodeId> eta;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(i);
    visitor(n);
    visitor(eta);
  }
  NodeOpGLSLstd450Refract() = default;
  ~NodeOpGLSLstd450Refract() = default;
  NodeOpGLSLstd450Refract(const NodeOpGLSLstd450Refract &) = delete;
  NodeOpGLSLstd450Refract &operator=(const NodeOpGLSLstd450Refract &) = delete;
  NodeOpGLSLstd450Refract(NodeOpGLSLstd450Refract &&) = delete;
  NodeOpGLSLstd450Refract &operator=(NodeOpGLSLstd450Refract &&) = delete;
  NodeOpGLSLstd450Refract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> i, NodePointer<NodeId> n,
    NodePointer<NodeId> eta)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->i = i;
    this->n = n;
    this->eta = eta;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SClamp
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SClamp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> minVal;
  NodePointer<NodeId> maxVal;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(minVal);
    visitor(maxVal);
  }
  NodeOpGLSLstd450SClamp() = default;
  ~NodeOpGLSLstd450SClamp() = default;
  NodeOpGLSLstd450SClamp(const NodeOpGLSLstd450SClamp &) = delete;
  NodeOpGLSLstd450SClamp &operator=(const NodeOpGLSLstd450SClamp &) = delete;
  NodeOpGLSLstd450SClamp(NodeOpGLSLstd450SClamp &&) = delete;
  NodeOpGLSLstd450SClamp &operator=(NodeOpGLSLstd450SClamp &&) = delete;
  NodeOpGLSLstd450SClamp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> min_val,
    NodePointer<NodeId> max_val)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->minVal = min_val;
    this->maxVal = max_val;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxSMax3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::SMax3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxSMax3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxSMax3() = default;
  NodeOpAMDShaderTrinaryMinmaxSMax3(const NodeOpAMDShaderTrinaryMinmaxSMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMax3 &operator=(const NodeOpAMDShaderTrinaryMinmaxSMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMax3(NodeOpAMDShaderTrinaryMinmaxSMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMax3 &operator=(NodeOpAMDShaderTrinaryMinmaxSMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMax3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxSMid3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::SMid3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxSMid3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxSMid3() = default;
  NodeOpAMDShaderTrinaryMinmaxSMid3(const NodeOpAMDShaderTrinaryMinmaxSMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMid3 &operator=(const NodeOpAMDShaderTrinaryMinmaxSMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMid3(NodeOpAMDShaderTrinaryMinmaxSMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMid3 &operator=(NodeOpAMDShaderTrinaryMinmaxSMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMid3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxSMin3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::SMin3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxSMin3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxSMin3() = default;
  NodeOpAMDShaderTrinaryMinmaxSMin3(const NodeOpAMDShaderTrinaryMinmaxSMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMin3 &operator=(const NodeOpAMDShaderTrinaryMinmaxSMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMin3(NodeOpAMDShaderTrinaryMinmaxSMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMin3 &operator=(NodeOpAMDShaderTrinaryMinmaxSMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxSMin3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SmoothStep
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SmoothStep;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> edge0;
  NodePointer<NodeId> edge1;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(edge0);
    visitor(edge1);
    visitor(x);
  }
  NodeOpGLSLstd450SmoothStep() = default;
  ~NodeOpGLSLstd450SmoothStep() = default;
  NodeOpGLSLstd450SmoothStep(const NodeOpGLSLstd450SmoothStep &) = delete;
  NodeOpGLSLstd450SmoothStep &operator=(const NodeOpGLSLstd450SmoothStep &) = delete;
  NodeOpGLSLstd450SmoothStep(NodeOpGLSLstd450SmoothStep &&) = delete;
  NodeOpGLSLstd450SmoothStep &operator=(NodeOpGLSLstd450SmoothStep &&) = delete;
  NodeOpGLSLstd450SmoothStep(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> edge0,
    NodePointer<NodeId> edge1, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->edge0 = edge0;
    this->edge1 = edge1;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UClamp
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UClamp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> minVal;
  NodePointer<NodeId> maxVal;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(minVal);
    visitor(maxVal);
  }
  NodeOpGLSLstd450UClamp() = default;
  ~NodeOpGLSLstd450UClamp() = default;
  NodeOpGLSLstd450UClamp(const NodeOpGLSLstd450UClamp &) = delete;
  NodeOpGLSLstd450UClamp &operator=(const NodeOpGLSLstd450UClamp &) = delete;
  NodeOpGLSLstd450UClamp(NodeOpGLSLstd450UClamp &&) = delete;
  NodeOpGLSLstd450UClamp &operator=(NodeOpGLSLstd450UClamp &&) = delete;
  NodeOpGLSLstd450UClamp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x, NodePointer<NodeId> min_val,
    NodePointer<NodeId> max_val)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->minVal = min_val;
    this->maxVal = max_val;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxUMax3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::UMax3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxUMax3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxUMax3() = default;
  NodeOpAMDShaderTrinaryMinmaxUMax3(const NodeOpAMDShaderTrinaryMinmaxUMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMax3 &operator=(const NodeOpAMDShaderTrinaryMinmaxUMax3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMax3(NodeOpAMDShaderTrinaryMinmaxUMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMax3 &operator=(NodeOpAMDShaderTrinaryMinmaxUMax3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMax3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxUMid3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::UMid3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxUMid3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxUMid3() = default;
  NodeOpAMDShaderTrinaryMinmaxUMid3(const NodeOpAMDShaderTrinaryMinmaxUMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMid3 &operator=(const NodeOpAMDShaderTrinaryMinmaxUMid3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMid3(NodeOpAMDShaderTrinaryMinmaxUMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMid3 &operator=(NodeOpAMDShaderTrinaryMinmaxUMid3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMid3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderTrinaryMinmaxUMin3
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderTrinaryMinmax extOpCode = AMDShaderTrinaryMinmax::UMin3AMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_trinary_minmax;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  NodePointer<NodeId> y;
  NodePointer<NodeId> z;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
    visitor(y);
    visitor(z);
  }
  NodeOpAMDShaderTrinaryMinmaxUMin3() = default;
  ~NodeOpAMDShaderTrinaryMinmaxUMin3() = default;
  NodeOpAMDShaderTrinaryMinmaxUMin3(const NodeOpAMDShaderTrinaryMinmaxUMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMin3 &operator=(const NodeOpAMDShaderTrinaryMinmaxUMin3 &) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMin3(NodeOpAMDShaderTrinaryMinmaxUMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMin3 &operator=(NodeOpAMDShaderTrinaryMinmaxUMin3 &&) = delete;
  NodeOpAMDShaderTrinaryMinmaxUMin3(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x,
    NodePointer<NodeId> y, NodePointer<NodeId> z)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
    this->y = y;
    this->z = z;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderBallotWriteInvocation
{
  const NodeKind nodeKind = NodeKind::TrinaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderBallot extOpCode = AMDShaderBallot::WriteInvocationAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_ballot;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> inputValue;
  NodePointer<NodeId> writeValue;
  NodePointer<NodeId> invocationIndex;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(inputValue);
    visitor(writeValue);
    visitor(invocationIndex);
  }
  NodeOpAMDShaderBallotWriteInvocation() = default;
  ~NodeOpAMDShaderBallotWriteInvocation() = default;
  NodeOpAMDShaderBallotWriteInvocation(const NodeOpAMDShaderBallotWriteInvocation &) = delete;
  NodeOpAMDShaderBallotWriteInvocation &operator=(const NodeOpAMDShaderBallotWriteInvocation &) = delete;
  NodeOpAMDShaderBallotWriteInvocation(NodeOpAMDShaderBallotWriteInvocation &&) = delete;
  NodeOpAMDShaderBallotWriteInvocation &operator=(NodeOpAMDShaderBallotWriteInvocation &&) = delete;
  NodeOpAMDShaderBallotWriteInvocation(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> input_value,
    NodePointer<NodeId> write_value, NodePointer<NodeId> invocation_index)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->inputValue = input_value;
    this->writeValue = write_value;
    this->invocationIndex = invocation_index;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeTrinaryOperation::visit(NodeTrinaryOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::TrinaryOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpBitFieldSExtract:
        if (visitor(reinterpret_cast<NodeOpBitFieldSExtract *>(node)))
          return true;
        break;
      case Op::OpBitFieldUExtract:
        if (visitor(reinterpret_cast<NodeOpBitFieldUExtract *>(node)))
          return true;
        break;
      case Op::OpBuildNDRange:
        if (visitor(reinterpret_cast<NodeOpBuildNDRange *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixLoadNV:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixLoadNV *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixMulAddKHR:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixMulAddKHR *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixMulAddNV:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixMulAddNV *>(node)))
          return true;
        break;
      case Op::OpGetMaxPipePackets:
        if (visitor(reinterpret_cast<NodeOpGetMaxPipePackets *>(node)))
          return true;
        break;
      case Op::OpGetNumPipePackets:
        if (visitor(reinterpret_cast<NodeOpGetNumPipePackets *>(node)))
          return true;
        break;
      case Op::OpImageBoxFilterQCOM:
        if (visitor(reinterpret_cast<NodeOpImageBoxFilterQCOM *>(node)))
          return true;
        break;
      case Op::OpImageSampleWeightedQCOM:
        if (visitor(reinterpret_cast<NodeOpImageSampleWeightedQCOM *>(node)))
          return true;
        break;
      case Op::OpSDotAccSat:
        if (visitor(reinterpret_cast<NodeOpSDotAccSat *>(node)))
          return true;
        break;
      // duplicated OpSDotAccSatKHR = 4453
      case Op::OpSUDotAccSat:
        if (visitor(reinterpret_cast<NodeOpSUDotAccSat *>(node)))
          return true;
        break;
      // duplicated OpSUDotAccSatKHR = 4455
      case Op::OpSelect:
        if (visitor(reinterpret_cast<NodeOpSelect *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeInitializeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeInitializeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetSingleReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetSingleReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupShuffleDownINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupShuffleDownINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupShuffleUpINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupShuffleUpINTEL *>(node)))
          return true;
        break;
      case Op::OpUDotAccSat:
        if (visitor(reinterpret_cast<NodeOpUDotAccSat *>(node)))
          return true;
        break;
      // duplicated OpUDotAccSatKHR = 4454
      case Op::OpVectorInsertDynamic:
        if (visitor(reinterpret_cast<NodeOpVectorInsertDynamic *>(node)))
          return true;
        break;
      case Op::OpExtInst:
        switch (node->grammarId)
        {
          default: break;
          case ExtendedGrammar::GLSL_std_450:
            switch (static_cast<GLSLstd450>(node->extOpCode))
            {
              default: break;
              case GLSLstd450::FClamp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FClamp *>(node)))
                  return true;
                break;
              case GLSLstd450::FMix:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FMix *>(node)))
                  return true;
                break;
              case GLSLstd450::FaceForward:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FaceForward *>(node)))
                  return true;
                break;
              case GLSLstd450::Fma:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Fma *>(node)))
                  return true;
                break;
              case GLSLstd450::IMix:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450IMix *>(node)))
                  return true;
                break;
              case GLSLstd450::NClamp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450NClamp *>(node)))
                  return true;
                break;
              case GLSLstd450::Refract:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Refract *>(node)))
                  return true;
                break;
              case GLSLstd450::SClamp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SClamp *>(node)))
                  return true;
                break;
              case GLSLstd450::SmoothStep:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SmoothStep *>(node)))
                  return true;
                break;
              case GLSLstd450::UClamp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UClamp *>(node)))
                  return true;
                break;
            }
            break;
          case ExtendedGrammar::AMD_shader_trinary_minmax:
            switch (static_cast<AMDShaderTrinaryMinmax>(node->extOpCode))
            {
              default: break;
              case AMDShaderTrinaryMinmax::FMax3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxFMax3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::FMid3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxFMid3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::FMin3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxFMin3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::SMax3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxSMax3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::SMid3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxSMid3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::SMin3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxSMin3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::UMax3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxUMax3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::UMid3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxUMid3 *>(node)))
                  return true;
                break;
              case AMDShaderTrinaryMinmax::UMin3AMD:
                if (visitor(reinterpret_cast<NodeOpAMDShaderTrinaryMinmaxUMin3 *>(node)))
                  return true;
                break;
            }
            break;
          case ExtendedGrammar::AMD_shader_ballot: // only one instruction for this grammar
            if (static_cast<AMDShaderBallot>(node->extOpCode) == AMDShaderBallot::WriteInvocationAMD)
            {
              if (visitor(reinterpret_cast<NodeOpAMDShaderBallotWriteInvocation *>(node)))
                return true;
            }
            break;
        }
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeUnaryOperation : NodeOperation
{
  NodePointer<NodeId> first;
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeUnaryOperation *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpGLSLstd450Acos
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Acos;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Acos() = default;
  ~NodeOpGLSLstd450Acos() = default;
  NodeOpGLSLstd450Acos(const NodeOpGLSLstd450Acos &) = delete;
  NodeOpGLSLstd450Acos &operator=(const NodeOpGLSLstd450Acos &) = delete;
  NodeOpGLSLstd450Acos(NodeOpGLSLstd450Acos &&) = delete;
  NodeOpGLSLstd450Acos &operator=(NodeOpGLSLstd450Acos &&) = delete;
  NodeOpGLSLstd450Acos(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Acosh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Acosh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Acosh() = default;
  ~NodeOpGLSLstd450Acosh() = default;
  NodeOpGLSLstd450Acosh(const NodeOpGLSLstd450Acosh &) = delete;
  NodeOpGLSLstd450Acosh &operator=(const NodeOpGLSLstd450Acosh &) = delete;
  NodeOpGLSLstd450Acosh(NodeOpGLSLstd450Acosh &&) = delete;
  NodeOpGLSLstd450Acosh &operator=(NodeOpGLSLstd450Acosh &&) = delete;
  NodeOpGLSLstd450Acosh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Asin
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Asin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Asin() = default;
  ~NodeOpGLSLstd450Asin() = default;
  NodeOpGLSLstd450Asin(const NodeOpGLSLstd450Asin &) = delete;
  NodeOpGLSLstd450Asin &operator=(const NodeOpGLSLstd450Asin &) = delete;
  NodeOpGLSLstd450Asin(NodeOpGLSLstd450Asin &&) = delete;
  NodeOpGLSLstd450Asin &operator=(NodeOpGLSLstd450Asin &&) = delete;
  NodeOpGLSLstd450Asin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Asinh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Asinh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Asinh() = default;
  ~NodeOpGLSLstd450Asinh() = default;
  NodeOpGLSLstd450Asinh(const NodeOpGLSLstd450Asinh &) = delete;
  NodeOpGLSLstd450Asinh &operator=(const NodeOpGLSLstd450Asinh &) = delete;
  NodeOpGLSLstd450Asinh(NodeOpGLSLstd450Asinh &&) = delete;
  NodeOpGLSLstd450Asinh &operator=(NodeOpGLSLstd450Asinh &&) = delete;
  NodeOpGLSLstd450Asinh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Atan
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Atan;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> y_over_x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(y_over_x);
  }
  NodeOpGLSLstd450Atan() = default;
  ~NodeOpGLSLstd450Atan() = default;
  NodeOpGLSLstd450Atan(const NodeOpGLSLstd450Atan &) = delete;
  NodeOpGLSLstd450Atan &operator=(const NodeOpGLSLstd450Atan &) = delete;
  NodeOpGLSLstd450Atan(NodeOpGLSLstd450Atan &&) = delete;
  NodeOpGLSLstd450Atan &operator=(NodeOpGLSLstd450Atan &&) = delete;
  NodeOpGLSLstd450Atan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> y_over_x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->y_over_x = y_over_x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Atanh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Atanh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Atanh() = default;
  ~NodeOpGLSLstd450Atanh() = default;
  NodeOpGLSLstd450Atanh(const NodeOpGLSLstd450Atanh &) = delete;
  NodeOpGLSLstd450Atanh &operator=(const NodeOpGLSLstd450Atanh &) = delete;
  NodeOpGLSLstd450Atanh(NodeOpGLSLstd450Atanh &&) = delete;
  NodeOpGLSLstd450Atanh &operator=(NodeOpGLSLstd450Atanh &&) = delete;
  NodeOpGLSLstd450Atanh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Ceil
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Ceil;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Ceil() = default;
  ~NodeOpGLSLstd450Ceil() = default;
  NodeOpGLSLstd450Ceil(const NodeOpGLSLstd450Ceil &) = delete;
  NodeOpGLSLstd450Ceil &operator=(const NodeOpGLSLstd450Ceil &) = delete;
  NodeOpGLSLstd450Ceil(NodeOpGLSLstd450Ceil &&) = delete;
  NodeOpGLSLstd450Ceil &operator=(NodeOpGLSLstd450Ceil &&) = delete;
  NodeOpGLSLstd450Ceil(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Cos
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Cos;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Cos() = default;
  ~NodeOpGLSLstd450Cos() = default;
  NodeOpGLSLstd450Cos(const NodeOpGLSLstd450Cos &) = delete;
  NodeOpGLSLstd450Cos &operator=(const NodeOpGLSLstd450Cos &) = delete;
  NodeOpGLSLstd450Cos(NodeOpGLSLstd450Cos &&) = delete;
  NodeOpGLSLstd450Cos &operator=(NodeOpGLSLstd450Cos &&) = delete;
  NodeOpGLSLstd450Cos(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Cosh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Cosh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Cosh() = default;
  ~NodeOpGLSLstd450Cosh() = default;
  NodeOpGLSLstd450Cosh(const NodeOpGLSLstd450Cosh &) = delete;
  NodeOpGLSLstd450Cosh &operator=(const NodeOpGLSLstd450Cosh &) = delete;
  NodeOpGLSLstd450Cosh(NodeOpGLSLstd450Cosh &&) = delete;
  NodeOpGLSLstd450Cosh &operator=(NodeOpGLSLstd450Cosh &&) = delete;
  NodeOpGLSLstd450Cosh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDGcnShaderCubeFaceCoord
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDGcnShader extOpCode = AMDGcnShader::CubeFaceCoordAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_gcn_shader;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpAMDGcnShaderCubeFaceCoord() = default;
  ~NodeOpAMDGcnShaderCubeFaceCoord() = default;
  NodeOpAMDGcnShaderCubeFaceCoord(const NodeOpAMDGcnShaderCubeFaceCoord &) = delete;
  NodeOpAMDGcnShaderCubeFaceCoord &operator=(const NodeOpAMDGcnShaderCubeFaceCoord &) = delete;
  NodeOpAMDGcnShaderCubeFaceCoord(NodeOpAMDGcnShaderCubeFaceCoord &&) = delete;
  NodeOpAMDGcnShaderCubeFaceCoord &operator=(NodeOpAMDGcnShaderCubeFaceCoord &&) = delete;
  NodeOpAMDGcnShaderCubeFaceCoord(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDGcnShaderCubeFaceIndex
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDGcnShader extOpCode = AMDGcnShader::CubeFaceIndexAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_gcn_shader;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpAMDGcnShaderCubeFaceIndex() = default;
  ~NodeOpAMDGcnShaderCubeFaceIndex() = default;
  NodeOpAMDGcnShaderCubeFaceIndex(const NodeOpAMDGcnShaderCubeFaceIndex &) = delete;
  NodeOpAMDGcnShaderCubeFaceIndex &operator=(const NodeOpAMDGcnShaderCubeFaceIndex &) = delete;
  NodeOpAMDGcnShaderCubeFaceIndex(NodeOpAMDGcnShaderCubeFaceIndex &&) = delete;
  NodeOpAMDGcnShaderCubeFaceIndex &operator=(NodeOpAMDGcnShaderCubeFaceIndex &&) = delete;
  NodeOpAMDGcnShaderCubeFaceIndex(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Degrees
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Degrees;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> radians;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(radians);
  }
  NodeOpGLSLstd450Degrees() = default;
  ~NodeOpGLSLstd450Degrees() = default;
  NodeOpGLSLstd450Degrees(const NodeOpGLSLstd450Degrees &) = delete;
  NodeOpGLSLstd450Degrees &operator=(const NodeOpGLSLstd450Degrees &) = delete;
  NodeOpGLSLstd450Degrees(NodeOpGLSLstd450Degrees &&) = delete;
  NodeOpGLSLstd450Degrees &operator=(NodeOpGLSLstd450Degrees &&) = delete;
  NodeOpGLSLstd450Degrees(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> radians)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->radians = radians;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Determinant
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Determinant;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Determinant() = default;
  ~NodeOpGLSLstd450Determinant() = default;
  NodeOpGLSLstd450Determinant(const NodeOpGLSLstd450Determinant &) = delete;
  NodeOpGLSLstd450Determinant &operator=(const NodeOpGLSLstd450Determinant &) = delete;
  NodeOpGLSLstd450Determinant(NodeOpGLSLstd450Determinant &&) = delete;
  NodeOpGLSLstd450Determinant &operator=(NodeOpGLSLstd450Determinant &&) = delete;
  NodeOpGLSLstd450Determinant(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Exp
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Exp;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Exp() = default;
  ~NodeOpGLSLstd450Exp() = default;
  NodeOpGLSLstd450Exp(const NodeOpGLSLstd450Exp &) = delete;
  NodeOpGLSLstd450Exp &operator=(const NodeOpGLSLstd450Exp &) = delete;
  NodeOpGLSLstd450Exp(NodeOpGLSLstd450Exp &&) = delete;
  NodeOpGLSLstd450Exp &operator=(NodeOpGLSLstd450Exp &&) = delete;
  NodeOpGLSLstd450Exp(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Exp2
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Exp2;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Exp2() = default;
  ~NodeOpGLSLstd450Exp2() = default;
  NodeOpGLSLstd450Exp2(const NodeOpGLSLstd450Exp2 &) = delete;
  NodeOpGLSLstd450Exp2 &operator=(const NodeOpGLSLstd450Exp2 &) = delete;
  NodeOpGLSLstd450Exp2(NodeOpGLSLstd450Exp2 &&) = delete;
  NodeOpGLSLstd450Exp2 &operator=(NodeOpGLSLstd450Exp2 &&) = delete;
  NodeOpGLSLstd450Exp2(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FAbs
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FAbs;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450FAbs() = default;
  ~NodeOpGLSLstd450FAbs() = default;
  NodeOpGLSLstd450FAbs(const NodeOpGLSLstd450FAbs &) = delete;
  NodeOpGLSLstd450FAbs &operator=(const NodeOpGLSLstd450FAbs &) = delete;
  NodeOpGLSLstd450FAbs(NodeOpGLSLstd450FAbs &&) = delete;
  NodeOpGLSLstd450FAbs &operator=(NodeOpGLSLstd450FAbs &&) = delete;
  NodeOpGLSLstd450FAbs(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FSign
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FSign;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450FSign() = default;
  ~NodeOpGLSLstd450FSign() = default;
  NodeOpGLSLstd450FSign(const NodeOpGLSLstd450FSign &) = delete;
  NodeOpGLSLstd450FSign &operator=(const NodeOpGLSLstd450FSign &) = delete;
  NodeOpGLSLstd450FSign(NodeOpGLSLstd450FSign &&) = delete;
  NodeOpGLSLstd450FSign &operator=(NodeOpGLSLstd450FSign &&) = delete;
  NodeOpGLSLstd450FSign(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FindILsb
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FindILsb;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpGLSLstd450FindILsb() = default;
  ~NodeOpGLSLstd450FindILsb() = default;
  NodeOpGLSLstd450FindILsb(const NodeOpGLSLstd450FindILsb &) = delete;
  NodeOpGLSLstd450FindILsb &operator=(const NodeOpGLSLstd450FindILsb &) = delete;
  NodeOpGLSLstd450FindILsb(NodeOpGLSLstd450FindILsb &&) = delete;
  NodeOpGLSLstd450FindILsb &operator=(NodeOpGLSLstd450FindILsb &&) = delete;
  NodeOpGLSLstd450FindILsb(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FindSMsb
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FindSMsb;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpGLSLstd450FindSMsb() = default;
  ~NodeOpGLSLstd450FindSMsb() = default;
  NodeOpGLSLstd450FindSMsb(const NodeOpGLSLstd450FindSMsb &) = delete;
  NodeOpGLSLstd450FindSMsb &operator=(const NodeOpGLSLstd450FindSMsb &) = delete;
  NodeOpGLSLstd450FindSMsb(NodeOpGLSLstd450FindSMsb &&) = delete;
  NodeOpGLSLstd450FindSMsb &operator=(NodeOpGLSLstd450FindSMsb &&) = delete;
  NodeOpGLSLstd450FindSMsb(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FindUMsb
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FindUMsb;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpGLSLstd450FindUMsb() = default;
  ~NodeOpGLSLstd450FindUMsb() = default;
  NodeOpGLSLstd450FindUMsb(const NodeOpGLSLstd450FindUMsb &) = delete;
  NodeOpGLSLstd450FindUMsb &operator=(const NodeOpGLSLstd450FindUMsb &) = delete;
  NodeOpGLSLstd450FindUMsb(NodeOpGLSLstd450FindUMsb &&) = delete;
  NodeOpGLSLstd450FindUMsb &operator=(NodeOpGLSLstd450FindUMsb &&) = delete;
  NodeOpGLSLstd450FindUMsb(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Floor
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Floor;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Floor() = default;
  ~NodeOpGLSLstd450Floor() = default;
  NodeOpGLSLstd450Floor(const NodeOpGLSLstd450Floor &) = delete;
  NodeOpGLSLstd450Floor &operator=(const NodeOpGLSLstd450Floor &) = delete;
  NodeOpGLSLstd450Floor(NodeOpGLSLstd450Floor &&) = delete;
  NodeOpGLSLstd450Floor &operator=(NodeOpGLSLstd450Floor &&) = delete;
  NodeOpGLSLstd450Floor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Fract
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Fract;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Fract() = default;
  ~NodeOpGLSLstd450Fract() = default;
  NodeOpGLSLstd450Fract(const NodeOpGLSLstd450Fract &) = delete;
  NodeOpGLSLstd450Fract &operator=(const NodeOpGLSLstd450Fract &) = delete;
  NodeOpGLSLstd450Fract(NodeOpGLSLstd450Fract &&) = delete;
  NodeOpGLSLstd450Fract &operator=(NodeOpGLSLstd450Fract &&) = delete;
  NodeOpGLSLstd450Fract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450FrexpStruct
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::FrexpStruct;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450FrexpStruct() = default;
  ~NodeOpGLSLstd450FrexpStruct() = default;
  NodeOpGLSLstd450FrexpStruct(const NodeOpGLSLstd450FrexpStruct &) = delete;
  NodeOpGLSLstd450FrexpStruct &operator=(const NodeOpGLSLstd450FrexpStruct &) = delete;
  NodeOpGLSLstd450FrexpStruct(NodeOpGLSLstd450FrexpStruct &&) = delete;
  NodeOpGLSLstd450FrexpStruct &operator=(NodeOpGLSLstd450FrexpStruct &&) = delete;
  NodeOpGLSLstd450FrexpStruct(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450InterpolateAtCentroid
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::InterpolateAtCentroid;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> interpolant;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(interpolant);
  }
  NodeOpGLSLstd450InterpolateAtCentroid() = default;
  ~NodeOpGLSLstd450InterpolateAtCentroid() = default;
  NodeOpGLSLstd450InterpolateAtCentroid(const NodeOpGLSLstd450InterpolateAtCentroid &) = delete;
  NodeOpGLSLstd450InterpolateAtCentroid &operator=(const NodeOpGLSLstd450InterpolateAtCentroid &) = delete;
  NodeOpGLSLstd450InterpolateAtCentroid(NodeOpGLSLstd450InterpolateAtCentroid &&) = delete;
  NodeOpGLSLstd450InterpolateAtCentroid &operator=(NodeOpGLSLstd450InterpolateAtCentroid &&) = delete;
  NodeOpGLSLstd450InterpolateAtCentroid(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> interpolant)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->interpolant = interpolant;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450InverseSqrt
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::InverseSqrt;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450InverseSqrt() = default;
  ~NodeOpGLSLstd450InverseSqrt() = default;
  NodeOpGLSLstd450InverseSqrt(const NodeOpGLSLstd450InverseSqrt &) = delete;
  NodeOpGLSLstd450InverseSqrt &operator=(const NodeOpGLSLstd450InverseSqrt &) = delete;
  NodeOpGLSLstd450InverseSqrt(NodeOpGLSLstd450InverseSqrt &&) = delete;
  NodeOpGLSLstd450InverseSqrt &operator=(NodeOpGLSLstd450InverseSqrt &&) = delete;
  NodeOpGLSLstd450InverseSqrt(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Length
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Length;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Length() = default;
  ~NodeOpGLSLstd450Length() = default;
  NodeOpGLSLstd450Length(const NodeOpGLSLstd450Length &) = delete;
  NodeOpGLSLstd450Length &operator=(const NodeOpGLSLstd450Length &) = delete;
  NodeOpGLSLstd450Length(NodeOpGLSLstd450Length &&) = delete;
  NodeOpGLSLstd450Length &operator=(NodeOpGLSLstd450Length &&) = delete;
  NodeOpGLSLstd450Length(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Log
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Log;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Log() = default;
  ~NodeOpGLSLstd450Log() = default;
  NodeOpGLSLstd450Log(const NodeOpGLSLstd450Log &) = delete;
  NodeOpGLSLstd450Log &operator=(const NodeOpGLSLstd450Log &) = delete;
  NodeOpGLSLstd450Log(NodeOpGLSLstd450Log &&) = delete;
  NodeOpGLSLstd450Log &operator=(NodeOpGLSLstd450Log &&) = delete;
  NodeOpGLSLstd450Log(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Log2
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Log2;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Log2() = default;
  ~NodeOpGLSLstd450Log2() = default;
  NodeOpGLSLstd450Log2(const NodeOpGLSLstd450Log2 &) = delete;
  NodeOpGLSLstd450Log2 &operator=(const NodeOpGLSLstd450Log2 &) = delete;
  NodeOpGLSLstd450Log2(NodeOpGLSLstd450Log2 &&) = delete;
  NodeOpGLSLstd450Log2 &operator=(NodeOpGLSLstd450Log2 &&) = delete;
  NodeOpGLSLstd450Log2(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450MatrixInverse
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::MatrixInverse;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450MatrixInverse() = default;
  ~NodeOpGLSLstd450MatrixInverse() = default;
  NodeOpGLSLstd450MatrixInverse(const NodeOpGLSLstd450MatrixInverse &) = delete;
  NodeOpGLSLstd450MatrixInverse &operator=(const NodeOpGLSLstd450MatrixInverse &) = delete;
  NodeOpGLSLstd450MatrixInverse(NodeOpGLSLstd450MatrixInverse &&) = delete;
  NodeOpGLSLstd450MatrixInverse &operator=(NodeOpGLSLstd450MatrixInverse &&) = delete;
  NodeOpGLSLstd450MatrixInverse(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAMDShaderBallotMbcnt
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const AMDShaderBallot extOpCode = AMDShaderBallot::MbcntAMD;
  const ExtendedGrammar grammarId = ExtendedGrammar::AMD_shader_ballot;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> mask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(mask);
  }
  NodeOpAMDShaderBallotMbcnt() = default;
  ~NodeOpAMDShaderBallotMbcnt() = default;
  NodeOpAMDShaderBallotMbcnt(const NodeOpAMDShaderBallotMbcnt &) = delete;
  NodeOpAMDShaderBallotMbcnt &operator=(const NodeOpAMDShaderBallotMbcnt &) = delete;
  NodeOpAMDShaderBallotMbcnt(NodeOpAMDShaderBallotMbcnt &&) = delete;
  NodeOpAMDShaderBallotMbcnt &operator=(NodeOpAMDShaderBallotMbcnt &&) = delete;
  NodeOpAMDShaderBallotMbcnt(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> mask)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->mask = mask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450ModfStruct
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::ModfStruct;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450ModfStruct() = default;
  ~NodeOpGLSLstd450ModfStruct() = default;
  NodeOpGLSLstd450ModfStruct(const NodeOpGLSLstd450ModfStruct &) = delete;
  NodeOpGLSLstd450ModfStruct &operator=(const NodeOpGLSLstd450ModfStruct &) = delete;
  NodeOpGLSLstd450ModfStruct(NodeOpGLSLstd450ModfStruct &&) = delete;
  NodeOpGLSLstd450ModfStruct &operator=(NodeOpGLSLstd450ModfStruct &&) = delete;
  NodeOpGLSLstd450ModfStruct(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Normalize
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Normalize;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Normalize() = default;
  ~NodeOpGLSLstd450Normalize() = default;
  NodeOpGLSLstd450Normalize(const NodeOpGLSLstd450Normalize &) = delete;
  NodeOpGLSLstd450Normalize &operator=(const NodeOpGLSLstd450Normalize &) = delete;
  NodeOpGLSLstd450Normalize(NodeOpGLSLstd450Normalize &&) = delete;
  NodeOpGLSLstd450Normalize &operator=(NodeOpGLSLstd450Normalize &&) = delete;
  NodeOpGLSLstd450Normalize(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAll
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAll;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
  }
  NodeOpAll() = default;
  ~NodeOpAll() = default;
  NodeOpAll(const NodeOpAll &) = delete;
  NodeOpAll &operator=(const NodeOpAll &) = delete;
  NodeOpAll(NodeOpAll &&) = delete;
  NodeOpAll &operator=(NodeOpAll &&) = delete;
  NodeOpAll(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAny
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAny;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> vector;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(vector);
  }
  NodeOpAny() = default;
  ~NodeOpAny() = default;
  NodeOpAny(const NodeOpAny &) = delete;
  NodeOpAny &operator=(const NodeOpAny &) = delete;
  NodeOpAny(NodeOpAny &&) = delete;
  NodeOpAny &operator=(NodeOpAny &&) = delete;
  NodeOpAny(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> vector)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->vector = vector;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatACosINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatACosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatACosINTEL() = default;
  ~NodeOpArbitraryFloatACosINTEL() = default;
  NodeOpArbitraryFloatACosINTEL(const NodeOpArbitraryFloatACosINTEL &) = delete;
  NodeOpArbitraryFloatACosINTEL &operator=(const NodeOpArbitraryFloatACosINTEL &) = delete;
  NodeOpArbitraryFloatACosINTEL(NodeOpArbitraryFloatACosINTEL &&) = delete;
  NodeOpArbitraryFloatACosINTEL &operator=(NodeOpArbitraryFloatACosINTEL &&) = delete;
  NodeOpArbitraryFloatACosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatACosPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatACosPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatACosPiINTEL() = default;
  ~NodeOpArbitraryFloatACosPiINTEL() = default;
  NodeOpArbitraryFloatACosPiINTEL(const NodeOpArbitraryFloatACosPiINTEL &) = delete;
  NodeOpArbitraryFloatACosPiINTEL &operator=(const NodeOpArbitraryFloatACosPiINTEL &) = delete;
  NodeOpArbitraryFloatACosPiINTEL(NodeOpArbitraryFloatACosPiINTEL &&) = delete;
  NodeOpArbitraryFloatACosPiINTEL &operator=(NodeOpArbitraryFloatACosPiINTEL &&) = delete;
  NodeOpArbitraryFloatACosPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatASinINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatASinINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatASinINTEL() = default;
  ~NodeOpArbitraryFloatASinINTEL() = default;
  NodeOpArbitraryFloatASinINTEL(const NodeOpArbitraryFloatASinINTEL &) = delete;
  NodeOpArbitraryFloatASinINTEL &operator=(const NodeOpArbitraryFloatASinINTEL &) = delete;
  NodeOpArbitraryFloatASinINTEL(NodeOpArbitraryFloatASinINTEL &&) = delete;
  NodeOpArbitraryFloatASinINTEL &operator=(NodeOpArbitraryFloatASinINTEL &&) = delete;
  NodeOpArbitraryFloatASinINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatASinPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatASinPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatASinPiINTEL() = default;
  ~NodeOpArbitraryFloatASinPiINTEL() = default;
  NodeOpArbitraryFloatASinPiINTEL(const NodeOpArbitraryFloatASinPiINTEL &) = delete;
  NodeOpArbitraryFloatASinPiINTEL &operator=(const NodeOpArbitraryFloatASinPiINTEL &) = delete;
  NodeOpArbitraryFloatASinPiINTEL(NodeOpArbitraryFloatASinPiINTEL &&) = delete;
  NodeOpArbitraryFloatASinPiINTEL &operator=(NodeOpArbitraryFloatASinPiINTEL &&) = delete;
  NodeOpArbitraryFloatASinPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatATan2INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatATan2INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatATan2INTEL() = default;
  ~NodeOpArbitraryFloatATan2INTEL() = default;
  NodeOpArbitraryFloatATan2INTEL(const NodeOpArbitraryFloatATan2INTEL &) = delete;
  NodeOpArbitraryFloatATan2INTEL &operator=(const NodeOpArbitraryFloatATan2INTEL &) = delete;
  NodeOpArbitraryFloatATan2INTEL(NodeOpArbitraryFloatATan2INTEL &&) = delete;
  NodeOpArbitraryFloatATan2INTEL &operator=(NodeOpArbitraryFloatATan2INTEL &&) = delete;
  NodeOpArbitraryFloatATan2INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatATanINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatATanINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatATanINTEL() = default;
  ~NodeOpArbitraryFloatATanINTEL() = default;
  NodeOpArbitraryFloatATanINTEL(const NodeOpArbitraryFloatATanINTEL &) = delete;
  NodeOpArbitraryFloatATanINTEL &operator=(const NodeOpArbitraryFloatATanINTEL &) = delete;
  NodeOpArbitraryFloatATanINTEL(NodeOpArbitraryFloatATanINTEL &&) = delete;
  NodeOpArbitraryFloatATanINTEL &operator=(NodeOpArbitraryFloatATanINTEL &&) = delete;
  NodeOpArbitraryFloatATanINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatATanPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatATanPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatATanPiINTEL() = default;
  ~NodeOpArbitraryFloatATanPiINTEL() = default;
  NodeOpArbitraryFloatATanPiINTEL(const NodeOpArbitraryFloatATanPiINTEL &) = delete;
  NodeOpArbitraryFloatATanPiINTEL &operator=(const NodeOpArbitraryFloatATanPiINTEL &) = delete;
  NodeOpArbitraryFloatATanPiINTEL(NodeOpArbitraryFloatATanPiINTEL &&) = delete;
  NodeOpArbitraryFloatATanPiINTEL &operator=(NodeOpArbitraryFloatATanPiINTEL &&) = delete;
  NodeOpArbitraryFloatATanPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatAddINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatAddINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatAddINTEL() = default;
  ~NodeOpArbitraryFloatAddINTEL() = default;
  NodeOpArbitraryFloatAddINTEL(const NodeOpArbitraryFloatAddINTEL &) = delete;
  NodeOpArbitraryFloatAddINTEL &operator=(const NodeOpArbitraryFloatAddINTEL &) = delete;
  NodeOpArbitraryFloatAddINTEL(NodeOpArbitraryFloatAddINTEL &&) = delete;
  NodeOpArbitraryFloatAddINTEL &operator=(NodeOpArbitraryFloatAddINTEL &&) = delete;
  NodeOpArbitraryFloatAddINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCastFromIntINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCastFromIntINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger mout;
  LiteralInteger fromSign;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCastFromIntINTEL() = default;
  ~NodeOpArbitraryFloatCastFromIntINTEL() = default;
  NodeOpArbitraryFloatCastFromIntINTEL(const NodeOpArbitraryFloatCastFromIntINTEL &) = delete;
  NodeOpArbitraryFloatCastFromIntINTEL &operator=(const NodeOpArbitraryFloatCastFromIntINTEL &) = delete;
  NodeOpArbitraryFloatCastFromIntINTEL(NodeOpArbitraryFloatCastFromIntINTEL &&) = delete;
  NodeOpArbitraryFloatCastFromIntINTEL &operator=(NodeOpArbitraryFloatCastFromIntINTEL &&) = delete;
  NodeOpArbitraryFloatCastFromIntINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a,
    LiteralInteger mout, LiteralInteger from_sign, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->mout = mout;
    this->fromSign = from_sign;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCastINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCastINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCastINTEL() = default;
  ~NodeOpArbitraryFloatCastINTEL() = default;
  NodeOpArbitraryFloatCastINTEL(const NodeOpArbitraryFloatCastINTEL &) = delete;
  NodeOpArbitraryFloatCastINTEL &operator=(const NodeOpArbitraryFloatCastINTEL &) = delete;
  NodeOpArbitraryFloatCastINTEL(NodeOpArbitraryFloatCastINTEL &&) = delete;
  NodeOpArbitraryFloatCastINTEL &operator=(NodeOpArbitraryFloatCastINTEL &&) = delete;
  NodeOpArbitraryFloatCastINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCastToIntINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCastToIntINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCastToIntINTEL() = default;
  ~NodeOpArbitraryFloatCastToIntINTEL() = default;
  NodeOpArbitraryFloatCastToIntINTEL(const NodeOpArbitraryFloatCastToIntINTEL &) = delete;
  NodeOpArbitraryFloatCastToIntINTEL &operator=(const NodeOpArbitraryFloatCastToIntINTEL &) = delete;
  NodeOpArbitraryFloatCastToIntINTEL(NodeOpArbitraryFloatCastToIntINTEL &&) = delete;
  NodeOpArbitraryFloatCastToIntINTEL &operator=(NodeOpArbitraryFloatCastToIntINTEL &&) = delete;
  NodeOpArbitraryFloatCastToIntINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCbrtINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCbrtINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCbrtINTEL() = default;
  ~NodeOpArbitraryFloatCbrtINTEL() = default;
  NodeOpArbitraryFloatCbrtINTEL(const NodeOpArbitraryFloatCbrtINTEL &) = delete;
  NodeOpArbitraryFloatCbrtINTEL &operator=(const NodeOpArbitraryFloatCbrtINTEL &) = delete;
  NodeOpArbitraryFloatCbrtINTEL(NodeOpArbitraryFloatCbrtINTEL &&) = delete;
  NodeOpArbitraryFloatCbrtINTEL &operator=(NodeOpArbitraryFloatCbrtINTEL &&) = delete;
  NodeOpArbitraryFloatCbrtINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCosINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCosINTEL() = default;
  ~NodeOpArbitraryFloatCosINTEL() = default;
  NodeOpArbitraryFloatCosINTEL(const NodeOpArbitraryFloatCosINTEL &) = delete;
  NodeOpArbitraryFloatCosINTEL &operator=(const NodeOpArbitraryFloatCosINTEL &) = delete;
  NodeOpArbitraryFloatCosINTEL(NodeOpArbitraryFloatCosINTEL &&) = delete;
  NodeOpArbitraryFloatCosINTEL &operator=(NodeOpArbitraryFloatCosINTEL &&) = delete;
  NodeOpArbitraryFloatCosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatCosPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatCosPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatCosPiINTEL() = default;
  ~NodeOpArbitraryFloatCosPiINTEL() = default;
  NodeOpArbitraryFloatCosPiINTEL(const NodeOpArbitraryFloatCosPiINTEL &) = delete;
  NodeOpArbitraryFloatCosPiINTEL &operator=(const NodeOpArbitraryFloatCosPiINTEL &) = delete;
  NodeOpArbitraryFloatCosPiINTEL(NodeOpArbitraryFloatCosPiINTEL &&) = delete;
  NodeOpArbitraryFloatCosPiINTEL &operator=(NodeOpArbitraryFloatCosPiINTEL &&) = delete;
  NodeOpArbitraryFloatCosPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatDivINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatDivINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatDivINTEL() = default;
  ~NodeOpArbitraryFloatDivINTEL() = default;
  NodeOpArbitraryFloatDivINTEL(const NodeOpArbitraryFloatDivINTEL &) = delete;
  NodeOpArbitraryFloatDivINTEL &operator=(const NodeOpArbitraryFloatDivINTEL &) = delete;
  NodeOpArbitraryFloatDivINTEL(NodeOpArbitraryFloatDivINTEL &&) = delete;
  NodeOpArbitraryFloatDivINTEL &operator=(NodeOpArbitraryFloatDivINTEL &&) = delete;
  NodeOpArbitraryFloatDivINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatEQINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatEQINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatEQINTEL() = default;
  ~NodeOpArbitraryFloatEQINTEL() = default;
  NodeOpArbitraryFloatEQINTEL(const NodeOpArbitraryFloatEQINTEL &) = delete;
  NodeOpArbitraryFloatEQINTEL &operator=(const NodeOpArbitraryFloatEQINTEL &) = delete;
  NodeOpArbitraryFloatEQINTEL(NodeOpArbitraryFloatEQINTEL &&) = delete;
  NodeOpArbitraryFloatEQINTEL &operator=(NodeOpArbitraryFloatEQINTEL &&) = delete;
  NodeOpArbitraryFloatEQINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatExp10INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatExp10INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatExp10INTEL() = default;
  ~NodeOpArbitraryFloatExp10INTEL() = default;
  NodeOpArbitraryFloatExp10INTEL(const NodeOpArbitraryFloatExp10INTEL &) = delete;
  NodeOpArbitraryFloatExp10INTEL &operator=(const NodeOpArbitraryFloatExp10INTEL &) = delete;
  NodeOpArbitraryFloatExp10INTEL(NodeOpArbitraryFloatExp10INTEL &&) = delete;
  NodeOpArbitraryFloatExp10INTEL &operator=(NodeOpArbitraryFloatExp10INTEL &&) = delete;
  NodeOpArbitraryFloatExp10INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatExp2INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatExp2INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatExp2INTEL() = default;
  ~NodeOpArbitraryFloatExp2INTEL() = default;
  NodeOpArbitraryFloatExp2INTEL(const NodeOpArbitraryFloatExp2INTEL &) = delete;
  NodeOpArbitraryFloatExp2INTEL &operator=(const NodeOpArbitraryFloatExp2INTEL &) = delete;
  NodeOpArbitraryFloatExp2INTEL(NodeOpArbitraryFloatExp2INTEL &&) = delete;
  NodeOpArbitraryFloatExp2INTEL &operator=(NodeOpArbitraryFloatExp2INTEL &&) = delete;
  NodeOpArbitraryFloatExp2INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatExpINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatExpINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatExpINTEL() = default;
  ~NodeOpArbitraryFloatExpINTEL() = default;
  NodeOpArbitraryFloatExpINTEL(const NodeOpArbitraryFloatExpINTEL &) = delete;
  NodeOpArbitraryFloatExpINTEL &operator=(const NodeOpArbitraryFloatExpINTEL &) = delete;
  NodeOpArbitraryFloatExpINTEL(NodeOpArbitraryFloatExpINTEL &&) = delete;
  NodeOpArbitraryFloatExpINTEL &operator=(NodeOpArbitraryFloatExpINTEL &&) = delete;
  NodeOpArbitraryFloatExpINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatExpm1INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatExpm1INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatExpm1INTEL() = default;
  ~NodeOpArbitraryFloatExpm1INTEL() = default;
  NodeOpArbitraryFloatExpm1INTEL(const NodeOpArbitraryFloatExpm1INTEL &) = delete;
  NodeOpArbitraryFloatExpm1INTEL &operator=(const NodeOpArbitraryFloatExpm1INTEL &) = delete;
  NodeOpArbitraryFloatExpm1INTEL(NodeOpArbitraryFloatExpm1INTEL &&) = delete;
  NodeOpArbitraryFloatExpm1INTEL &operator=(NodeOpArbitraryFloatExpm1INTEL &&) = delete;
  NodeOpArbitraryFloatExpm1INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatGEINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatGEINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatGEINTEL() = default;
  ~NodeOpArbitraryFloatGEINTEL() = default;
  NodeOpArbitraryFloatGEINTEL(const NodeOpArbitraryFloatGEINTEL &) = delete;
  NodeOpArbitraryFloatGEINTEL &operator=(const NodeOpArbitraryFloatGEINTEL &) = delete;
  NodeOpArbitraryFloatGEINTEL(NodeOpArbitraryFloatGEINTEL &&) = delete;
  NodeOpArbitraryFloatGEINTEL &operator=(NodeOpArbitraryFloatGEINTEL &&) = delete;
  NodeOpArbitraryFloatGEINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatGTINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatGTINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatGTINTEL() = default;
  ~NodeOpArbitraryFloatGTINTEL() = default;
  NodeOpArbitraryFloatGTINTEL(const NodeOpArbitraryFloatGTINTEL &) = delete;
  NodeOpArbitraryFloatGTINTEL &operator=(const NodeOpArbitraryFloatGTINTEL &) = delete;
  NodeOpArbitraryFloatGTINTEL(NodeOpArbitraryFloatGTINTEL &&) = delete;
  NodeOpArbitraryFloatGTINTEL &operator=(NodeOpArbitraryFloatGTINTEL &&) = delete;
  NodeOpArbitraryFloatGTINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatHypotINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatHypotINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatHypotINTEL() = default;
  ~NodeOpArbitraryFloatHypotINTEL() = default;
  NodeOpArbitraryFloatHypotINTEL(const NodeOpArbitraryFloatHypotINTEL &) = delete;
  NodeOpArbitraryFloatHypotINTEL &operator=(const NodeOpArbitraryFloatHypotINTEL &) = delete;
  NodeOpArbitraryFloatHypotINTEL(NodeOpArbitraryFloatHypotINTEL &&) = delete;
  NodeOpArbitraryFloatHypotINTEL &operator=(NodeOpArbitraryFloatHypotINTEL &&) = delete;
  NodeOpArbitraryFloatHypotINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLEINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLEINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatLEINTEL() = default;
  ~NodeOpArbitraryFloatLEINTEL() = default;
  NodeOpArbitraryFloatLEINTEL(const NodeOpArbitraryFloatLEINTEL &) = delete;
  NodeOpArbitraryFloatLEINTEL &operator=(const NodeOpArbitraryFloatLEINTEL &) = delete;
  NodeOpArbitraryFloatLEINTEL(NodeOpArbitraryFloatLEINTEL &&) = delete;
  NodeOpArbitraryFloatLEINTEL &operator=(NodeOpArbitraryFloatLEINTEL &&) = delete;
  NodeOpArbitraryFloatLEINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLTINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLTINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatLTINTEL() = default;
  ~NodeOpArbitraryFloatLTINTEL() = default;
  NodeOpArbitraryFloatLTINTEL(const NodeOpArbitraryFloatLTINTEL &) = delete;
  NodeOpArbitraryFloatLTINTEL &operator=(const NodeOpArbitraryFloatLTINTEL &) = delete;
  NodeOpArbitraryFloatLTINTEL(NodeOpArbitraryFloatLTINTEL &&) = delete;
  NodeOpArbitraryFloatLTINTEL &operator=(NodeOpArbitraryFloatLTINTEL &&) = delete;
  NodeOpArbitraryFloatLTINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLog10INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLog10INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatLog10INTEL() = default;
  ~NodeOpArbitraryFloatLog10INTEL() = default;
  NodeOpArbitraryFloatLog10INTEL(const NodeOpArbitraryFloatLog10INTEL &) = delete;
  NodeOpArbitraryFloatLog10INTEL &operator=(const NodeOpArbitraryFloatLog10INTEL &) = delete;
  NodeOpArbitraryFloatLog10INTEL(NodeOpArbitraryFloatLog10INTEL &&) = delete;
  NodeOpArbitraryFloatLog10INTEL &operator=(NodeOpArbitraryFloatLog10INTEL &&) = delete;
  NodeOpArbitraryFloatLog10INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLog1pINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLog1pINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatLog1pINTEL() = default;
  ~NodeOpArbitraryFloatLog1pINTEL() = default;
  NodeOpArbitraryFloatLog1pINTEL(const NodeOpArbitraryFloatLog1pINTEL &) = delete;
  NodeOpArbitraryFloatLog1pINTEL &operator=(const NodeOpArbitraryFloatLog1pINTEL &) = delete;
  NodeOpArbitraryFloatLog1pINTEL(NodeOpArbitraryFloatLog1pINTEL &&) = delete;
  NodeOpArbitraryFloatLog1pINTEL &operator=(NodeOpArbitraryFloatLog1pINTEL &&) = delete;
  NodeOpArbitraryFloatLog1pINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLog2INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLog2INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatLog2INTEL() = default;
  ~NodeOpArbitraryFloatLog2INTEL() = default;
  NodeOpArbitraryFloatLog2INTEL(const NodeOpArbitraryFloatLog2INTEL &) = delete;
  NodeOpArbitraryFloatLog2INTEL &operator=(const NodeOpArbitraryFloatLog2INTEL &) = delete;
  NodeOpArbitraryFloatLog2INTEL(NodeOpArbitraryFloatLog2INTEL &&) = delete;
  NodeOpArbitraryFloatLog2INTEL &operator=(NodeOpArbitraryFloatLog2INTEL &&) = delete;
  NodeOpArbitraryFloatLog2INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatLogINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatLogINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatLogINTEL() = default;
  ~NodeOpArbitraryFloatLogINTEL() = default;
  NodeOpArbitraryFloatLogINTEL(const NodeOpArbitraryFloatLogINTEL &) = delete;
  NodeOpArbitraryFloatLogINTEL &operator=(const NodeOpArbitraryFloatLogINTEL &) = delete;
  NodeOpArbitraryFloatLogINTEL(NodeOpArbitraryFloatLogINTEL &&) = delete;
  NodeOpArbitraryFloatLogINTEL &operator=(NodeOpArbitraryFloatLogINTEL &&) = delete;
  NodeOpArbitraryFloatLogINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatMulINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatMulINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatMulINTEL() = default;
  ~NodeOpArbitraryFloatMulINTEL() = default;
  NodeOpArbitraryFloatMulINTEL(const NodeOpArbitraryFloatMulINTEL &) = delete;
  NodeOpArbitraryFloatMulINTEL &operator=(const NodeOpArbitraryFloatMulINTEL &) = delete;
  NodeOpArbitraryFloatMulINTEL(NodeOpArbitraryFloatMulINTEL &&) = delete;
  NodeOpArbitraryFloatMulINTEL &operator=(NodeOpArbitraryFloatMulINTEL &&) = delete;
  NodeOpArbitraryFloatMulINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatPowINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatPowINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatPowINTEL() = default;
  ~NodeOpArbitraryFloatPowINTEL() = default;
  NodeOpArbitraryFloatPowINTEL(const NodeOpArbitraryFloatPowINTEL &) = delete;
  NodeOpArbitraryFloatPowINTEL &operator=(const NodeOpArbitraryFloatPowINTEL &) = delete;
  NodeOpArbitraryFloatPowINTEL(NodeOpArbitraryFloatPowINTEL &&) = delete;
  NodeOpArbitraryFloatPowINTEL &operator=(NodeOpArbitraryFloatPowINTEL &&) = delete;
  NodeOpArbitraryFloatPowINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatPowNINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatPowNINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatPowNINTEL() = default;
  ~NodeOpArbitraryFloatPowNINTEL() = default;
  NodeOpArbitraryFloatPowNINTEL(const NodeOpArbitraryFloatPowNINTEL &) = delete;
  NodeOpArbitraryFloatPowNINTEL &operator=(const NodeOpArbitraryFloatPowNINTEL &) = delete;
  NodeOpArbitraryFloatPowNINTEL(NodeOpArbitraryFloatPowNINTEL &&) = delete;
  NodeOpArbitraryFloatPowNINTEL &operator=(NodeOpArbitraryFloatPowNINTEL &&) = delete;
  NodeOpArbitraryFloatPowNINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatPowRINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatPowRINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatPowRINTEL() = default;
  ~NodeOpArbitraryFloatPowRINTEL() = default;
  NodeOpArbitraryFloatPowRINTEL(const NodeOpArbitraryFloatPowRINTEL &) = delete;
  NodeOpArbitraryFloatPowRINTEL &operator=(const NodeOpArbitraryFloatPowRINTEL &) = delete;
  NodeOpArbitraryFloatPowRINTEL(NodeOpArbitraryFloatPowRINTEL &&) = delete;
  NodeOpArbitraryFloatPowRINTEL &operator=(NodeOpArbitraryFloatPowRINTEL &&) = delete;
  NodeOpArbitraryFloatPowRINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatRSqrtINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatRSqrtINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatRSqrtINTEL() = default;
  ~NodeOpArbitraryFloatRSqrtINTEL() = default;
  NodeOpArbitraryFloatRSqrtINTEL(const NodeOpArbitraryFloatRSqrtINTEL &) = delete;
  NodeOpArbitraryFloatRSqrtINTEL &operator=(const NodeOpArbitraryFloatRSqrtINTEL &) = delete;
  NodeOpArbitraryFloatRSqrtINTEL(NodeOpArbitraryFloatRSqrtINTEL &&) = delete;
  NodeOpArbitraryFloatRSqrtINTEL &operator=(NodeOpArbitraryFloatRSqrtINTEL &&) = delete;
  NodeOpArbitraryFloatRSqrtINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatRecipINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatRecipINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatRecipINTEL() = default;
  ~NodeOpArbitraryFloatRecipINTEL() = default;
  NodeOpArbitraryFloatRecipINTEL(const NodeOpArbitraryFloatRecipINTEL &) = delete;
  NodeOpArbitraryFloatRecipINTEL &operator=(const NodeOpArbitraryFloatRecipINTEL &) = delete;
  NodeOpArbitraryFloatRecipINTEL(NodeOpArbitraryFloatRecipINTEL &&) = delete;
  NodeOpArbitraryFloatRecipINTEL &operator=(NodeOpArbitraryFloatRecipINTEL &&) = delete;
  NodeOpArbitraryFloatRecipINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSinCosINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSinCosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatSinCosINTEL() = default;
  ~NodeOpArbitraryFloatSinCosINTEL() = default;
  NodeOpArbitraryFloatSinCosINTEL(const NodeOpArbitraryFloatSinCosINTEL &) = delete;
  NodeOpArbitraryFloatSinCosINTEL &operator=(const NodeOpArbitraryFloatSinCosINTEL &) = delete;
  NodeOpArbitraryFloatSinCosINTEL(NodeOpArbitraryFloatSinCosINTEL &&) = delete;
  NodeOpArbitraryFloatSinCosINTEL &operator=(NodeOpArbitraryFloatSinCosINTEL &&) = delete;
  NodeOpArbitraryFloatSinCosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSinCosPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSinCosPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger fromSign;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatSinCosPiINTEL() = default;
  ~NodeOpArbitraryFloatSinCosPiINTEL() = default;
  NodeOpArbitraryFloatSinCosPiINTEL(const NodeOpArbitraryFloatSinCosPiINTEL &) = delete;
  NodeOpArbitraryFloatSinCosPiINTEL &operator=(const NodeOpArbitraryFloatSinCosPiINTEL &) = delete;
  NodeOpArbitraryFloatSinCosPiINTEL(NodeOpArbitraryFloatSinCosPiINTEL &&) = delete;
  NodeOpArbitraryFloatSinCosPiINTEL &operator=(NodeOpArbitraryFloatSinCosPiINTEL &&) = delete;
  NodeOpArbitraryFloatSinCosPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger from_sign, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->fromSign = from_sign;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSinINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSinINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatSinINTEL() = default;
  ~NodeOpArbitraryFloatSinINTEL() = default;
  NodeOpArbitraryFloatSinINTEL(const NodeOpArbitraryFloatSinINTEL &) = delete;
  NodeOpArbitraryFloatSinINTEL &operator=(const NodeOpArbitraryFloatSinINTEL &) = delete;
  NodeOpArbitraryFloatSinINTEL(NodeOpArbitraryFloatSinINTEL &&) = delete;
  NodeOpArbitraryFloatSinINTEL &operator=(NodeOpArbitraryFloatSinINTEL &&) = delete;
  NodeOpArbitraryFloatSinINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSinPiINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSinPiINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatSinPiINTEL() = default;
  ~NodeOpArbitraryFloatSinPiINTEL() = default;
  NodeOpArbitraryFloatSinPiINTEL(const NodeOpArbitraryFloatSinPiINTEL &) = delete;
  NodeOpArbitraryFloatSinPiINTEL &operator=(const NodeOpArbitraryFloatSinPiINTEL &) = delete;
  NodeOpArbitraryFloatSinPiINTEL(NodeOpArbitraryFloatSinPiINTEL &&) = delete;
  NodeOpArbitraryFloatSinPiINTEL &operator=(NodeOpArbitraryFloatSinPiINTEL &&) = delete;
  NodeOpArbitraryFloatSinPiINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSqrtINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSqrtINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
  }
  NodeOpArbitraryFloatSqrtINTEL() = default;
  ~NodeOpArbitraryFloatSqrtINTEL() = default;
  NodeOpArbitraryFloatSqrtINTEL(const NodeOpArbitraryFloatSqrtINTEL &) = delete;
  NodeOpArbitraryFloatSqrtINTEL &operator=(const NodeOpArbitraryFloatSqrtINTEL &) = delete;
  NodeOpArbitraryFloatSqrtINTEL(NodeOpArbitraryFloatSqrtINTEL &&) = delete;
  NodeOpArbitraryFloatSqrtINTEL &operator=(NodeOpArbitraryFloatSqrtINTEL &&) = delete;
  NodeOpArbitraryFloatSqrtINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode, LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArbitraryFloatSubINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArbitraryFloatSubINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> a;
  LiteralInteger m1;
  NodePointer<NodeId> b;
  LiteralInteger m2;
  LiteralInteger mout;
  LiteralInteger enableSubnormals;
  LiteralInteger roundingMode;
  LiteralInteger roundingAccuracy;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(a);
    visitor(b);
  }
  NodeOpArbitraryFloatSubINTEL() = default;
  ~NodeOpArbitraryFloatSubINTEL() = default;
  NodeOpArbitraryFloatSubINTEL(const NodeOpArbitraryFloatSubINTEL &) = delete;
  NodeOpArbitraryFloatSubINTEL &operator=(const NodeOpArbitraryFloatSubINTEL &) = delete;
  NodeOpArbitraryFloatSubINTEL(NodeOpArbitraryFloatSubINTEL &&) = delete;
  NodeOpArbitraryFloatSubINTEL &operator=(NodeOpArbitraryFloatSubINTEL &&) = delete;
  NodeOpArbitraryFloatSubINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> a, LiteralInteger m1,
    NodePointer<NodeId> b, LiteralInteger m2, LiteralInteger mout, LiteralInteger enable_subnormals, LiteralInteger rounding_mode,
    LiteralInteger rounding_accuracy)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->a = a;
    this->m1 = m1;
    this->b = b;
    this->m2 = m2;
    this->mout = mout;
    this->enableSubnormals = enable_subnormals;
    this->roundingMode = rounding_mode;
    this->roundingAccuracy = rounding_accuracy;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpArrayLength
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpArrayLength;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> structure;
  LiteralInteger arrayMember;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(structure);
  }
  NodeOpArrayLength() = default;
  ~NodeOpArrayLength() = default;
  NodeOpArrayLength(const NodeOpArrayLength &) = delete;
  NodeOpArrayLength &operator=(const NodeOpArrayLength &) = delete;
  NodeOpArrayLength(NodeOpArrayLength &&) = delete;
  NodeOpArrayLength &operator=(NodeOpArrayLength &&) = delete;
  NodeOpArrayLength(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> structure, LiteralInteger array_member)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->structure = structure;
    this->arrayMember = array_member;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAsmCallINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAsmCallINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> not_reserved_asm;
  eastl::vector<NodePointer<NodeId>> argument0;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(not_reserved_asm);
    for (auto &&ref : argument0)
      visitor(ref);
  }
  NodeOpAsmCallINTEL() = default;
  ~NodeOpAsmCallINTEL() = default;
  NodeOpAsmCallINTEL(const NodeOpAsmCallINTEL &) = delete;
  NodeOpAsmCallINTEL &operator=(const NodeOpAsmCallINTEL &) = delete;
  NodeOpAsmCallINTEL(NodeOpAsmCallINTEL &&) = delete;
  NodeOpAsmCallINTEL &operator=(NodeOpAsmCallINTEL &&) = delete;
  NodeOpAsmCallINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> not_reserved_asm,
    NodePointer<NodeId> *argument_0 = nullptr, size_t argument_0_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->not_reserved_asm = not_reserved_asm;
    this->argument0.assign(argument_0, argument_0 + argument_0_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicAnd
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicAnd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicAnd() = default;
  ~NodeOpAtomicAnd() = default;
  NodeOpAtomicAnd(const NodeOpAtomicAnd &) = delete;
  NodeOpAtomicAnd &operator=(const NodeOpAtomicAnd &) = delete;
  NodeOpAtomicAnd(NodeOpAtomicAnd &&) = delete;
  NodeOpAtomicAnd &operator=(NodeOpAtomicAnd &&) = delete;
  NodeOpAtomicAnd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicCompareExchange
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicCompareExchange;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> equal;
  NodePointer<NodeOperation> unequal;
  NodePointer<NodeId> value;
  NodePointer<NodeId> comparator;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(equal);
    visitor(unequal);
    visitor(value);
    visitor(comparator);
  }
  NodeOpAtomicCompareExchange() = default;
  ~NodeOpAtomicCompareExchange() = default;
  NodeOpAtomicCompareExchange(const NodeOpAtomicCompareExchange &) = delete;
  NodeOpAtomicCompareExchange &operator=(const NodeOpAtomicCompareExchange &) = delete;
  NodeOpAtomicCompareExchange(NodeOpAtomicCompareExchange &&) = delete;
  NodeOpAtomicCompareExchange &operator=(NodeOpAtomicCompareExchange &&) = delete;
  NodeOpAtomicCompareExchange(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> equal, NodePointer<NodeOperation> unequal, NodePointer<NodeId> value,
    NodePointer<NodeId> comparator)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->equal = equal;
    this->unequal = unequal;
    this->value = value;
    this->comparator = comparator;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicCompareExchangeWeak
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicCompareExchangeWeak;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> equal;
  NodePointer<NodeOperation> unequal;
  NodePointer<NodeId> value;
  NodePointer<NodeId> comparator;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(equal);
    visitor(unequal);
    visitor(value);
    visitor(comparator);
  }
  NodeOpAtomicCompareExchangeWeak() = default;
  ~NodeOpAtomicCompareExchangeWeak() = default;
  NodeOpAtomicCompareExchangeWeak(const NodeOpAtomicCompareExchangeWeak &) = delete;
  NodeOpAtomicCompareExchangeWeak &operator=(const NodeOpAtomicCompareExchangeWeak &) = delete;
  NodeOpAtomicCompareExchangeWeak(NodeOpAtomicCompareExchangeWeak &&) = delete;
  NodeOpAtomicCompareExchangeWeak &operator=(NodeOpAtomicCompareExchangeWeak &&) = delete;
  NodeOpAtomicCompareExchangeWeak(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> equal, NodePointer<NodeOperation> unequal, NodePointer<NodeId> value,
    NodePointer<NodeId> comparator)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->equal = equal;
    this->unequal = unequal;
    this->value = value;
    this->comparator = comparator;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicExchange
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicExchange;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicExchange() = default;
  ~NodeOpAtomicExchange() = default;
  NodeOpAtomicExchange(const NodeOpAtomicExchange &) = delete;
  NodeOpAtomicExchange &operator=(const NodeOpAtomicExchange &) = delete;
  NodeOpAtomicExchange(NodeOpAtomicExchange &&) = delete;
  NodeOpAtomicExchange &operator=(NodeOpAtomicExchange &&) = delete;
  NodeOpAtomicExchange(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicFAddEXT
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicFAddEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicFAddEXT() = default;
  ~NodeOpAtomicFAddEXT() = default;
  NodeOpAtomicFAddEXT(const NodeOpAtomicFAddEXT &) = delete;
  NodeOpAtomicFAddEXT &operator=(const NodeOpAtomicFAddEXT &) = delete;
  NodeOpAtomicFAddEXT(NodeOpAtomicFAddEXT &&) = delete;
  NodeOpAtomicFAddEXT &operator=(NodeOpAtomicFAddEXT &&) = delete;
  NodeOpAtomicFAddEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicFMaxEXT
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicFMaxEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicFMaxEXT() = default;
  ~NodeOpAtomicFMaxEXT() = default;
  NodeOpAtomicFMaxEXT(const NodeOpAtomicFMaxEXT &) = delete;
  NodeOpAtomicFMaxEXT &operator=(const NodeOpAtomicFMaxEXT &) = delete;
  NodeOpAtomicFMaxEXT(NodeOpAtomicFMaxEXT &&) = delete;
  NodeOpAtomicFMaxEXT &operator=(NodeOpAtomicFMaxEXT &&) = delete;
  NodeOpAtomicFMaxEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicFMinEXT
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicFMinEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicFMinEXT() = default;
  ~NodeOpAtomicFMinEXT() = default;
  NodeOpAtomicFMinEXT(const NodeOpAtomicFMinEXT &) = delete;
  NodeOpAtomicFMinEXT &operator=(const NodeOpAtomicFMinEXT &) = delete;
  NodeOpAtomicFMinEXT(NodeOpAtomicFMinEXT &&) = delete;
  NodeOpAtomicFMinEXT &operator=(NodeOpAtomicFMinEXT &&) = delete;
  NodeOpAtomicFMinEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicFlagTestAndSet
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicFlagTestAndSet;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpAtomicFlagTestAndSet() = default;
  ~NodeOpAtomicFlagTestAndSet() = default;
  NodeOpAtomicFlagTestAndSet(const NodeOpAtomicFlagTestAndSet &) = delete;
  NodeOpAtomicFlagTestAndSet &operator=(const NodeOpAtomicFlagTestAndSet &) = delete;
  NodeOpAtomicFlagTestAndSet(NodeOpAtomicFlagTestAndSet &&) = delete;
  NodeOpAtomicFlagTestAndSet &operator=(NodeOpAtomicFlagTestAndSet &&) = delete;
  NodeOpAtomicFlagTestAndSet(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicIAdd
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicIAdd;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicIAdd() = default;
  ~NodeOpAtomicIAdd() = default;
  NodeOpAtomicIAdd(const NodeOpAtomicIAdd &) = delete;
  NodeOpAtomicIAdd &operator=(const NodeOpAtomicIAdd &) = delete;
  NodeOpAtomicIAdd(NodeOpAtomicIAdd &&) = delete;
  NodeOpAtomicIAdd &operator=(NodeOpAtomicIAdd &&) = delete;
  NodeOpAtomicIAdd(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicIDecrement
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicIDecrement;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpAtomicIDecrement() = default;
  ~NodeOpAtomicIDecrement() = default;
  NodeOpAtomicIDecrement(const NodeOpAtomicIDecrement &) = delete;
  NodeOpAtomicIDecrement &operator=(const NodeOpAtomicIDecrement &) = delete;
  NodeOpAtomicIDecrement(NodeOpAtomicIDecrement &&) = delete;
  NodeOpAtomicIDecrement &operator=(NodeOpAtomicIDecrement &&) = delete;
  NodeOpAtomicIDecrement(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicIIncrement
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicIIncrement;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpAtomicIIncrement() = default;
  ~NodeOpAtomicIIncrement() = default;
  NodeOpAtomicIIncrement(const NodeOpAtomicIIncrement &) = delete;
  NodeOpAtomicIIncrement &operator=(const NodeOpAtomicIIncrement &) = delete;
  NodeOpAtomicIIncrement(NodeOpAtomicIIncrement &&) = delete;
  NodeOpAtomicIIncrement &operator=(NodeOpAtomicIIncrement &&) = delete;
  NodeOpAtomicIIncrement(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicISub
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicISub;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicISub() = default;
  ~NodeOpAtomicISub() = default;
  NodeOpAtomicISub(const NodeOpAtomicISub &) = delete;
  NodeOpAtomicISub &operator=(const NodeOpAtomicISub &) = delete;
  NodeOpAtomicISub(NodeOpAtomicISub &&) = delete;
  NodeOpAtomicISub &operator=(NodeOpAtomicISub &&) = delete;
  NodeOpAtomicISub(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicLoad
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicLoad;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
  }
  NodeOpAtomicLoad() = default;
  ~NodeOpAtomicLoad() = default;
  NodeOpAtomicLoad(const NodeOpAtomicLoad &) = delete;
  NodeOpAtomicLoad &operator=(const NodeOpAtomicLoad &) = delete;
  NodeOpAtomicLoad(NodeOpAtomicLoad &&) = delete;
  NodeOpAtomicLoad &operator=(NodeOpAtomicLoad &&) = delete;
  NodeOpAtomicLoad(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicOr
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicOr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicOr() = default;
  ~NodeOpAtomicOr() = default;
  NodeOpAtomicOr(const NodeOpAtomicOr &) = delete;
  NodeOpAtomicOr &operator=(const NodeOpAtomicOr &) = delete;
  NodeOpAtomicOr(NodeOpAtomicOr &&) = delete;
  NodeOpAtomicOr &operator=(NodeOpAtomicOr &&) = delete;
  NodeOpAtomicOr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer, NodePointer<NodeOperation> memory,
    NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicSMax
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicSMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicSMax() = default;
  ~NodeOpAtomicSMax() = default;
  NodeOpAtomicSMax(const NodeOpAtomicSMax &) = delete;
  NodeOpAtomicSMax &operator=(const NodeOpAtomicSMax &) = delete;
  NodeOpAtomicSMax(NodeOpAtomicSMax &&) = delete;
  NodeOpAtomicSMax &operator=(NodeOpAtomicSMax &&) = delete;
  NodeOpAtomicSMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicSMin
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicSMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicSMin() = default;
  ~NodeOpAtomicSMin() = default;
  NodeOpAtomicSMin(const NodeOpAtomicSMin &) = delete;
  NodeOpAtomicSMin &operator=(const NodeOpAtomicSMin &) = delete;
  NodeOpAtomicSMin(NodeOpAtomicSMin &&) = delete;
  NodeOpAtomicSMin &operator=(NodeOpAtomicSMin &&) = delete;
  NodeOpAtomicSMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicUMax
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicUMax;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicUMax() = default;
  ~NodeOpAtomicUMax() = default;
  NodeOpAtomicUMax(const NodeOpAtomicUMax &) = delete;
  NodeOpAtomicUMax &operator=(const NodeOpAtomicUMax &) = delete;
  NodeOpAtomicUMax(NodeOpAtomicUMax &&) = delete;
  NodeOpAtomicUMax &operator=(NodeOpAtomicUMax &&) = delete;
  NodeOpAtomicUMax(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicUMin
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicUMin;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicUMin() = default;
  ~NodeOpAtomicUMin() = default;
  NodeOpAtomicUMin(const NodeOpAtomicUMin &) = delete;
  NodeOpAtomicUMin &operator=(const NodeOpAtomicUMin &) = delete;
  NodeOpAtomicUMin(NodeOpAtomicUMin &&) = delete;
  NodeOpAtomicUMin &operator=(NodeOpAtomicUMin &&) = delete;
  NodeOpAtomicUMin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpAtomicXor
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpAtomicXor;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  NodePointer<NodeOperation> memory;
  NodePointer<NodeOperation> semantics;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    visitor(memory);
    visitor(semantics);
    visitor(value);
  }
  NodeOpAtomicXor() = default;
  ~NodeOpAtomicXor() = default;
  NodeOpAtomicXor(const NodeOpAtomicXor &) = delete;
  NodeOpAtomicXor &operator=(const NodeOpAtomicXor &) = delete;
  NodeOpAtomicXor(NodeOpAtomicXor &&) = delete;
  NodeOpAtomicXor &operator=(NodeOpAtomicXor &&) = delete;
  NodeOpAtomicXor(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    NodePointer<NodeOperation> memory, NodePointer<NodeOperation> semantics, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memory = memory;
    this->semantics = semantics;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitCount
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpBitCount;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
  }
  NodeOpBitCount() = default;
  ~NodeOpBitCount() = default;
  NodeOpBitCount(const NodeOpBitCount &) = delete;
  NodeOpBitCount &operator=(const NodeOpBitCount &) = delete;
  NodeOpBitCount(NodeOpBitCount &&) = delete;
  NodeOpBitCount &operator=(NodeOpBitCount &&) = delete;
  NodeOpBitCount(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitReverse
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpBitReverse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
  }
  NodeOpBitReverse() = default;
  ~NodeOpBitReverse() = default;
  NodeOpBitReverse(const NodeOpBitReverse &) = delete;
  NodeOpBitReverse &operator=(const NodeOpBitReverse &) = delete;
  NodeOpBitReverse(NodeOpBitReverse &&) = delete;
  NodeOpBitReverse &operator=(NodeOpBitReverse &&) = delete;
  NodeOpBitReverse(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpBitcast
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpBitcast;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpBitcast() = default;
  ~NodeOpBitcast() = default;
  NodeOpBitcast(const NodeOpBitcast &) = delete;
  NodeOpBitcast &operator=(const NodeOpBitcast &) = delete;
  NodeOpBitcast(NodeOpBitcast &&) = delete;
  NodeOpBitcast &operator=(NodeOpBitcast &&) = delete;
  NodeOpBitcast(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpColorAttachmentReadEXT
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpColorAttachmentReadEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> attachment;
  eastl::optional<NodePointer<NodeId>> sample;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(attachment);
    if (sample)
      visitor(*sample);
  }
  NodeOpColorAttachmentReadEXT() = default;
  ~NodeOpColorAttachmentReadEXT() = default;
  NodeOpColorAttachmentReadEXT(const NodeOpColorAttachmentReadEXT &) = delete;
  NodeOpColorAttachmentReadEXT &operator=(const NodeOpColorAttachmentReadEXT &) = delete;
  NodeOpColorAttachmentReadEXT(NodeOpColorAttachmentReadEXT &&) = delete;
  NodeOpColorAttachmentReadEXT &operator=(NodeOpColorAttachmentReadEXT &&) = delete;
  NodeOpColorAttachmentReadEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> attachment,
    eastl::optional<NodePointer<NodeId>> sample = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->attachment = attachment;
    this->sample = sample;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCompositeConstructReplicateEXT
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCompositeConstructReplicateEXT;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpCompositeConstructReplicateEXT() = default;
  ~NodeOpCompositeConstructReplicateEXT() = default;
  NodeOpCompositeConstructReplicateEXT(const NodeOpCompositeConstructReplicateEXT &) = delete;
  NodeOpCompositeConstructReplicateEXT &operator=(const NodeOpCompositeConstructReplicateEXT &) = delete;
  NodeOpCompositeConstructReplicateEXT(NodeOpCompositeConstructReplicateEXT &&) = delete;
  NodeOpCompositeConstructReplicateEXT &operator=(NodeOpCompositeConstructReplicateEXT &&) = delete;
  NodeOpCompositeConstructReplicateEXT(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCompositeExtract
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCompositeExtract;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> composite;
  eastl::vector<LiteralInteger> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(composite);
  }
  NodeOpCompositeExtract() = default;
  ~NodeOpCompositeExtract() = default;
  NodeOpCompositeExtract(const NodeOpCompositeExtract &) = delete;
  NodeOpCompositeExtract &operator=(const NodeOpCompositeExtract &) = delete;
  NodeOpCompositeExtract(NodeOpCompositeExtract &&) = delete;
  NodeOpCompositeExtract &operator=(NodeOpCompositeExtract &&) = delete;
  NodeOpCompositeExtract(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> composite,
    LiteralInteger *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->composite = composite;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertBF16ToFINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertBF16ToFINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> bfloat16Value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(bfloat16Value);
  }
  NodeOpConvertBF16ToFINTEL() = default;
  ~NodeOpConvertBF16ToFINTEL() = default;
  NodeOpConvertBF16ToFINTEL(const NodeOpConvertBF16ToFINTEL &) = delete;
  NodeOpConvertBF16ToFINTEL &operator=(const NodeOpConvertBF16ToFINTEL &) = delete;
  NodeOpConvertBF16ToFINTEL(NodeOpConvertBF16ToFINTEL &&) = delete;
  NodeOpConvertBF16ToFINTEL &operator=(NodeOpConvertBF16ToFINTEL &&) = delete;
  NodeOpConvertBF16ToFINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> b_float16_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->bfloat16Value = b_float16_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertFToBF16INTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertFToBF16INTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> floatValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(floatValue);
  }
  NodeOpConvertFToBF16INTEL() = default;
  ~NodeOpConvertFToBF16INTEL() = default;
  NodeOpConvertFToBF16INTEL(const NodeOpConvertFToBF16INTEL &) = delete;
  NodeOpConvertFToBF16INTEL &operator=(const NodeOpConvertFToBF16INTEL &) = delete;
  NodeOpConvertFToBF16INTEL(NodeOpConvertFToBF16INTEL &&) = delete;
  NodeOpConvertFToBF16INTEL &operator=(NodeOpConvertFToBF16INTEL &&) = delete;
  NodeOpConvertFToBF16INTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> float_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->floatValue = float_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertFToS
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertFToS;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> floatValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(floatValue);
  }
  NodeOpConvertFToS() = default;
  ~NodeOpConvertFToS() = default;
  NodeOpConvertFToS(const NodeOpConvertFToS &) = delete;
  NodeOpConvertFToS &operator=(const NodeOpConvertFToS &) = delete;
  NodeOpConvertFToS(NodeOpConvertFToS &&) = delete;
  NodeOpConvertFToS &operator=(NodeOpConvertFToS &&) = delete;
  NodeOpConvertFToS(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> float_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->floatValue = float_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertFToU
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertFToU;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> floatValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(floatValue);
  }
  NodeOpConvertFToU() = default;
  ~NodeOpConvertFToU() = default;
  NodeOpConvertFToU(const NodeOpConvertFToU &) = delete;
  NodeOpConvertFToU &operator=(const NodeOpConvertFToU &) = delete;
  NodeOpConvertFToU(NodeOpConvertFToU &&) = delete;
  NodeOpConvertFToU &operator=(NodeOpConvertFToU &&) = delete;
  NodeOpConvertFToU(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> float_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->floatValue = float_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertImageToUNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertImageToUNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertImageToUNV() = default;
  ~NodeOpConvertImageToUNV() = default;
  NodeOpConvertImageToUNV(const NodeOpConvertImageToUNV &) = delete;
  NodeOpConvertImageToUNV &operator=(const NodeOpConvertImageToUNV &) = delete;
  NodeOpConvertImageToUNV(NodeOpConvertImageToUNV &&) = delete;
  NodeOpConvertImageToUNV &operator=(NodeOpConvertImageToUNV &&) = delete;
  NodeOpConvertImageToUNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertPtrToU
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertPtrToU;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpConvertPtrToU() = default;
  ~NodeOpConvertPtrToU() = default;
  NodeOpConvertPtrToU(const NodeOpConvertPtrToU &) = delete;
  NodeOpConvertPtrToU &operator=(const NodeOpConvertPtrToU &) = delete;
  NodeOpConvertPtrToU(NodeOpConvertPtrToU &&) = delete;
  NodeOpConvertPtrToU &operator=(NodeOpConvertPtrToU &&) = delete;
  NodeOpConvertPtrToU(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertSToF
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertSToF;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> signedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(signedValue);
  }
  NodeOpConvertSToF() = default;
  ~NodeOpConvertSToF() = default;
  NodeOpConvertSToF(const NodeOpConvertSToF &) = delete;
  NodeOpConvertSToF &operator=(const NodeOpConvertSToF &) = delete;
  NodeOpConvertSToF(NodeOpConvertSToF &&) = delete;
  NodeOpConvertSToF &operator=(NodeOpConvertSToF &&) = delete;
  NodeOpConvertSToF(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> signed_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->signedValue = signed_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertSampledImageToUNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertSampledImageToUNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertSampledImageToUNV() = default;
  ~NodeOpConvertSampledImageToUNV() = default;
  NodeOpConvertSampledImageToUNV(const NodeOpConvertSampledImageToUNV &) = delete;
  NodeOpConvertSampledImageToUNV &operator=(const NodeOpConvertSampledImageToUNV &) = delete;
  NodeOpConvertSampledImageToUNV(NodeOpConvertSampledImageToUNV &&) = delete;
  NodeOpConvertSampledImageToUNV &operator=(NodeOpConvertSampledImageToUNV &&) = delete;
  NodeOpConvertSampledImageToUNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertSamplerToUNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertSamplerToUNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertSamplerToUNV() = default;
  ~NodeOpConvertSamplerToUNV() = default;
  NodeOpConvertSamplerToUNV(const NodeOpConvertSamplerToUNV &) = delete;
  NodeOpConvertSamplerToUNV &operator=(const NodeOpConvertSamplerToUNV &) = delete;
  NodeOpConvertSamplerToUNV(NodeOpConvertSamplerToUNV &&) = delete;
  NodeOpConvertSamplerToUNV &operator=(NodeOpConvertSamplerToUNV &&) = delete;
  NodeOpConvertSamplerToUNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToAccelerationStructureKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToAccelerationStructureKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> accel;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(accel);
  }
  NodeOpConvertUToAccelerationStructureKHR() = default;
  ~NodeOpConvertUToAccelerationStructureKHR() = default;
  NodeOpConvertUToAccelerationStructureKHR(const NodeOpConvertUToAccelerationStructureKHR &) = delete;
  NodeOpConvertUToAccelerationStructureKHR &operator=(const NodeOpConvertUToAccelerationStructureKHR &) = delete;
  NodeOpConvertUToAccelerationStructureKHR(NodeOpConvertUToAccelerationStructureKHR &&) = delete;
  NodeOpConvertUToAccelerationStructureKHR &operator=(NodeOpConvertUToAccelerationStructureKHR &&) = delete;
  NodeOpConvertUToAccelerationStructureKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> accel)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->accel = accel;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToF
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToF;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> unsignedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(unsignedValue);
  }
  NodeOpConvertUToF() = default;
  ~NodeOpConvertUToF() = default;
  NodeOpConvertUToF(const NodeOpConvertUToF &) = delete;
  NodeOpConvertUToF &operator=(const NodeOpConvertUToF &) = delete;
  NodeOpConvertUToF(NodeOpConvertUToF &&) = delete;
  NodeOpConvertUToF &operator=(NodeOpConvertUToF &&) = delete;
  NodeOpConvertUToF(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> unsigned_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->unsignedValue = unsigned_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToImageNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToImageNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertUToImageNV() = default;
  ~NodeOpConvertUToImageNV() = default;
  NodeOpConvertUToImageNV(const NodeOpConvertUToImageNV &) = delete;
  NodeOpConvertUToImageNV &operator=(const NodeOpConvertUToImageNV &) = delete;
  NodeOpConvertUToImageNV(NodeOpConvertUToImageNV &&) = delete;
  NodeOpConvertUToImageNV &operator=(NodeOpConvertUToImageNV &&) = delete;
  NodeOpConvertUToImageNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToPtr
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToPtr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> integerValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(integerValue);
  }
  NodeOpConvertUToPtr() = default;
  ~NodeOpConvertUToPtr() = default;
  NodeOpConvertUToPtr(const NodeOpConvertUToPtr &) = delete;
  NodeOpConvertUToPtr &operator=(const NodeOpConvertUToPtr &) = delete;
  NodeOpConvertUToPtr(NodeOpConvertUToPtr &&) = delete;
  NodeOpConvertUToPtr &operator=(NodeOpConvertUToPtr &&) = delete;
  NodeOpConvertUToPtr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> integer_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->integerValue = integer_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToSampledImageNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToSampledImageNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertUToSampledImageNV() = default;
  ~NodeOpConvertUToSampledImageNV() = default;
  NodeOpConvertUToSampledImageNV(const NodeOpConvertUToSampledImageNV &) = delete;
  NodeOpConvertUToSampledImageNV &operator=(const NodeOpConvertUToSampledImageNV &) = delete;
  NodeOpConvertUToSampledImageNV(NodeOpConvertUToSampledImageNV &&) = delete;
  NodeOpConvertUToSampledImageNV &operator=(NodeOpConvertUToSampledImageNV &&) = delete;
  NodeOpConvertUToSampledImageNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpConvertUToSamplerNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpConvertUToSamplerNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpConvertUToSamplerNV() = default;
  ~NodeOpConvertUToSamplerNV() = default;
  NodeOpConvertUToSamplerNV(const NodeOpConvertUToSamplerNV &) = delete;
  NodeOpConvertUToSamplerNV &operator=(const NodeOpConvertUToSamplerNV &) = delete;
  NodeOpConvertUToSamplerNV(NodeOpConvertUToSamplerNV &&) = delete;
  NodeOpConvertUToSamplerNV &operator=(NodeOpConvertUToSamplerNV &&) = delete;
  NodeOpConvertUToSamplerNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixLengthKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCooperativeMatrixLengthKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> type;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(type);
  }
  NodeOpCooperativeMatrixLengthKHR() = default;
  ~NodeOpCooperativeMatrixLengthKHR() = default;
  NodeOpCooperativeMatrixLengthKHR(const NodeOpCooperativeMatrixLengthKHR &) = delete;
  NodeOpCooperativeMatrixLengthKHR &operator=(const NodeOpCooperativeMatrixLengthKHR &) = delete;
  NodeOpCooperativeMatrixLengthKHR(NodeOpCooperativeMatrixLengthKHR &&) = delete;
  NodeOpCooperativeMatrixLengthKHR &operator=(NodeOpCooperativeMatrixLengthKHR &&) = delete;
  NodeOpCooperativeMatrixLengthKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->type = type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCooperativeMatrixLengthNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCooperativeMatrixLengthNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> type;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(type);
  }
  NodeOpCooperativeMatrixLengthNV() = default;
  ~NodeOpCooperativeMatrixLengthNV() = default;
  NodeOpCooperativeMatrixLengthNV(const NodeOpCooperativeMatrixLengthNV &) = delete;
  NodeOpCooperativeMatrixLengthNV &operator=(const NodeOpCooperativeMatrixLengthNV &) = delete;
  NodeOpCooperativeMatrixLengthNV(NodeOpCooperativeMatrixLengthNV &&) = delete;
  NodeOpCooperativeMatrixLengthNV &operator=(NodeOpCooperativeMatrixLengthNV &&) = delete;
  NodeOpCooperativeMatrixLengthNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->type = type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCopyLogical
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCopyLogical;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpCopyLogical() = default;
  ~NodeOpCopyLogical() = default;
  NodeOpCopyLogical(const NodeOpCopyLogical &) = delete;
  NodeOpCopyLogical &operator=(const NodeOpCopyLogical &) = delete;
  NodeOpCopyLogical(NodeOpCopyLogical &&) = delete;
  NodeOpCopyLogical &operator=(NodeOpCopyLogical &&) = delete;
  NodeOpCopyLogical(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCopyObject
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCopyObject;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpCopyObject() = default;
  ~NodeOpCopyObject() = default;
  NodeOpCopyObject(const NodeOpCopyObject &) = delete;
  NodeOpCopyObject &operator=(const NodeOpCopyObject &) = delete;
  NodeOpCopyObject(NodeOpCopyObject &&) = delete;
  NodeOpCopyObject &operator=(NodeOpCopyObject &&) = delete;
  NodeOpCopyObject(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCreatePipeFromPipeStorage
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCreatePipeFromPipeStorage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pipeStorage;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pipeStorage);
  }
  NodeOpCreatePipeFromPipeStorage() = default;
  ~NodeOpCreatePipeFromPipeStorage() = default;
  NodeOpCreatePipeFromPipeStorage(const NodeOpCreatePipeFromPipeStorage &) = delete;
  NodeOpCreatePipeFromPipeStorage &operator=(const NodeOpCreatePipeFromPipeStorage &) = delete;
  NodeOpCreatePipeFromPipeStorage(NodeOpCreatePipeFromPipeStorage &&) = delete;
  NodeOpCreatePipeFromPipeStorage &operator=(NodeOpCreatePipeFromPipeStorage &&) = delete;
  NodeOpCreatePipeFromPipeStorage(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pipe_storage)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pipeStorage = pipe_storage;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpCrossWorkgroupCastToPtrINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpCrossWorkgroupCastToPtrINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpCrossWorkgroupCastToPtrINTEL() = default;
  ~NodeOpCrossWorkgroupCastToPtrINTEL() = default;
  NodeOpCrossWorkgroupCastToPtrINTEL(const NodeOpCrossWorkgroupCastToPtrINTEL &) = delete;
  NodeOpCrossWorkgroupCastToPtrINTEL &operator=(const NodeOpCrossWorkgroupCastToPtrINTEL &) = delete;
  NodeOpCrossWorkgroupCastToPtrINTEL(NodeOpCrossWorkgroupCastToPtrINTEL &&) = delete;
  NodeOpCrossWorkgroupCastToPtrINTEL &operator=(NodeOpCrossWorkgroupCastToPtrINTEL &&) = delete;
  NodeOpCrossWorkgroupCastToPtrINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdx
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdx;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdx() = default;
  ~NodeOpDPdx() = default;
  NodeOpDPdx(const NodeOpDPdx &) = delete;
  NodeOpDPdx &operator=(const NodeOpDPdx &) = delete;
  NodeOpDPdx(NodeOpDPdx &&) = delete;
  NodeOpDPdx &operator=(NodeOpDPdx &&) = delete;
  NodeOpDPdx(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdxCoarse
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdxCoarse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdxCoarse() = default;
  ~NodeOpDPdxCoarse() = default;
  NodeOpDPdxCoarse(const NodeOpDPdxCoarse &) = delete;
  NodeOpDPdxCoarse &operator=(const NodeOpDPdxCoarse &) = delete;
  NodeOpDPdxCoarse(NodeOpDPdxCoarse &&) = delete;
  NodeOpDPdxCoarse &operator=(NodeOpDPdxCoarse &&) = delete;
  NodeOpDPdxCoarse(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdxFine
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdxFine;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdxFine() = default;
  ~NodeOpDPdxFine() = default;
  NodeOpDPdxFine(const NodeOpDPdxFine &) = delete;
  NodeOpDPdxFine &operator=(const NodeOpDPdxFine &) = delete;
  NodeOpDPdxFine(NodeOpDPdxFine &&) = delete;
  NodeOpDPdxFine &operator=(NodeOpDPdxFine &&) = delete;
  NodeOpDPdxFine(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdy
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdy;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdy() = default;
  ~NodeOpDPdy() = default;
  NodeOpDPdy(const NodeOpDPdy &) = delete;
  NodeOpDPdy &operator=(const NodeOpDPdy &) = delete;
  NodeOpDPdy(NodeOpDPdy &&) = delete;
  NodeOpDPdy &operator=(NodeOpDPdy &&) = delete;
  NodeOpDPdy(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdyCoarse
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdyCoarse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdyCoarse() = default;
  ~NodeOpDPdyCoarse() = default;
  NodeOpDPdyCoarse(const NodeOpDPdyCoarse &) = delete;
  NodeOpDPdyCoarse &operator=(const NodeOpDPdyCoarse &) = delete;
  NodeOpDPdyCoarse(NodeOpDPdyCoarse &&) = delete;
  NodeOpDPdyCoarse &operator=(NodeOpDPdyCoarse &&) = delete;
  NodeOpDPdyCoarse(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpDPdyFine
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpDPdyFine;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpDPdyFine() = default;
  ~NodeOpDPdyFine() = default;
  NodeOpDPdyFine(const NodeOpDPdyFine &) = delete;
  NodeOpDPdyFine &operator=(const NodeOpDPdyFine &) = delete;
  NodeOpDPdyFine(NodeOpDPdyFine &&) = delete;
  NodeOpDPdyFine &operator=(NodeOpDPdyFine &&) = delete;
  NodeOpDPdyFine(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpExtInstWithForwardRefsKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInstWithForwardRefsKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> set;
  LiteralExtInstInteger instruction;
  eastl::vector<NodePointer<NodeId>> param4;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(set);
    for (auto &&ref : param4)
      visitor(ref);
  }
  NodeOpExtInstWithForwardRefsKHR() = default;
  ~NodeOpExtInstWithForwardRefsKHR() = default;
  NodeOpExtInstWithForwardRefsKHR(const NodeOpExtInstWithForwardRefsKHR &) = delete;
  NodeOpExtInstWithForwardRefsKHR &operator=(const NodeOpExtInstWithForwardRefsKHR &) = delete;
  NodeOpExtInstWithForwardRefsKHR(NodeOpExtInstWithForwardRefsKHR &&) = delete;
  NodeOpExtInstWithForwardRefsKHR &operator=(NodeOpExtInstWithForwardRefsKHR &&) = delete;
  NodeOpExtInstWithForwardRefsKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> set,
    LiteralExtInstInteger instruction, NodePointer<NodeId> *param_4 = nullptr, size_t param_4_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->set = set;
    this->instruction = instruction;
    this->param4.assign(param_4, param_4 + param_4_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFConvert
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFConvert;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> floatValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(floatValue);
  }
  NodeOpFConvert() = default;
  ~NodeOpFConvert() = default;
  NodeOpFConvert(const NodeOpFConvert &) = delete;
  NodeOpFConvert &operator=(const NodeOpFConvert &) = delete;
  NodeOpFConvert(NodeOpFConvert &&) = delete;
  NodeOpFConvert &operator=(NodeOpFConvert &&) = delete;
  NodeOpFConvert(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> float_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->floatValue = float_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFNegate
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFNegate;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpFNegate() = default;
  ~NodeOpFNegate() = default;
  NodeOpFNegate(const NodeOpFNegate &) = delete;
  NodeOpFNegate &operator=(const NodeOpFNegate &) = delete;
  NodeOpFNegate(NodeOpFNegate &&) = delete;
  NodeOpFNegate &operator=(NodeOpFNegate &&) = delete;
  NodeOpFNegate(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFinishWritingNodePayloadAMDX
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFinishWritingNodePayloadAMDX;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpFinishWritingNodePayloadAMDX() = default;
  ~NodeOpFinishWritingNodePayloadAMDX() = default;
  NodeOpFinishWritingNodePayloadAMDX(const NodeOpFinishWritingNodePayloadAMDX &) = delete;
  NodeOpFinishWritingNodePayloadAMDX &operator=(const NodeOpFinishWritingNodePayloadAMDX &) = delete;
  NodeOpFinishWritingNodePayloadAMDX(NodeOpFinishWritingNodePayloadAMDX &&) = delete;
  NodeOpFinishWritingNodePayloadAMDX &operator=(NodeOpFinishWritingNodePayloadAMDX &&) = delete;
  NodeOpFinishWritingNodePayloadAMDX(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFwidth
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFwidth;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpFwidth() = default;
  ~NodeOpFwidth() = default;
  NodeOpFwidth(const NodeOpFwidth &) = delete;
  NodeOpFwidth &operator=(const NodeOpFwidth &) = delete;
  NodeOpFwidth(NodeOpFwidth &&) = delete;
  NodeOpFwidth &operator=(NodeOpFwidth &&) = delete;
  NodeOpFwidth(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFwidthCoarse
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFwidthCoarse;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpFwidthCoarse() = default;
  ~NodeOpFwidthCoarse() = default;
  NodeOpFwidthCoarse(const NodeOpFwidthCoarse &) = delete;
  NodeOpFwidthCoarse &operator=(const NodeOpFwidthCoarse &) = delete;
  NodeOpFwidthCoarse(NodeOpFwidthCoarse &&) = delete;
  NodeOpFwidthCoarse &operator=(NodeOpFwidthCoarse &&) = delete;
  NodeOpFwidthCoarse(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFwidthFine
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpFwidthFine;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpFwidthFine() = default;
  ~NodeOpFwidthFine() = default;
  NodeOpFwidthFine(const NodeOpFwidthFine &) = delete;
  NodeOpFwidthFine &operator=(const NodeOpFwidthFine &) = delete;
  NodeOpFwidthFine(NodeOpFwidthFine &&) = delete;
  NodeOpFwidthFine &operator=(NodeOpFwidthFine &&) = delete;
  NodeOpFwidthFine(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGenericCastToPtr
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGenericCastToPtr;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpGenericCastToPtr() = default;
  ~NodeOpGenericCastToPtr() = default;
  NodeOpGenericCastToPtr(const NodeOpGenericCastToPtr &) = delete;
  NodeOpGenericCastToPtr &operator=(const NodeOpGenericCastToPtr &) = delete;
  NodeOpGenericCastToPtr(NodeOpGenericCastToPtr &&) = delete;
  NodeOpGenericCastToPtr &operator=(NodeOpGenericCastToPtr &&) = delete;
  NodeOpGenericCastToPtr(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGenericCastToPtrExplicit
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGenericCastToPtrExplicit;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  StorageClass storage;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpGenericCastToPtrExplicit() = default;
  ~NodeOpGenericCastToPtrExplicit() = default;
  NodeOpGenericCastToPtrExplicit(const NodeOpGenericCastToPtrExplicit &) = delete;
  NodeOpGenericCastToPtrExplicit &operator=(const NodeOpGenericCastToPtrExplicit &) = delete;
  NodeOpGenericCastToPtrExplicit(NodeOpGenericCastToPtrExplicit &&) = delete;
  NodeOpGenericCastToPtrExplicit &operator=(NodeOpGenericCastToPtrExplicit &&) = delete;
  NodeOpGenericCastToPtrExplicit(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    StorageClass storage)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->storage = storage;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGenericPtrMemSemantics
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGenericPtrMemSemantics;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpGenericPtrMemSemantics() = default;
  ~NodeOpGenericPtrMemSemantics() = default;
  NodeOpGenericPtrMemSemantics(const NodeOpGenericPtrMemSemantics &) = delete;
  NodeOpGenericPtrMemSemantics &operator=(const NodeOpGenericPtrMemSemantics &) = delete;
  NodeOpGenericPtrMemSemantics(NodeOpGenericPtrMemSemantics &&) = delete;
  NodeOpGenericPtrMemSemantics &operator=(NodeOpGenericPtrMemSemantics &&) = delete;
  NodeOpGenericPtrMemSemantics(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformPartitionNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGroupNonUniformPartitionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpGroupNonUniformPartitionNV() = default;
  ~NodeOpGroupNonUniformPartitionNV() = default;
  NodeOpGroupNonUniformPartitionNV(const NodeOpGroupNonUniformPartitionNV &) = delete;
  NodeOpGroupNonUniformPartitionNV &operator=(const NodeOpGroupNonUniformPartitionNV &) = delete;
  NodeOpGroupNonUniformPartitionNV(NodeOpGroupNonUniformPartitionNV &&) = delete;
  NodeOpGroupNonUniformPartitionNV &operator=(NodeOpGroupNonUniformPartitionNV &&) = delete;
  NodeOpGroupNonUniformPartitionNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformQuadAllKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGroupNonUniformQuadAllKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpGroupNonUniformQuadAllKHR() = default;
  ~NodeOpGroupNonUniformQuadAllKHR() = default;
  NodeOpGroupNonUniformQuadAllKHR(const NodeOpGroupNonUniformQuadAllKHR &) = delete;
  NodeOpGroupNonUniformQuadAllKHR &operator=(const NodeOpGroupNonUniformQuadAllKHR &) = delete;
  NodeOpGroupNonUniformQuadAllKHR(NodeOpGroupNonUniformQuadAllKHR &&) = delete;
  NodeOpGroupNonUniformQuadAllKHR &operator=(NodeOpGroupNonUniformQuadAllKHR &&) = delete;
  NodeOpGroupNonUniformQuadAllKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGroupNonUniformQuadAnyKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpGroupNonUniformQuadAnyKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpGroupNonUniformQuadAnyKHR() = default;
  ~NodeOpGroupNonUniformQuadAnyKHR() = default;
  NodeOpGroupNonUniformQuadAnyKHR(const NodeOpGroupNonUniformQuadAnyKHR &) = delete;
  NodeOpGroupNonUniformQuadAnyKHR &operator=(const NodeOpGroupNonUniformQuadAnyKHR &) = delete;
  NodeOpGroupNonUniformQuadAnyKHR(NodeOpGroupNonUniformQuadAnyKHR &&) = delete;
  NodeOpGroupNonUniformQuadAnyKHR &operator=(NodeOpGroupNonUniformQuadAnyKHR &&) = delete;
  NodeOpGroupNonUniformQuadAnyKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetCurrentTimeNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetCurrentTimeNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetCurrentTimeNV() = default;
  ~NodeOpHitObjectGetCurrentTimeNV() = default;
  NodeOpHitObjectGetCurrentTimeNV(const NodeOpHitObjectGetCurrentTimeNV &) = delete;
  NodeOpHitObjectGetCurrentTimeNV &operator=(const NodeOpHitObjectGetCurrentTimeNV &) = delete;
  NodeOpHitObjectGetCurrentTimeNV(NodeOpHitObjectGetCurrentTimeNV &&) = delete;
  NodeOpHitObjectGetCurrentTimeNV &operator=(NodeOpHitObjectGetCurrentTimeNV &&) = delete;
  NodeOpHitObjectGetCurrentTimeNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetGeometryIndexNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetGeometryIndexNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetGeometryIndexNV() = default;
  ~NodeOpHitObjectGetGeometryIndexNV() = default;
  NodeOpHitObjectGetGeometryIndexNV(const NodeOpHitObjectGetGeometryIndexNV &) = delete;
  NodeOpHitObjectGetGeometryIndexNV &operator=(const NodeOpHitObjectGetGeometryIndexNV &) = delete;
  NodeOpHitObjectGetGeometryIndexNV(NodeOpHitObjectGetGeometryIndexNV &&) = delete;
  NodeOpHitObjectGetGeometryIndexNV &operator=(NodeOpHitObjectGetGeometryIndexNV &&) = delete;
  NodeOpHitObjectGetGeometryIndexNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetHitKindNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetHitKindNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetHitKindNV() = default;
  ~NodeOpHitObjectGetHitKindNV() = default;
  NodeOpHitObjectGetHitKindNV(const NodeOpHitObjectGetHitKindNV &) = delete;
  NodeOpHitObjectGetHitKindNV &operator=(const NodeOpHitObjectGetHitKindNV &) = delete;
  NodeOpHitObjectGetHitKindNV(NodeOpHitObjectGetHitKindNV &&) = delete;
  NodeOpHitObjectGetHitKindNV &operator=(NodeOpHitObjectGetHitKindNV &&) = delete;
  NodeOpHitObjectGetHitKindNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetInstanceCustomIndexNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetInstanceCustomIndexNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetInstanceCustomIndexNV() = default;
  ~NodeOpHitObjectGetInstanceCustomIndexNV() = default;
  NodeOpHitObjectGetInstanceCustomIndexNV(const NodeOpHitObjectGetInstanceCustomIndexNV &) = delete;
  NodeOpHitObjectGetInstanceCustomIndexNV &operator=(const NodeOpHitObjectGetInstanceCustomIndexNV &) = delete;
  NodeOpHitObjectGetInstanceCustomIndexNV(NodeOpHitObjectGetInstanceCustomIndexNV &&) = delete;
  NodeOpHitObjectGetInstanceCustomIndexNV &operator=(NodeOpHitObjectGetInstanceCustomIndexNV &&) = delete;
  NodeOpHitObjectGetInstanceCustomIndexNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetInstanceIdNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetInstanceIdNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetInstanceIdNV() = default;
  ~NodeOpHitObjectGetInstanceIdNV() = default;
  NodeOpHitObjectGetInstanceIdNV(const NodeOpHitObjectGetInstanceIdNV &) = delete;
  NodeOpHitObjectGetInstanceIdNV &operator=(const NodeOpHitObjectGetInstanceIdNV &) = delete;
  NodeOpHitObjectGetInstanceIdNV(NodeOpHitObjectGetInstanceIdNV &&) = delete;
  NodeOpHitObjectGetInstanceIdNV &operator=(NodeOpHitObjectGetInstanceIdNV &&) = delete;
  NodeOpHitObjectGetInstanceIdNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetObjectRayDirectionNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetObjectRayDirectionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetObjectRayDirectionNV() = default;
  ~NodeOpHitObjectGetObjectRayDirectionNV() = default;
  NodeOpHitObjectGetObjectRayDirectionNV(const NodeOpHitObjectGetObjectRayDirectionNV &) = delete;
  NodeOpHitObjectGetObjectRayDirectionNV &operator=(const NodeOpHitObjectGetObjectRayDirectionNV &) = delete;
  NodeOpHitObjectGetObjectRayDirectionNV(NodeOpHitObjectGetObjectRayDirectionNV &&) = delete;
  NodeOpHitObjectGetObjectRayDirectionNV &operator=(NodeOpHitObjectGetObjectRayDirectionNV &&) = delete;
  NodeOpHitObjectGetObjectRayDirectionNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetObjectRayOriginNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetObjectRayOriginNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetObjectRayOriginNV() = default;
  ~NodeOpHitObjectGetObjectRayOriginNV() = default;
  NodeOpHitObjectGetObjectRayOriginNV(const NodeOpHitObjectGetObjectRayOriginNV &) = delete;
  NodeOpHitObjectGetObjectRayOriginNV &operator=(const NodeOpHitObjectGetObjectRayOriginNV &) = delete;
  NodeOpHitObjectGetObjectRayOriginNV(NodeOpHitObjectGetObjectRayOriginNV &&) = delete;
  NodeOpHitObjectGetObjectRayOriginNV &operator=(NodeOpHitObjectGetObjectRayOriginNV &&) = delete;
  NodeOpHitObjectGetObjectRayOriginNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetObjectToWorldNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetObjectToWorldNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetObjectToWorldNV() = default;
  ~NodeOpHitObjectGetObjectToWorldNV() = default;
  NodeOpHitObjectGetObjectToWorldNV(const NodeOpHitObjectGetObjectToWorldNV &) = delete;
  NodeOpHitObjectGetObjectToWorldNV &operator=(const NodeOpHitObjectGetObjectToWorldNV &) = delete;
  NodeOpHitObjectGetObjectToWorldNV(NodeOpHitObjectGetObjectToWorldNV &&) = delete;
  NodeOpHitObjectGetObjectToWorldNV &operator=(NodeOpHitObjectGetObjectToWorldNV &&) = delete;
  NodeOpHitObjectGetObjectToWorldNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetPrimitiveIndexNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetPrimitiveIndexNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetPrimitiveIndexNV() = default;
  ~NodeOpHitObjectGetPrimitiveIndexNV() = default;
  NodeOpHitObjectGetPrimitiveIndexNV(const NodeOpHitObjectGetPrimitiveIndexNV &) = delete;
  NodeOpHitObjectGetPrimitiveIndexNV &operator=(const NodeOpHitObjectGetPrimitiveIndexNV &) = delete;
  NodeOpHitObjectGetPrimitiveIndexNV(NodeOpHitObjectGetPrimitiveIndexNV &&) = delete;
  NodeOpHitObjectGetPrimitiveIndexNV &operator=(NodeOpHitObjectGetPrimitiveIndexNV &&) = delete;
  NodeOpHitObjectGetPrimitiveIndexNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetRayTMaxNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetRayTMaxNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetRayTMaxNV() = default;
  ~NodeOpHitObjectGetRayTMaxNV() = default;
  NodeOpHitObjectGetRayTMaxNV(const NodeOpHitObjectGetRayTMaxNV &) = delete;
  NodeOpHitObjectGetRayTMaxNV &operator=(const NodeOpHitObjectGetRayTMaxNV &) = delete;
  NodeOpHitObjectGetRayTMaxNV(NodeOpHitObjectGetRayTMaxNV &&) = delete;
  NodeOpHitObjectGetRayTMaxNV &operator=(NodeOpHitObjectGetRayTMaxNV &&) = delete;
  NodeOpHitObjectGetRayTMaxNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetRayTMinNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetRayTMinNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetRayTMinNV() = default;
  ~NodeOpHitObjectGetRayTMinNV() = default;
  NodeOpHitObjectGetRayTMinNV(const NodeOpHitObjectGetRayTMinNV &) = delete;
  NodeOpHitObjectGetRayTMinNV &operator=(const NodeOpHitObjectGetRayTMinNV &) = delete;
  NodeOpHitObjectGetRayTMinNV(NodeOpHitObjectGetRayTMinNV &&) = delete;
  NodeOpHitObjectGetRayTMinNV &operator=(NodeOpHitObjectGetRayTMinNV &&) = delete;
  NodeOpHitObjectGetRayTMinNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetShaderBindingTableRecordIndexNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetShaderBindingTableRecordIndexNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV() = default;
  ~NodeOpHitObjectGetShaderBindingTableRecordIndexNV() = default;
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV(const NodeOpHitObjectGetShaderBindingTableRecordIndexNV &) = delete;
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV &operator=(const NodeOpHitObjectGetShaderBindingTableRecordIndexNV &) = delete;
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV(NodeOpHitObjectGetShaderBindingTableRecordIndexNV &&) = delete;
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV &operator=(NodeOpHitObjectGetShaderBindingTableRecordIndexNV &&) = delete;
  NodeOpHitObjectGetShaderBindingTableRecordIndexNV(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetShaderRecordBufferHandleNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetShaderRecordBufferHandleNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetShaderRecordBufferHandleNV() = default;
  ~NodeOpHitObjectGetShaderRecordBufferHandleNV() = default;
  NodeOpHitObjectGetShaderRecordBufferHandleNV(const NodeOpHitObjectGetShaderRecordBufferHandleNV &) = delete;
  NodeOpHitObjectGetShaderRecordBufferHandleNV &operator=(const NodeOpHitObjectGetShaderRecordBufferHandleNV &) = delete;
  NodeOpHitObjectGetShaderRecordBufferHandleNV(NodeOpHitObjectGetShaderRecordBufferHandleNV &&) = delete;
  NodeOpHitObjectGetShaderRecordBufferHandleNV &operator=(NodeOpHitObjectGetShaderRecordBufferHandleNV &&) = delete;
  NodeOpHitObjectGetShaderRecordBufferHandleNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetWorldRayDirectionNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetWorldRayDirectionNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetWorldRayDirectionNV() = default;
  ~NodeOpHitObjectGetWorldRayDirectionNV() = default;
  NodeOpHitObjectGetWorldRayDirectionNV(const NodeOpHitObjectGetWorldRayDirectionNV &) = delete;
  NodeOpHitObjectGetWorldRayDirectionNV &operator=(const NodeOpHitObjectGetWorldRayDirectionNV &) = delete;
  NodeOpHitObjectGetWorldRayDirectionNV(NodeOpHitObjectGetWorldRayDirectionNV &&) = delete;
  NodeOpHitObjectGetWorldRayDirectionNV &operator=(NodeOpHitObjectGetWorldRayDirectionNV &&) = delete;
  NodeOpHitObjectGetWorldRayDirectionNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetWorldRayOriginNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetWorldRayOriginNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetWorldRayOriginNV() = default;
  ~NodeOpHitObjectGetWorldRayOriginNV() = default;
  NodeOpHitObjectGetWorldRayOriginNV(const NodeOpHitObjectGetWorldRayOriginNV &) = delete;
  NodeOpHitObjectGetWorldRayOriginNV &operator=(const NodeOpHitObjectGetWorldRayOriginNV &) = delete;
  NodeOpHitObjectGetWorldRayOriginNV(NodeOpHitObjectGetWorldRayOriginNV &&) = delete;
  NodeOpHitObjectGetWorldRayOriginNV &operator=(NodeOpHitObjectGetWorldRayOriginNV &&) = delete;
  NodeOpHitObjectGetWorldRayOriginNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectGetWorldToObjectNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectGetWorldToObjectNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectGetWorldToObjectNV() = default;
  ~NodeOpHitObjectGetWorldToObjectNV() = default;
  NodeOpHitObjectGetWorldToObjectNV(const NodeOpHitObjectGetWorldToObjectNV &) = delete;
  NodeOpHitObjectGetWorldToObjectNV &operator=(const NodeOpHitObjectGetWorldToObjectNV &) = delete;
  NodeOpHitObjectGetWorldToObjectNV(NodeOpHitObjectGetWorldToObjectNV &&) = delete;
  NodeOpHitObjectGetWorldToObjectNV &operator=(NodeOpHitObjectGetWorldToObjectNV &&) = delete;
  NodeOpHitObjectGetWorldToObjectNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectIsEmptyNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectIsEmptyNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectIsEmptyNV() = default;
  ~NodeOpHitObjectIsEmptyNV() = default;
  NodeOpHitObjectIsEmptyNV(const NodeOpHitObjectIsEmptyNV &) = delete;
  NodeOpHitObjectIsEmptyNV &operator=(const NodeOpHitObjectIsEmptyNV &) = delete;
  NodeOpHitObjectIsEmptyNV(NodeOpHitObjectIsEmptyNV &&) = delete;
  NodeOpHitObjectIsEmptyNV &operator=(NodeOpHitObjectIsEmptyNV &&) = delete;
  NodeOpHitObjectIsEmptyNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectIsHitNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectIsHitNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectIsHitNV() = default;
  ~NodeOpHitObjectIsHitNV() = default;
  NodeOpHitObjectIsHitNV(const NodeOpHitObjectIsHitNV &) = delete;
  NodeOpHitObjectIsHitNV &operator=(const NodeOpHitObjectIsHitNV &) = delete;
  NodeOpHitObjectIsHitNV(NodeOpHitObjectIsHitNV &&) = delete;
  NodeOpHitObjectIsHitNV &operator=(NodeOpHitObjectIsHitNV &&) = delete;
  NodeOpHitObjectIsHitNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpHitObjectIsMissNV
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpHitObjectIsMissNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> hitObject;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(hitObject);
  }
  NodeOpHitObjectIsMissNV() = default;
  ~NodeOpHitObjectIsMissNV() = default;
  NodeOpHitObjectIsMissNV(const NodeOpHitObjectIsMissNV &) = delete;
  NodeOpHitObjectIsMissNV &operator=(const NodeOpHitObjectIsMissNV &) = delete;
  NodeOpHitObjectIsMissNV(NodeOpHitObjectIsMissNV &&) = delete;
  NodeOpHitObjectIsMissNV &operator=(NodeOpHitObjectIsMissNV &&) = delete;
  NodeOpHitObjectIsMissNV(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> hit_object)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->hitObject = hit_object;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageSparseTexelsResident
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpImageSparseTexelsResident;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> residentCode;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(residentCode);
  }
  NodeOpImageSparseTexelsResident() = default;
  ~NodeOpImageSparseTexelsResident() = default;
  NodeOpImageSparseTexelsResident(const NodeOpImageSparseTexelsResident &) = delete;
  NodeOpImageSparseTexelsResident &operator=(const NodeOpImageSparseTexelsResident &) = delete;
  NodeOpImageSparseTexelsResident(NodeOpImageSparseTexelsResident &&) = delete;
  NodeOpImageSparseTexelsResident &operator=(NodeOpImageSparseTexelsResident &&) = delete;
  NodeOpImageSparseTexelsResident(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> resident_code)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->residentCode = resident_code;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsFinite
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsFinite;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpIsFinite() = default;
  ~NodeOpIsFinite() = default;
  NodeOpIsFinite(const NodeOpIsFinite &) = delete;
  NodeOpIsFinite &operator=(const NodeOpIsFinite &) = delete;
  NodeOpIsFinite(NodeOpIsFinite &&) = delete;
  NodeOpIsFinite &operator=(NodeOpIsFinite &&) = delete;
  NodeOpIsFinite(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsInf
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsInf;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpIsInf() = default;
  ~NodeOpIsInf() = default;
  NodeOpIsInf(const NodeOpIsInf &) = delete;
  NodeOpIsInf &operator=(const NodeOpIsInf &) = delete;
  NodeOpIsInf(NodeOpIsInf &&) = delete;
  NodeOpIsInf &operator=(NodeOpIsInf &&) = delete;
  NodeOpIsInf(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsNan
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsNan;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpIsNan() = default;
  ~NodeOpIsNan() = default;
  NodeOpIsNan(const NodeOpIsNan &) = delete;
  NodeOpIsNan &operator=(const NodeOpIsNan &) = delete;
  NodeOpIsNan(NodeOpIsNan &&) = delete;
  NodeOpIsNan &operator=(NodeOpIsNan &&) = delete;
  NodeOpIsNan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsNormal
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsNormal;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpIsNormal() = default;
  ~NodeOpIsNormal() = default;
  NodeOpIsNormal(const NodeOpIsNormal &) = delete;
  NodeOpIsNormal &operator=(const NodeOpIsNormal &) = delete;
  NodeOpIsNormal(NodeOpIsNormal &&) = delete;
  NodeOpIsNormal &operator=(NodeOpIsNormal &&) = delete;
  NodeOpIsNormal(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsValidEvent
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsValidEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> event;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(event);
  }
  NodeOpIsValidEvent() = default;
  ~NodeOpIsValidEvent() = default;
  NodeOpIsValidEvent(const NodeOpIsValidEvent &) = delete;
  NodeOpIsValidEvent &operator=(const NodeOpIsValidEvent &) = delete;
  NodeOpIsValidEvent(NodeOpIsValidEvent &&) = delete;
  NodeOpIsValidEvent &operator=(NodeOpIsValidEvent &&) = delete;
  NodeOpIsValidEvent(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> event)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->event = event;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpIsValidReserveId
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpIsValidReserveId;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> reserveId;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(reserveId);
  }
  NodeOpIsValidReserveId() = default;
  ~NodeOpIsValidReserveId() = default;
  NodeOpIsValidReserveId(const NodeOpIsValidReserveId &) = delete;
  NodeOpIsValidReserveId &operator=(const NodeOpIsValidReserveId &) = delete;
  NodeOpIsValidReserveId(NodeOpIsValidReserveId &&) = delete;
  NodeOpIsValidReserveId &operator=(NodeOpIsValidReserveId &&) = delete;
  NodeOpIsValidReserveId(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> reserve_id)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->reserveId = reserve_id;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLoad
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpLoad;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  eastl::optional<MemoryAccessMask> memoryAccess;
  // extra values for memoryAccess
  LiteralInteger memoryAccessAligned;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailable;
  NodePointer<NodeOperation> memoryAccessMakePointerAvailableKHR;
  NodePointer<NodeOperation> memoryAccessMakePointerVisible;
  NodePointer<NodeOperation> memoryAccessMakePointerVisibleKHR;
  NodePointer<NodeId> memoryAccessAliasScopeINTELMask;
  NodePointer<NodeId> memoryAccessNoAliasINTELMask;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
    if (memoryAccessMakePointerAvailable)
      visitor(memoryAccessMakePointerAvailable);
    if (memoryAccessMakePointerAvailableKHR)
      visitor(memoryAccessMakePointerAvailableKHR);
    if (memoryAccessMakePointerVisible)
      visitor(memoryAccessMakePointerVisible);
    if (memoryAccessMakePointerVisibleKHR)
      visitor(memoryAccessMakePointerVisibleKHR);
    if (memoryAccessAliasScopeINTELMask)
      visitor(memoryAccessAliasScopeINTELMask);
    if (memoryAccessNoAliasINTELMask)
      visitor(memoryAccessNoAliasINTELMask);
  }
  NodeOpLoad() = default;
  ~NodeOpLoad() = default;
  NodeOpLoad(const NodeOpLoad &) = delete;
  NodeOpLoad &operator=(const NodeOpLoad &) = delete;
  NodeOpLoad(NodeOpLoad &&) = delete;
  NodeOpLoad &operator=(NodeOpLoad &&) = delete;
  NodeOpLoad(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer,
    eastl::optional<MemoryAccessMask> memory_access, eastl::optional<LiteralInteger> memory_access_aligned = {},
    NodePointer<NodeOperation> memory_access_makePointerAvailable = {},
    NodePointer<NodeOperation> memory_access_makePointerAvailableKHR = {},
    NodePointer<NodeOperation> memory_access_makePointerVisible = {},
    NodePointer<NodeOperation> memory_access_makePointerVisibleKHR = {}, NodePointer<NodeId> memory_access_aliasScopeINTELMask = {},
    NodePointer<NodeId> memory_access_noAliasINTELMask = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
    this->memoryAccess = memory_access;
    if (memory_access_aligned)
      this->memoryAccessAligned = *memory_access_aligned;
    this->memoryAccessMakePointerAvailable = memory_access_makePointerAvailable;
    this->memoryAccessMakePointerAvailableKHR = memory_access_makePointerAvailableKHR;
    this->memoryAccessMakePointerVisible = memory_access_makePointerVisible;
    this->memoryAccessMakePointerVisibleKHR = memory_access_makePointerVisibleKHR;
    this->memoryAccessAliasScopeINTELMask = memory_access_aliasScopeINTELMask;
    this->memoryAccessNoAliasINTELMask = memory_access_noAliasINTELMask;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpLogicalNot
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpLogicalNot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpLogicalNot() = default;
  ~NodeOpLogicalNot() = default;
  NodeOpLogicalNot(const NodeOpLogicalNot &) = delete;
  NodeOpLogicalNot &operator=(const NodeOpLogicalNot &) = delete;
  NodeOpLogicalNot(NodeOpLogicalNot &&) = delete;
  NodeOpLogicalNot &operator=(NodeOpLogicalNot &&) = delete;
  NodeOpLogicalNot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpMaskedGatherINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpMaskedGatherINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> ptrVector;
  LiteralInteger alignment;
  NodePointer<NodeId> mask;
  NodePointer<NodeId> fillEmpty;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(ptrVector);
    visitor(mask);
    visitor(fillEmpty);
  }
  NodeOpMaskedGatherINTEL() = default;
  ~NodeOpMaskedGatherINTEL() = default;
  NodeOpMaskedGatherINTEL(const NodeOpMaskedGatherINTEL &) = delete;
  NodeOpMaskedGatherINTEL &operator=(const NodeOpMaskedGatherINTEL &) = delete;
  NodeOpMaskedGatherINTEL(NodeOpMaskedGatherINTEL &&) = delete;
  NodeOpMaskedGatherINTEL &operator=(NodeOpMaskedGatherINTEL &&) = delete;
  NodeOpMaskedGatherINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ptr_vector,
    LiteralInteger alignment, NodePointer<NodeId> mask, NodePointer<NodeId> fill_empty)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->ptrVector = ptr_vector;
    this->alignment = alignment;
    this->mask = mask;
    this->fillEmpty = fill_empty;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpNamedBarrierInitialize
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpNamedBarrierInitialize;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> subgroupCount;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(subgroupCount);
  }
  NodeOpNamedBarrierInitialize() = default;
  ~NodeOpNamedBarrierInitialize() = default;
  NodeOpNamedBarrierInitialize(const NodeOpNamedBarrierInitialize &) = delete;
  NodeOpNamedBarrierInitialize &operator=(const NodeOpNamedBarrierInitialize &) = delete;
  NodeOpNamedBarrierInitialize(NodeOpNamedBarrierInitialize &&) = delete;
  NodeOpNamedBarrierInitialize &operator=(NodeOpNamedBarrierInitialize &&) = delete;
  NodeOpNamedBarrierInitialize(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> subgroup_count)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->subgroupCount = subgroup_count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpNot
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpNot;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpNot() = default;
  ~NodeOpNot() = default;
  NodeOpNot(const NodeOpNot &) = delete;
  NodeOpNot &operator=(const NodeOpNot &) = delete;
  NodeOpNot(NodeOpNot &&) = delete;
  NodeOpNot &operator=(NodeOpNot &&) = delete;
  NodeOpNot(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrCastToCrossWorkgroupINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpPtrCastToCrossWorkgroupINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpPtrCastToCrossWorkgroupINTEL() = default;
  ~NodeOpPtrCastToCrossWorkgroupINTEL() = default;
  NodeOpPtrCastToCrossWorkgroupINTEL(const NodeOpPtrCastToCrossWorkgroupINTEL &) = delete;
  NodeOpPtrCastToCrossWorkgroupINTEL &operator=(const NodeOpPtrCastToCrossWorkgroupINTEL &) = delete;
  NodeOpPtrCastToCrossWorkgroupINTEL(NodeOpPtrCastToCrossWorkgroupINTEL &&) = delete;
  NodeOpPtrCastToCrossWorkgroupINTEL &operator=(NodeOpPtrCastToCrossWorkgroupINTEL &&) = delete;
  NodeOpPtrCastToCrossWorkgroupINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrCastToGeneric
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpPtrCastToGeneric;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpPtrCastToGeneric() = default;
  ~NodeOpPtrCastToGeneric() = default;
  NodeOpPtrCastToGeneric(const NodeOpPtrCastToGeneric &) = delete;
  NodeOpPtrCastToGeneric &operator=(const NodeOpPtrCastToGeneric &) = delete;
  NodeOpPtrCastToGeneric(NodeOpPtrCastToGeneric &&) = delete;
  NodeOpPtrCastToGeneric &operator=(NodeOpPtrCastToGeneric &&) = delete;
  NodeOpPtrCastToGeneric(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpQuantizeToF16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpQuantizeToF16;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpQuantizeToF16() = default;
  ~NodeOpQuantizeToF16() = default;
  NodeOpQuantizeToF16(const NodeOpQuantizeToF16 &) = delete;
  NodeOpQuantizeToF16 &operator=(const NodeOpQuantizeToF16 &) = delete;
  NodeOpQuantizeToF16(NodeOpQuantizeToF16 &&) = delete;
  NodeOpQuantizeToF16 &operator=(NodeOpQuantizeToF16 &&) = delete;
  NodeOpQuantizeToF16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR() = default;
  ~NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR() = default;
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR(const NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &) = delete;
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &operator=(const NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &) = delete;
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR(NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &&) = delete;
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &operator=(NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR &&) = delete;
  NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetRayFlagsKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryGetRayFlagsKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryGetRayFlagsKHR() = default;
  ~NodeOpRayQueryGetRayFlagsKHR() = default;
  NodeOpRayQueryGetRayFlagsKHR(const NodeOpRayQueryGetRayFlagsKHR &) = delete;
  NodeOpRayQueryGetRayFlagsKHR &operator=(const NodeOpRayQueryGetRayFlagsKHR &) = delete;
  NodeOpRayQueryGetRayFlagsKHR(NodeOpRayQueryGetRayFlagsKHR &&) = delete;
  NodeOpRayQueryGetRayFlagsKHR &operator=(NodeOpRayQueryGetRayFlagsKHR &&) = delete;
  NodeOpRayQueryGetRayFlagsKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetRayTMinKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryGetRayTMinKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryGetRayTMinKHR() = default;
  ~NodeOpRayQueryGetRayTMinKHR() = default;
  NodeOpRayQueryGetRayTMinKHR(const NodeOpRayQueryGetRayTMinKHR &) = delete;
  NodeOpRayQueryGetRayTMinKHR &operator=(const NodeOpRayQueryGetRayTMinKHR &) = delete;
  NodeOpRayQueryGetRayTMinKHR(NodeOpRayQueryGetRayTMinKHR &&) = delete;
  NodeOpRayQueryGetRayTMinKHR &operator=(NodeOpRayQueryGetRayTMinKHR &&) = delete;
  NodeOpRayQueryGetRayTMinKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetWorldRayDirectionKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryGetWorldRayDirectionKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryGetWorldRayDirectionKHR() = default;
  ~NodeOpRayQueryGetWorldRayDirectionKHR() = default;
  NodeOpRayQueryGetWorldRayDirectionKHR(const NodeOpRayQueryGetWorldRayDirectionKHR &) = delete;
  NodeOpRayQueryGetWorldRayDirectionKHR &operator=(const NodeOpRayQueryGetWorldRayDirectionKHR &) = delete;
  NodeOpRayQueryGetWorldRayDirectionKHR(NodeOpRayQueryGetWorldRayDirectionKHR &&) = delete;
  NodeOpRayQueryGetWorldRayDirectionKHR &operator=(NodeOpRayQueryGetWorldRayDirectionKHR &&) = delete;
  NodeOpRayQueryGetWorldRayDirectionKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryGetWorldRayOriginKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryGetWorldRayOriginKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryGetWorldRayOriginKHR() = default;
  ~NodeOpRayQueryGetWorldRayOriginKHR() = default;
  NodeOpRayQueryGetWorldRayOriginKHR(const NodeOpRayQueryGetWorldRayOriginKHR &) = delete;
  NodeOpRayQueryGetWorldRayOriginKHR &operator=(const NodeOpRayQueryGetWorldRayOriginKHR &) = delete;
  NodeOpRayQueryGetWorldRayOriginKHR(NodeOpRayQueryGetWorldRayOriginKHR &&) = delete;
  NodeOpRayQueryGetWorldRayOriginKHR &operator=(NodeOpRayQueryGetWorldRayOriginKHR &&) = delete;
  NodeOpRayQueryGetWorldRayOriginKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpRayQueryProceedKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpRayQueryProceedKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> rayQuery;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(rayQuery);
  }
  NodeOpRayQueryProceedKHR() = default;
  ~NodeOpRayQueryProceedKHR() = default;
  NodeOpRayQueryProceedKHR(const NodeOpRayQueryProceedKHR &) = delete;
  NodeOpRayQueryProceedKHR &operator=(const NodeOpRayQueryProceedKHR &) = delete;
  NodeOpRayQueryProceedKHR(NodeOpRayQueryProceedKHR &&) = delete;
  NodeOpRayQueryProceedKHR &operator=(NodeOpRayQueryProceedKHR &&) = delete;
  NodeOpRayQueryProceedKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ray_query)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->rayQuery = ray_query;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSConvert
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSConvert;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> signedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(signedValue);
  }
  NodeOpSConvert() = default;
  ~NodeOpSConvert() = default;
  NodeOpSConvert(const NodeOpSConvert &) = delete;
  NodeOpSConvert &operator=(const NodeOpSConvert &) = delete;
  NodeOpSConvert(NodeOpSConvert &&) = delete;
  NodeOpSConvert &operator=(NodeOpSConvert &&) = delete;
  NodeOpSConvert(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> signed_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->signedValue = signed_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSNegate
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSNegate;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpSNegate() = default;
  ~NodeOpSNegate() = default;
  NodeOpSNegate(const NodeOpSNegate &) = delete;
  NodeOpSNegate &operator=(const NodeOpSNegate &) = delete;
  NodeOpSNegate(NodeOpSNegate &&) = delete;
  NodeOpSNegate &operator=(NodeOpSNegate &&) = delete;
  NodeOpSNegate(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSatConvertSToU
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSatConvertSToU;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> signedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(signedValue);
  }
  NodeOpSatConvertSToU() = default;
  ~NodeOpSatConvertSToU() = default;
  NodeOpSatConvertSToU(const NodeOpSatConvertSToU &) = delete;
  NodeOpSatConvertSToU &operator=(const NodeOpSatConvertSToU &) = delete;
  NodeOpSatConvertSToU(NodeOpSatConvertSToU &&) = delete;
  NodeOpSatConvertSToU &operator=(NodeOpSatConvertSToU &&) = delete;
  NodeOpSatConvertSToU(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> signed_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->signedValue = signed_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSatConvertUToS
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSatConvertUToS;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> unsignedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(unsignedValue);
  }
  NodeOpSatConvertUToS() = default;
  ~NodeOpSatConvertUToS() = default;
  NodeOpSatConvertUToS(const NodeOpSatConvertUToS &) = delete;
  NodeOpSatConvertUToS &operator=(const NodeOpSatConvertUToS &) = delete;
  NodeOpSatConvertUToS(NodeOpSatConvertUToS &&) = delete;
  NodeOpSatConvertUToS &operator=(NodeOpSatConvertUToS &&) = delete;
  NodeOpSatConvertUToS(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> unsigned_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->unsignedValue = unsigned_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSignBitSet
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSignBitSet;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpSignBitSet() = default;
  ~NodeOpSignBitSet() = default;
  NodeOpSignBitSet(const NodeOpSignBitSet &) = delete;
  NodeOpSignBitSet &operator=(const NodeOpSignBitSet &) = delete;
  NodeOpSignBitSet(NodeOpSignBitSet &&) = delete;
  NodeOpSignBitSet &operator=(NodeOpSignBitSet &&) = delete;
  NodeOpSignBitSet(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSizeOf
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSizeOf;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> pointer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(pointer);
  }
  NodeOpSizeOf() = default;
  ~NodeOpSizeOf() = default;
  NodeOpSizeOf(const NodeOpSizeOf &) = delete;
  NodeOpSizeOf &operator=(const NodeOpSizeOf &) = delete;
  NodeOpSizeOf(NodeOpSizeOf &&) = delete;
  NodeOpSizeOf &operator=(NodeOpSizeOf &&) = delete;
  NodeOpSizeOf(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> pointer)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->pointer = pointer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAllEqualKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAllEqualKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpSubgroupAllEqualKHR() = default;
  ~NodeOpSubgroupAllEqualKHR() = default;
  NodeOpSubgroupAllEqualKHR(const NodeOpSubgroupAllEqualKHR &) = delete;
  NodeOpSubgroupAllEqualKHR &operator=(const NodeOpSubgroupAllEqualKHR &) = delete;
  NodeOpSubgroupAllEqualKHR(NodeOpSubgroupAllEqualKHR &&) = delete;
  NodeOpSubgroupAllEqualKHR &operator=(NodeOpSubgroupAllEqualKHR &&) = delete;
  NodeOpSubgroupAllEqualKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAllKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAllKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpSubgroupAllKHR() = default;
  ~NodeOpSubgroupAllKHR() = default;
  NodeOpSubgroupAllKHR(const NodeOpSubgroupAllKHR &) = delete;
  NodeOpSubgroupAllKHR &operator=(const NodeOpSubgroupAllKHR &) = delete;
  NodeOpSubgroupAllKHR(NodeOpSubgroupAllKHR &&) = delete;
  NodeOpSubgroupAllKHR &operator=(NodeOpSubgroupAllKHR &&) = delete;
  NodeOpSubgroupAllKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAnyKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAnyKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpSubgroupAnyKHR() = default;
  ~NodeOpSubgroupAnyKHR() = default;
  NodeOpSubgroupAnyKHR(const NodeOpSubgroupAnyKHR &) = delete;
  NodeOpSubgroupAnyKHR &operator=(const NodeOpSubgroupAnyKHR &) = delete;
  NodeOpSubgroupAnyKHR(NodeOpSubgroupAnyKHR &&) = delete;
  NodeOpSubgroupAnyKHR &operator=(NodeOpSubgroupAnyKHR &&) = delete;
  NodeOpSubgroupAnyKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeConvertToMcePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeConvertToMcePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL() = default;
  ~NodeOpSubgroupAvcImeConvertToMcePayloadINTEL() = default;
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL(const NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &operator=(const NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL(NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &operator=(NodeOpSubgroupAvcImeConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcImeConvertToMcePayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeConvertToMceResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeConvertToMceResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeConvertToMceResultINTEL() = default;
  ~NodeOpSubgroupAvcImeConvertToMceResultINTEL() = default;
  NodeOpSubgroupAvcImeConvertToMceResultINTEL(const NodeOpSubgroupAvcImeConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcImeConvertToMceResultINTEL &operator=(const NodeOpSubgroupAvcImeConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcImeConvertToMceResultINTEL(NodeOpSubgroupAvcImeConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcImeConvertToMceResultINTEL &operator=(NodeOpSubgroupAvcImeConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcImeConvertToMceResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetDualReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL() = default;
  ~NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL() = default;
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL(const NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &operator=(const NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL(NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &operator=(NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetSingleReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL() = default;
  ~NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL() = default;
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL(const NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &operator=(const NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &) = delete;
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL(NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &operator=(NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL() = default;
  ~NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL() = default;
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(const NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &) = delete;
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &operator=(
    const NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &) = delete;
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &operator=(NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL() = default;
  ~NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL() = default;
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(
    const NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &) = delete;
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &operator=(
    const NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &) = delete;
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(
    NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &operator=(
    NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL() = default;
  ~NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL() = default;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(
    const NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &operator=(
    const NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(
    NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &operator=(
    NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL() = default;
  ~NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL() = default;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(
    const NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &operator=(
    const NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(
    NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &operator=(
    NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL &&) = delete;
  NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL() = default;
  ~NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL() = default;
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(const NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &) = delete;
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &operator=(
    const NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &) = delete;
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &operator=(NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL &&) = delete;
  NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeStripDualReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL() = default;
  ~NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL() = default;
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL(const NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &operator=(
    const NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL(NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &operator=(NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL() = default;
  ~NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL() = default;
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(const NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &operator=(
    const NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &) = delete;
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &operator=(
    NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToImePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToImePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToImePayloadINTEL() = default;
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL(const NodeOpSubgroupAvcMceConvertToImePayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL &operator=(const NodeOpSubgroupAvcMceConvertToImePayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL(NodeOpSubgroupAvcMceConvertToImePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL &operator=(NodeOpSubgroupAvcMceConvertToImePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToImePayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToImeResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToImeResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToImeResultINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToImeResultINTEL() = default;
  NodeOpSubgroupAvcMceConvertToImeResultINTEL(const NodeOpSubgroupAvcMceConvertToImeResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToImeResultINTEL &operator=(const NodeOpSubgroupAvcMceConvertToImeResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToImeResultINTEL(NodeOpSubgroupAvcMceConvertToImeResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToImeResultINTEL &operator=(NodeOpSubgroupAvcMceConvertToImeResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToImeResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToRefPayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToRefPayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToRefPayloadINTEL() = default;
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL(const NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &operator=(const NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL(NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &operator=(NodeOpSubgroupAvcMceConvertToRefPayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToRefPayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToRefResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToRefResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToRefResultINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToRefResultINTEL() = default;
  NodeOpSubgroupAvcMceConvertToRefResultINTEL(const NodeOpSubgroupAvcMceConvertToRefResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToRefResultINTEL &operator=(const NodeOpSubgroupAvcMceConvertToRefResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToRefResultINTEL(NodeOpSubgroupAvcMceConvertToRefResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToRefResultINTEL &operator=(NodeOpSubgroupAvcMceConvertToRefResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToRefResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToSicPayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToSicPayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToSicPayloadINTEL() = default;
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL(const NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &operator=(const NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL(NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &operator=(NodeOpSubgroupAvcMceConvertToSicPayloadINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToSicPayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceConvertToSicResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceConvertToSicResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceConvertToSicResultINTEL() = default;
  ~NodeOpSubgroupAvcMceConvertToSicResultINTEL() = default;
  NodeOpSubgroupAvcMceConvertToSicResultINTEL(const NodeOpSubgroupAvcMceConvertToSicResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToSicResultINTEL &operator=(const NodeOpSubgroupAvcMceConvertToSicResultINTEL &) = delete;
  NodeOpSubgroupAvcMceConvertToSicResultINTEL(NodeOpSubgroupAvcMceConvertToSicResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToSicResultINTEL &operator=(NodeOpSubgroupAvcMceConvertToSicResultINTEL &&) = delete;
  NodeOpSubgroupAvcMceConvertToSicResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetBestInterDistortionsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL() = default;
  ~NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL() = default;
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL(const NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &operator=(const NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL(NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &operator=(NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterDirectionsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterDirectionsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterDirectionsINTEL() = default;
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL(const NodeOpSubgroupAvcMceGetInterDirectionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL &operator=(const NodeOpSubgroupAvcMceGetInterDirectionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL(NodeOpSubgroupAvcMceGetInterDirectionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL &operator=(NodeOpSubgroupAvcMceGetInterDirectionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterDirectionsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterDistortionsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterDistortionsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterDistortionsINTEL() = default;
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL(const NodeOpSubgroupAvcMceGetInterDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL &operator=(const NodeOpSubgroupAvcMceGetInterDistortionsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL(NodeOpSubgroupAvcMceGetInterDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL &operator=(NodeOpSubgroupAvcMceGetInterDistortionsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterDistortionsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterMajorShapeINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterMajorShapeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterMajorShapeINTEL() = default;
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL(const NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &operator=(const NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL(NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &operator=(NodeOpSubgroupAvcMceGetInterMajorShapeINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMajorShapeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterMinorShapeINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterMinorShapeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterMinorShapeINTEL() = default;
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL(const NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &operator=(const NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL(NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &operator=(NodeOpSubgroupAvcMceGetInterMinorShapeINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMinorShapeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterMotionVectorCountINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL() = default;
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL(const NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &operator=(const NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL(NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &operator=(NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetInterReferenceIdsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL() = default;
  ~NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL() = default;
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL(const NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &operator=(const NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL(NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &operator=(NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceGetMotionVectorsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceGetMotionVectorsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL() = default;
  ~NodeOpSubgroupAvcMceGetMotionVectorsINTEL() = default;
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL(const NodeOpSubgroupAvcMceGetMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL &operator=(const NodeOpSubgroupAvcMceGetMotionVectorsINTEL &) = delete;
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL(NodeOpSubgroupAvcMceGetMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL &operator=(NodeOpSubgroupAvcMceGetMotionVectorsINTEL &&) = delete;
  NodeOpSubgroupAvcMceGetMotionVectorsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcMceSetAcOnlyHaarINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL() = default;
  ~NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL() = default;
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL(const NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &) = delete;
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &operator=(const NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &) = delete;
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL(NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &operator=(NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL &&) = delete;
  NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefConvertToMcePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefConvertToMcePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL() = default;
  ~NodeOpSubgroupAvcRefConvertToMcePayloadINTEL() = default;
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL(const NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &operator=(const NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL(NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &operator=(NodeOpSubgroupAvcRefConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcRefConvertToMcePayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefConvertToMceResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefConvertToMceResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefConvertToMceResultINTEL() = default;
  ~NodeOpSubgroupAvcRefConvertToMceResultINTEL() = default;
  NodeOpSubgroupAvcRefConvertToMceResultINTEL(const NodeOpSubgroupAvcRefConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcRefConvertToMceResultINTEL &operator=(const NodeOpSubgroupAvcRefConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcRefConvertToMceResultINTEL(NodeOpSubgroupAvcRefConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcRefConvertToMceResultINTEL &operator=(NodeOpSubgroupAvcRefConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcRefConvertToMceResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefSetBidirectionalMixDisableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL() = default;
  ~NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL() = default;
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL(const NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &) = delete;
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &operator=(const NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &) = delete;
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL(NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &&) = delete;
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &operator=(NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL &&) = delete;
  NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcRefSetBilinearFilterEnableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL() = default;
  ~NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL() = default;
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL(const NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &) = delete;
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &operator=(const NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &) = delete;
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL(NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &&) = delete;
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &operator=(NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL &&) = delete;
  NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicConvertToMcePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicConvertToMcePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL() = default;
  ~NodeOpSubgroupAvcSicConvertToMcePayloadINTEL() = default;
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL(const NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &operator=(const NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &) = delete;
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL(NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &operator=(NodeOpSubgroupAvcSicConvertToMcePayloadINTEL &&) = delete;
  NodeOpSubgroupAvcSicConvertToMcePayloadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicConvertToMceResultINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicConvertToMceResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicConvertToMceResultINTEL() = default;
  ~NodeOpSubgroupAvcSicConvertToMceResultINTEL() = default;
  NodeOpSubgroupAvcSicConvertToMceResultINTEL(const NodeOpSubgroupAvcSicConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcSicConvertToMceResultINTEL &operator=(const NodeOpSubgroupAvcSicConvertToMceResultINTEL &) = delete;
  NodeOpSubgroupAvcSicConvertToMceResultINTEL(NodeOpSubgroupAvcSicConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcSicConvertToMceResultINTEL &operator=(NodeOpSubgroupAvcSicConvertToMceResultINTEL &&) = delete;
  NodeOpSubgroupAvcSicConvertToMceResultINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL() = default;
  ~NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL() = default;
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(const NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &) = delete;
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &operator=(const NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &) = delete;
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &operator=(NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL() = default;
  ~NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL() = default;
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(const NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &) = delete;
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &operator=(const NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &) = delete;
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &operator=(NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetInterRawSadsINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetInterRawSadsINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL() = default;
  ~NodeOpSubgroupAvcSicGetInterRawSadsINTEL() = default;
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL(const NodeOpSubgroupAvcSicGetInterRawSadsINTEL &) = delete;
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL &operator=(const NodeOpSubgroupAvcSicGetInterRawSadsINTEL &) = delete;
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL(NodeOpSubgroupAvcSicGetInterRawSadsINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL &operator=(NodeOpSubgroupAvcSicGetInterRawSadsINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetInterRawSadsINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetIpeChromaModeINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetIpeChromaModeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL() = default;
  ~NodeOpSubgroupAvcSicGetIpeChromaModeINTEL() = default;
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL(const NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &) = delete;
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &operator=(const NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &) = delete;
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL(NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &operator=(NodeOpSubgroupAvcSicGetIpeChromaModeINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetIpeChromaModeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetIpeLumaShapeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL() = default;
  ~NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL() = default;
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL(const NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &) = delete;
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &operator=(const NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &) = delete;
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL(NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &operator=(NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetPackedIpeLumaModesINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL() = default;
  ~NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL() = default;
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL(const NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &operator=(const NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL(NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &operator=(NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL() = default;
  ~NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL() = default;
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(const NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &operator=(
    const NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &operator=(
    NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL() = default;
  ~NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL() = default;
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(const NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &operator=(
    const NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &operator=(NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL &&) = delete;
  NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type,
    NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicInitializeINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicInitializeINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> srcCoord;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(srcCoord);
  }
  NodeOpSubgroupAvcSicInitializeINTEL() = default;
  ~NodeOpSubgroupAvcSicInitializeINTEL() = default;
  NodeOpSubgroupAvcSicInitializeINTEL(const NodeOpSubgroupAvcSicInitializeINTEL &) = delete;
  NodeOpSubgroupAvcSicInitializeINTEL &operator=(const NodeOpSubgroupAvcSicInitializeINTEL &) = delete;
  NodeOpSubgroupAvcSicInitializeINTEL(NodeOpSubgroupAvcSicInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcSicInitializeINTEL &operator=(NodeOpSubgroupAvcSicInitializeINTEL &&) = delete;
  NodeOpSubgroupAvcSicInitializeINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> src_coord)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->srcCoord = src_coord;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupAvcSicSetBilinearFilterEnableINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> payload;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(payload);
  }
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL() = default;
  ~NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL() = default;
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL(const NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &) = delete;
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &operator=(const NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &) = delete;
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL(NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &operator=(NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL &&) = delete;
  NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> payload)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->payload = payload;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupBallotKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupBallotKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> predicate;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(predicate);
  }
  NodeOpSubgroupBallotKHR() = default;
  ~NodeOpSubgroupBallotKHR() = default;
  NodeOpSubgroupBallotKHR(const NodeOpSubgroupBallotKHR &) = delete;
  NodeOpSubgroupBallotKHR &operator=(const NodeOpSubgroupBallotKHR &) = delete;
  NodeOpSubgroupBallotKHR(NodeOpSubgroupBallotKHR &&) = delete;
  NodeOpSubgroupBallotKHR &operator=(NodeOpSubgroupBallotKHR &&) = delete;
  NodeOpSubgroupBallotKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> predicate)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->predicate = predicate;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupBlockReadINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupBlockReadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> ptr;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(ptr);
  }
  NodeOpSubgroupBlockReadINTEL() = default;
  ~NodeOpSubgroupBlockReadINTEL() = default;
  NodeOpSubgroupBlockReadINTEL(const NodeOpSubgroupBlockReadINTEL &) = delete;
  NodeOpSubgroupBlockReadINTEL &operator=(const NodeOpSubgroupBlockReadINTEL &) = delete;
  NodeOpSubgroupBlockReadINTEL(NodeOpSubgroupBlockReadINTEL &&) = delete;
  NodeOpSubgroupBlockReadINTEL &operator=(NodeOpSubgroupBlockReadINTEL &&) = delete;
  NodeOpSubgroupBlockReadINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> ptr)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->ptr = ptr;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpSubgroupFirstInvocationKHR
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpSubgroupFirstInvocationKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> value;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(value);
  }
  NodeOpSubgroupFirstInvocationKHR() = default;
  ~NodeOpSubgroupFirstInvocationKHR() = default;
  NodeOpSubgroupFirstInvocationKHR(const NodeOpSubgroupFirstInvocationKHR &) = delete;
  NodeOpSubgroupFirstInvocationKHR &operator=(const NodeOpSubgroupFirstInvocationKHR &) = delete;
  NodeOpSubgroupFirstInvocationKHR(NodeOpSubgroupFirstInvocationKHR &&) = delete;
  NodeOpSubgroupFirstInvocationKHR &operator=(NodeOpSubgroupFirstInvocationKHR &&) = delete;
  NodeOpSubgroupFirstInvocationKHR(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->value = value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTranspose
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpTranspose;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> matrix;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(matrix);
  }
  NodeOpTranspose() = default;
  ~NodeOpTranspose() = default;
  NodeOpTranspose(const NodeOpTranspose &) = delete;
  NodeOpTranspose &operator=(const NodeOpTranspose &) = delete;
  NodeOpTranspose(NodeOpTranspose &&) = delete;
  NodeOpTranspose &operator=(NodeOpTranspose &&) = delete;
  NodeOpTranspose(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> matrix)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->matrix = matrix;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUConvert
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpUConvert;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> unsignedValue;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(unsignedValue);
  }
  NodeOpUConvert() = default;
  ~NodeOpUConvert() = default;
  NodeOpUConvert(const NodeOpUConvert &) = delete;
  NodeOpUConvert &operator=(const NodeOpUConvert &) = delete;
  NodeOpUConvert(NodeOpUConvert &&) = delete;
  NodeOpUConvert &operator=(NodeOpUConvert &&) = delete;
  NodeOpUConvert(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> unsigned_value)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->unsignedValue = unsigned_value;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUCountLeadingZerosINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpUCountLeadingZerosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpUCountLeadingZerosINTEL() = default;
  ~NodeOpUCountLeadingZerosINTEL() = default;
  NodeOpUCountLeadingZerosINTEL(const NodeOpUCountLeadingZerosINTEL &) = delete;
  NodeOpUCountLeadingZerosINTEL &operator=(const NodeOpUCountLeadingZerosINTEL &) = delete;
  NodeOpUCountLeadingZerosINTEL(NodeOpUCountLeadingZerosINTEL &&) = delete;
  NodeOpUCountLeadingZerosINTEL &operator=(NodeOpUCountLeadingZerosINTEL &&) = delete;
  NodeOpUCountLeadingZerosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpUCountTrailingZerosINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpUCountTrailingZerosINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> operand;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(operand);
  }
  NodeOpUCountTrailingZerosINTEL() = default;
  ~NodeOpUCountTrailingZerosINTEL() = default;
  NodeOpUCountTrailingZerosINTEL(const NodeOpUCountTrailingZerosINTEL &) = delete;
  NodeOpUCountTrailingZerosINTEL &operator=(const NodeOpUCountTrailingZerosINTEL &) = delete;
  NodeOpUCountTrailingZerosINTEL(NodeOpUCountTrailingZerosINTEL &&) = delete;
  NodeOpUCountTrailingZerosINTEL &operator=(NodeOpUCountTrailingZerosINTEL &&) = delete;
  NodeOpUCountTrailingZerosINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> operand)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->operand = operand;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVariableLengthArrayINTEL
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpVariableLengthArrayINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> lenght;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(lenght);
  }
  NodeOpVariableLengthArrayINTEL() = default;
  ~NodeOpVariableLengthArrayINTEL() = default;
  NodeOpVariableLengthArrayINTEL(const NodeOpVariableLengthArrayINTEL &) = delete;
  NodeOpVariableLengthArrayINTEL &operator=(const NodeOpVariableLengthArrayINTEL &) = delete;
  NodeOpVariableLengthArrayINTEL(NodeOpVariableLengthArrayINTEL &&) = delete;
  NodeOpVariableLengthArrayINTEL &operator=(NodeOpVariableLengthArrayINTEL &&) = delete;
  NodeOpVariableLengthArrayINTEL(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> lenght)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->lenght = lenght;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackDouble2x32
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackDouble2x32;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackDouble2x32() = default;
  ~NodeOpGLSLstd450PackDouble2x32() = default;
  NodeOpGLSLstd450PackDouble2x32(const NodeOpGLSLstd450PackDouble2x32 &) = delete;
  NodeOpGLSLstd450PackDouble2x32 &operator=(const NodeOpGLSLstd450PackDouble2x32 &) = delete;
  NodeOpGLSLstd450PackDouble2x32(NodeOpGLSLstd450PackDouble2x32 &&) = delete;
  NodeOpGLSLstd450PackDouble2x32 &operator=(NodeOpGLSLstd450PackDouble2x32 &&) = delete;
  NodeOpGLSLstd450PackDouble2x32(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackHalf2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackHalf2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackHalf2x16() = default;
  ~NodeOpGLSLstd450PackHalf2x16() = default;
  NodeOpGLSLstd450PackHalf2x16(const NodeOpGLSLstd450PackHalf2x16 &) = delete;
  NodeOpGLSLstd450PackHalf2x16 &operator=(const NodeOpGLSLstd450PackHalf2x16 &) = delete;
  NodeOpGLSLstd450PackHalf2x16(NodeOpGLSLstd450PackHalf2x16 &&) = delete;
  NodeOpGLSLstd450PackHalf2x16 &operator=(NodeOpGLSLstd450PackHalf2x16 &&) = delete;
  NodeOpGLSLstd450PackHalf2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackSnorm2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackSnorm2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackSnorm2x16() = default;
  ~NodeOpGLSLstd450PackSnorm2x16() = default;
  NodeOpGLSLstd450PackSnorm2x16(const NodeOpGLSLstd450PackSnorm2x16 &) = delete;
  NodeOpGLSLstd450PackSnorm2x16 &operator=(const NodeOpGLSLstd450PackSnorm2x16 &) = delete;
  NodeOpGLSLstd450PackSnorm2x16(NodeOpGLSLstd450PackSnorm2x16 &&) = delete;
  NodeOpGLSLstd450PackSnorm2x16 &operator=(NodeOpGLSLstd450PackSnorm2x16 &&) = delete;
  NodeOpGLSLstd450PackSnorm2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackSnorm4x8
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackSnorm4x8;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackSnorm4x8() = default;
  ~NodeOpGLSLstd450PackSnorm4x8() = default;
  NodeOpGLSLstd450PackSnorm4x8(const NodeOpGLSLstd450PackSnorm4x8 &) = delete;
  NodeOpGLSLstd450PackSnorm4x8 &operator=(const NodeOpGLSLstd450PackSnorm4x8 &) = delete;
  NodeOpGLSLstd450PackSnorm4x8(NodeOpGLSLstd450PackSnorm4x8 &&) = delete;
  NodeOpGLSLstd450PackSnorm4x8 &operator=(NodeOpGLSLstd450PackSnorm4x8 &&) = delete;
  NodeOpGLSLstd450PackSnorm4x8(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackUnorm2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackUnorm2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackUnorm2x16() = default;
  ~NodeOpGLSLstd450PackUnorm2x16() = default;
  NodeOpGLSLstd450PackUnorm2x16(const NodeOpGLSLstd450PackUnorm2x16 &) = delete;
  NodeOpGLSLstd450PackUnorm2x16 &operator=(const NodeOpGLSLstd450PackUnorm2x16 &) = delete;
  NodeOpGLSLstd450PackUnorm2x16(NodeOpGLSLstd450PackUnorm2x16 &&) = delete;
  NodeOpGLSLstd450PackUnorm2x16 &operator=(NodeOpGLSLstd450PackUnorm2x16 &&) = delete;
  NodeOpGLSLstd450PackUnorm2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450PackUnorm4x8
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::PackUnorm4x8;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450PackUnorm4x8() = default;
  ~NodeOpGLSLstd450PackUnorm4x8() = default;
  NodeOpGLSLstd450PackUnorm4x8(const NodeOpGLSLstd450PackUnorm4x8 &) = delete;
  NodeOpGLSLstd450PackUnorm4x8 &operator=(const NodeOpGLSLstd450PackUnorm4x8 &) = delete;
  NodeOpGLSLstd450PackUnorm4x8(NodeOpGLSLstd450PackUnorm4x8 &&) = delete;
  NodeOpGLSLstd450PackUnorm4x8 &operator=(NodeOpGLSLstd450PackUnorm4x8 &&) = delete;
  NodeOpGLSLstd450PackUnorm4x8(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Radians
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Radians;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> degrees;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(degrees);
  }
  NodeOpGLSLstd450Radians() = default;
  ~NodeOpGLSLstd450Radians() = default;
  NodeOpGLSLstd450Radians(const NodeOpGLSLstd450Radians &) = delete;
  NodeOpGLSLstd450Radians &operator=(const NodeOpGLSLstd450Radians &) = delete;
  NodeOpGLSLstd450Radians(NodeOpGLSLstd450Radians &&) = delete;
  NodeOpGLSLstd450Radians &operator=(NodeOpGLSLstd450Radians &&) = delete;
  NodeOpGLSLstd450Radians(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> degrees)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->degrees = degrees;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Round
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Round;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Round() = default;
  ~NodeOpGLSLstd450Round() = default;
  NodeOpGLSLstd450Round(const NodeOpGLSLstd450Round &) = delete;
  NodeOpGLSLstd450Round &operator=(const NodeOpGLSLstd450Round &) = delete;
  NodeOpGLSLstd450Round(NodeOpGLSLstd450Round &&) = delete;
  NodeOpGLSLstd450Round &operator=(NodeOpGLSLstd450Round &&) = delete;
  NodeOpGLSLstd450Round(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450RoundEven
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::RoundEven;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450RoundEven() = default;
  ~NodeOpGLSLstd450RoundEven() = default;
  NodeOpGLSLstd450RoundEven(const NodeOpGLSLstd450RoundEven &) = delete;
  NodeOpGLSLstd450RoundEven &operator=(const NodeOpGLSLstd450RoundEven &) = delete;
  NodeOpGLSLstd450RoundEven(NodeOpGLSLstd450RoundEven &&) = delete;
  NodeOpGLSLstd450RoundEven &operator=(NodeOpGLSLstd450RoundEven &&) = delete;
  NodeOpGLSLstd450RoundEven(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SAbs
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SAbs;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450SAbs() = default;
  ~NodeOpGLSLstd450SAbs() = default;
  NodeOpGLSLstd450SAbs(const NodeOpGLSLstd450SAbs &) = delete;
  NodeOpGLSLstd450SAbs &operator=(const NodeOpGLSLstd450SAbs &) = delete;
  NodeOpGLSLstd450SAbs(NodeOpGLSLstd450SAbs &&) = delete;
  NodeOpGLSLstd450SAbs &operator=(NodeOpGLSLstd450SAbs &&) = delete;
  NodeOpGLSLstd450SAbs(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450SSign
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::SSign;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450SSign() = default;
  ~NodeOpGLSLstd450SSign() = default;
  NodeOpGLSLstd450SSign(const NodeOpGLSLstd450SSign &) = delete;
  NodeOpGLSLstd450SSign &operator=(const NodeOpGLSLstd450SSign &) = delete;
  NodeOpGLSLstd450SSign(NodeOpGLSLstd450SSign &&) = delete;
  NodeOpGLSLstd450SSign &operator=(NodeOpGLSLstd450SSign &&) = delete;
  NodeOpGLSLstd450SSign(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Sin
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Sin;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Sin() = default;
  ~NodeOpGLSLstd450Sin() = default;
  NodeOpGLSLstd450Sin(const NodeOpGLSLstd450Sin &) = delete;
  NodeOpGLSLstd450Sin &operator=(const NodeOpGLSLstd450Sin &) = delete;
  NodeOpGLSLstd450Sin(NodeOpGLSLstd450Sin &&) = delete;
  NodeOpGLSLstd450Sin &operator=(NodeOpGLSLstd450Sin &&) = delete;
  NodeOpGLSLstd450Sin(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Sinh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Sinh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Sinh() = default;
  ~NodeOpGLSLstd450Sinh() = default;
  NodeOpGLSLstd450Sinh(const NodeOpGLSLstd450Sinh &) = delete;
  NodeOpGLSLstd450Sinh &operator=(const NodeOpGLSLstd450Sinh &) = delete;
  NodeOpGLSLstd450Sinh(NodeOpGLSLstd450Sinh &&) = delete;
  NodeOpGLSLstd450Sinh &operator=(NodeOpGLSLstd450Sinh &&) = delete;
  NodeOpGLSLstd450Sinh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Sqrt
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Sqrt;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Sqrt() = default;
  ~NodeOpGLSLstd450Sqrt() = default;
  NodeOpGLSLstd450Sqrt(const NodeOpGLSLstd450Sqrt &) = delete;
  NodeOpGLSLstd450Sqrt &operator=(const NodeOpGLSLstd450Sqrt &) = delete;
  NodeOpGLSLstd450Sqrt(NodeOpGLSLstd450Sqrt &&) = delete;
  NodeOpGLSLstd450Sqrt &operator=(NodeOpGLSLstd450Sqrt &&) = delete;
  NodeOpGLSLstd450Sqrt(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Tan
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Tan;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Tan() = default;
  ~NodeOpGLSLstd450Tan() = default;
  NodeOpGLSLstd450Tan(const NodeOpGLSLstd450Tan &) = delete;
  NodeOpGLSLstd450Tan &operator=(const NodeOpGLSLstd450Tan &) = delete;
  NodeOpGLSLstd450Tan(NodeOpGLSLstd450Tan &&) = delete;
  NodeOpGLSLstd450Tan &operator=(NodeOpGLSLstd450Tan &&) = delete;
  NodeOpGLSLstd450Tan(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Tanh
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Tanh;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Tanh() = default;
  ~NodeOpGLSLstd450Tanh() = default;
  NodeOpGLSLstd450Tanh(const NodeOpGLSLstd450Tanh &) = delete;
  NodeOpGLSLstd450Tanh &operator=(const NodeOpGLSLstd450Tanh &) = delete;
  NodeOpGLSLstd450Tanh(NodeOpGLSLstd450Tanh &&) = delete;
  NodeOpGLSLstd450Tanh &operator=(NodeOpGLSLstd450Tanh &&) = delete;
  NodeOpGLSLstd450Tanh(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450Trunc
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::Trunc;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> x;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(x);
  }
  NodeOpGLSLstd450Trunc() = default;
  ~NodeOpGLSLstd450Trunc() = default;
  NodeOpGLSLstd450Trunc(const NodeOpGLSLstd450Trunc &) = delete;
  NodeOpGLSLstd450Trunc &operator=(const NodeOpGLSLstd450Trunc &) = delete;
  NodeOpGLSLstd450Trunc(NodeOpGLSLstd450Trunc &&) = delete;
  NodeOpGLSLstd450Trunc &operator=(NodeOpGLSLstd450Trunc &&) = delete;
  NodeOpGLSLstd450Trunc(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> x)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->x = x;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackDouble2x32
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackDouble2x32;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450UnpackDouble2x32() = default;
  ~NodeOpGLSLstd450UnpackDouble2x32() = default;
  NodeOpGLSLstd450UnpackDouble2x32(const NodeOpGLSLstd450UnpackDouble2x32 &) = delete;
  NodeOpGLSLstd450UnpackDouble2x32 &operator=(const NodeOpGLSLstd450UnpackDouble2x32 &) = delete;
  NodeOpGLSLstd450UnpackDouble2x32(NodeOpGLSLstd450UnpackDouble2x32 &&) = delete;
  NodeOpGLSLstd450UnpackDouble2x32 &operator=(NodeOpGLSLstd450UnpackDouble2x32 &&) = delete;
  NodeOpGLSLstd450UnpackDouble2x32(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackHalf2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackHalf2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> v;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(v);
  }
  NodeOpGLSLstd450UnpackHalf2x16() = default;
  ~NodeOpGLSLstd450UnpackHalf2x16() = default;
  NodeOpGLSLstd450UnpackHalf2x16(const NodeOpGLSLstd450UnpackHalf2x16 &) = delete;
  NodeOpGLSLstd450UnpackHalf2x16 &operator=(const NodeOpGLSLstd450UnpackHalf2x16 &) = delete;
  NodeOpGLSLstd450UnpackHalf2x16(NodeOpGLSLstd450UnpackHalf2x16 &&) = delete;
  NodeOpGLSLstd450UnpackHalf2x16 &operator=(NodeOpGLSLstd450UnpackHalf2x16 &&) = delete;
  NodeOpGLSLstd450UnpackHalf2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> v)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->v = v;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackSnorm2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackSnorm2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpGLSLstd450UnpackSnorm2x16() = default;
  ~NodeOpGLSLstd450UnpackSnorm2x16() = default;
  NodeOpGLSLstd450UnpackSnorm2x16(const NodeOpGLSLstd450UnpackSnorm2x16 &) = delete;
  NodeOpGLSLstd450UnpackSnorm2x16 &operator=(const NodeOpGLSLstd450UnpackSnorm2x16 &) = delete;
  NodeOpGLSLstd450UnpackSnorm2x16(NodeOpGLSLstd450UnpackSnorm2x16 &&) = delete;
  NodeOpGLSLstd450UnpackSnorm2x16 &operator=(NodeOpGLSLstd450UnpackSnorm2x16 &&) = delete;
  NodeOpGLSLstd450UnpackSnorm2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackSnorm4x8
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackSnorm4x8;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpGLSLstd450UnpackSnorm4x8() = default;
  ~NodeOpGLSLstd450UnpackSnorm4x8() = default;
  NodeOpGLSLstd450UnpackSnorm4x8(const NodeOpGLSLstd450UnpackSnorm4x8 &) = delete;
  NodeOpGLSLstd450UnpackSnorm4x8 &operator=(const NodeOpGLSLstd450UnpackSnorm4x8 &) = delete;
  NodeOpGLSLstd450UnpackSnorm4x8(NodeOpGLSLstd450UnpackSnorm4x8 &&) = delete;
  NodeOpGLSLstd450UnpackSnorm4x8 &operator=(NodeOpGLSLstd450UnpackSnorm4x8 &&) = delete;
  NodeOpGLSLstd450UnpackSnorm4x8(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackUnorm2x16
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackUnorm2x16;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpGLSLstd450UnpackUnorm2x16() = default;
  ~NodeOpGLSLstd450UnpackUnorm2x16() = default;
  NodeOpGLSLstd450UnpackUnorm2x16(const NodeOpGLSLstd450UnpackUnorm2x16 &) = delete;
  NodeOpGLSLstd450UnpackUnorm2x16 &operator=(const NodeOpGLSLstd450UnpackUnorm2x16 &) = delete;
  NodeOpGLSLstd450UnpackUnorm2x16(NodeOpGLSLstd450UnpackUnorm2x16 &&) = delete;
  NodeOpGLSLstd450UnpackUnorm2x16 &operator=(NodeOpGLSLstd450UnpackUnorm2x16 &&) = delete;
  NodeOpGLSLstd450UnpackUnorm2x16(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpGLSLstd450UnpackUnorm4x8
{
  const NodeKind nodeKind = NodeKind::UnaryOperation;
  const Op opCode = Op::OpExtInst;
  const GLSLstd450 extOpCode = GLSLstd450::UnpackUnorm4x8;
  const ExtendedGrammar grammarId = ExtendedGrammar::GLSL_std_450;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> p;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(p);
  }
  NodeOpGLSLstd450UnpackUnorm4x8() = default;
  ~NodeOpGLSLstd450UnpackUnorm4x8() = default;
  NodeOpGLSLstd450UnpackUnorm4x8(const NodeOpGLSLstd450UnpackUnorm4x8 &) = delete;
  NodeOpGLSLstd450UnpackUnorm4x8 &operator=(const NodeOpGLSLstd450UnpackUnorm4x8 &) = delete;
  NodeOpGLSLstd450UnpackUnorm4x8(NodeOpGLSLstd450UnpackUnorm4x8 &&) = delete;
  NodeOpGLSLstd450UnpackUnorm4x8 &operator=(NodeOpGLSLstd450UnpackUnorm4x8 &&) = delete;
  NodeOpGLSLstd450UnpackUnorm4x8(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> p)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->p = p;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeUnaryOperation::visit(NodeUnaryOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::UnaryOperation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAll:
        if (visitor(reinterpret_cast<NodeOpAll *>(node)))
          return true;
        break;
      case Op::OpAny:
        if (visitor(reinterpret_cast<NodeOpAny *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatACosINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatACosINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatACosPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatACosPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatASinINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatASinINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatASinPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatASinPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatATan2INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatATan2INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatATanINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatATanINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatATanPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatATanPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatAddINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatAddINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCastFromIntINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCastFromIntINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCastINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCastINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCastToIntINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCastToIntINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCbrtINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCbrtINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCosINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCosINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatCosPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatCosPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatDivINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatDivINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatEQINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatEQINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatExp10INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatExp10INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatExp2INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatExp2INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatExpINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatExpINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatExpm1INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatExpm1INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatGEINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatGEINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatGTINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatGTINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatHypotINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatHypotINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLEINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLEINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLTINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLTINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLog10INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLog10INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLog1pINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLog1pINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLog2INTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLog2INTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatLogINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatLogINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatMulINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatMulINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatPowINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatPowINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatPowNINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatPowNINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatPowRINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatPowRINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatRSqrtINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatRSqrtINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatRecipINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatRecipINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSinCosINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSinCosINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSinCosPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSinCosPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSinINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSinINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSinPiINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSinPiINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSqrtINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSqrtINTEL *>(node)))
          return true;
        break;
      case Op::OpArbitraryFloatSubINTEL:
        if (visitor(reinterpret_cast<NodeOpArbitraryFloatSubINTEL *>(node)))
          return true;
        break;
      case Op::OpArrayLength:
        if (visitor(reinterpret_cast<NodeOpArrayLength *>(node)))
          return true;
        break;
      case Op::OpAsmCallINTEL:
        if (visitor(reinterpret_cast<NodeOpAsmCallINTEL *>(node)))
          return true;
        break;
      case Op::OpAtomicAnd:
        if (visitor(reinterpret_cast<NodeOpAtomicAnd *>(node)))
          return true;
        break;
      case Op::OpAtomicCompareExchange:
        if (visitor(reinterpret_cast<NodeOpAtomicCompareExchange *>(node)))
          return true;
        break;
      case Op::OpAtomicCompareExchangeWeak:
        if (visitor(reinterpret_cast<NodeOpAtomicCompareExchangeWeak *>(node)))
          return true;
        break;
      case Op::OpAtomicExchange:
        if (visitor(reinterpret_cast<NodeOpAtomicExchange *>(node)))
          return true;
        break;
      case Op::OpAtomicFAddEXT:
        if (visitor(reinterpret_cast<NodeOpAtomicFAddEXT *>(node)))
          return true;
        break;
      case Op::OpAtomicFMaxEXT:
        if (visitor(reinterpret_cast<NodeOpAtomicFMaxEXT *>(node)))
          return true;
        break;
      case Op::OpAtomicFMinEXT:
        if (visitor(reinterpret_cast<NodeOpAtomicFMinEXT *>(node)))
          return true;
        break;
      case Op::OpAtomicFlagTestAndSet:
        if (visitor(reinterpret_cast<NodeOpAtomicFlagTestAndSet *>(node)))
          return true;
        break;
      case Op::OpAtomicIAdd:
        if (visitor(reinterpret_cast<NodeOpAtomicIAdd *>(node)))
          return true;
        break;
      case Op::OpAtomicIDecrement:
        if (visitor(reinterpret_cast<NodeOpAtomicIDecrement *>(node)))
          return true;
        break;
      case Op::OpAtomicIIncrement:
        if (visitor(reinterpret_cast<NodeOpAtomicIIncrement *>(node)))
          return true;
        break;
      case Op::OpAtomicISub:
        if (visitor(reinterpret_cast<NodeOpAtomicISub *>(node)))
          return true;
        break;
      case Op::OpAtomicLoad:
        if (visitor(reinterpret_cast<NodeOpAtomicLoad *>(node)))
          return true;
        break;
      case Op::OpAtomicOr:
        if (visitor(reinterpret_cast<NodeOpAtomicOr *>(node)))
          return true;
        break;
      case Op::OpAtomicSMax:
        if (visitor(reinterpret_cast<NodeOpAtomicSMax *>(node)))
          return true;
        break;
      case Op::OpAtomicSMin:
        if (visitor(reinterpret_cast<NodeOpAtomicSMin *>(node)))
          return true;
        break;
      case Op::OpAtomicUMax:
        if (visitor(reinterpret_cast<NodeOpAtomicUMax *>(node)))
          return true;
        break;
      case Op::OpAtomicUMin:
        if (visitor(reinterpret_cast<NodeOpAtomicUMin *>(node)))
          return true;
        break;
      case Op::OpAtomicXor:
        if (visitor(reinterpret_cast<NodeOpAtomicXor *>(node)))
          return true;
        break;
      case Op::OpBitCount:
        if (visitor(reinterpret_cast<NodeOpBitCount *>(node)))
          return true;
        break;
      case Op::OpBitReverse:
        if (visitor(reinterpret_cast<NodeOpBitReverse *>(node)))
          return true;
        break;
      case Op::OpBitcast:
        if (visitor(reinterpret_cast<NodeOpBitcast *>(node)))
          return true;
        break;
      case Op::OpColorAttachmentReadEXT:
        if (visitor(reinterpret_cast<NodeOpColorAttachmentReadEXT *>(node)))
          return true;
        break;
      case Op::OpCompositeConstructReplicateEXT:
        if (visitor(reinterpret_cast<NodeOpCompositeConstructReplicateEXT *>(node)))
          return true;
        break;
      case Op::OpCompositeExtract:
        if (visitor(reinterpret_cast<NodeOpCompositeExtract *>(node)))
          return true;
        break;
      case Op::OpConvertBF16ToFINTEL:
        if (visitor(reinterpret_cast<NodeOpConvertBF16ToFINTEL *>(node)))
          return true;
        break;
      case Op::OpConvertFToBF16INTEL:
        if (visitor(reinterpret_cast<NodeOpConvertFToBF16INTEL *>(node)))
          return true;
        break;
      case Op::OpConvertFToS:
        if (visitor(reinterpret_cast<NodeOpConvertFToS *>(node)))
          return true;
        break;
      case Op::OpConvertFToU:
        if (visitor(reinterpret_cast<NodeOpConvertFToU *>(node)))
          return true;
        break;
      case Op::OpConvertImageToUNV:
        if (visitor(reinterpret_cast<NodeOpConvertImageToUNV *>(node)))
          return true;
        break;
      case Op::OpConvertPtrToU:
        if (visitor(reinterpret_cast<NodeOpConvertPtrToU *>(node)))
          return true;
        break;
      case Op::OpConvertSToF:
        if (visitor(reinterpret_cast<NodeOpConvertSToF *>(node)))
          return true;
        break;
      case Op::OpConvertSampledImageToUNV:
        if (visitor(reinterpret_cast<NodeOpConvertSampledImageToUNV *>(node)))
          return true;
        break;
      case Op::OpConvertSamplerToUNV:
        if (visitor(reinterpret_cast<NodeOpConvertSamplerToUNV *>(node)))
          return true;
        break;
      case Op::OpConvertUToAccelerationStructureKHR:
        if (visitor(reinterpret_cast<NodeOpConvertUToAccelerationStructureKHR *>(node)))
          return true;
        break;
      case Op::OpConvertUToF:
        if (visitor(reinterpret_cast<NodeOpConvertUToF *>(node)))
          return true;
        break;
      case Op::OpConvertUToImageNV:
        if (visitor(reinterpret_cast<NodeOpConvertUToImageNV *>(node)))
          return true;
        break;
      case Op::OpConvertUToPtr:
        if (visitor(reinterpret_cast<NodeOpConvertUToPtr *>(node)))
          return true;
        break;
      case Op::OpConvertUToSampledImageNV:
        if (visitor(reinterpret_cast<NodeOpConvertUToSampledImageNV *>(node)))
          return true;
        break;
      case Op::OpConvertUToSamplerNV:
        if (visitor(reinterpret_cast<NodeOpConvertUToSamplerNV *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixLengthKHR:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixLengthKHR *>(node)))
          return true;
        break;
      case Op::OpCooperativeMatrixLengthNV:
        if (visitor(reinterpret_cast<NodeOpCooperativeMatrixLengthNV *>(node)))
          return true;
        break;
      case Op::OpCopyLogical:
        if (visitor(reinterpret_cast<NodeOpCopyLogical *>(node)))
          return true;
        break;
      case Op::OpCopyObject:
        if (visitor(reinterpret_cast<NodeOpCopyObject *>(node)))
          return true;
        break;
      case Op::OpCreatePipeFromPipeStorage:
        if (visitor(reinterpret_cast<NodeOpCreatePipeFromPipeStorage *>(node)))
          return true;
        break;
      case Op::OpCrossWorkgroupCastToPtrINTEL:
        if (visitor(reinterpret_cast<NodeOpCrossWorkgroupCastToPtrINTEL *>(node)))
          return true;
        break;
      case Op::OpDPdx:
        if (visitor(reinterpret_cast<NodeOpDPdx *>(node)))
          return true;
        break;
      case Op::OpDPdxCoarse:
        if (visitor(reinterpret_cast<NodeOpDPdxCoarse *>(node)))
          return true;
        break;
      case Op::OpDPdxFine:
        if (visitor(reinterpret_cast<NodeOpDPdxFine *>(node)))
          return true;
        break;
      case Op::OpDPdy:
        if (visitor(reinterpret_cast<NodeOpDPdy *>(node)))
          return true;
        break;
      case Op::OpDPdyCoarse:
        if (visitor(reinterpret_cast<NodeOpDPdyCoarse *>(node)))
          return true;
        break;
      case Op::OpDPdyFine:
        if (visitor(reinterpret_cast<NodeOpDPdyFine *>(node)))
          return true;
        break;
      case Op::OpExtInstWithForwardRefsKHR:
        if (visitor(reinterpret_cast<NodeOpExtInstWithForwardRefsKHR *>(node)))
          return true;
        break;
      case Op::OpFConvert:
        if (visitor(reinterpret_cast<NodeOpFConvert *>(node)))
          return true;
        break;
      case Op::OpFNegate:
        if (visitor(reinterpret_cast<NodeOpFNegate *>(node)))
          return true;
        break;
      case Op::OpFinishWritingNodePayloadAMDX:
        if (visitor(reinterpret_cast<NodeOpFinishWritingNodePayloadAMDX *>(node)))
          return true;
        break;
      case Op::OpFwidth:
        if (visitor(reinterpret_cast<NodeOpFwidth *>(node)))
          return true;
        break;
      case Op::OpFwidthCoarse:
        if (visitor(reinterpret_cast<NodeOpFwidthCoarse *>(node)))
          return true;
        break;
      case Op::OpFwidthFine:
        if (visitor(reinterpret_cast<NodeOpFwidthFine *>(node)))
          return true;
        break;
      case Op::OpGenericCastToPtr:
        if (visitor(reinterpret_cast<NodeOpGenericCastToPtr *>(node)))
          return true;
        break;
      case Op::OpGenericCastToPtrExplicit:
        if (visitor(reinterpret_cast<NodeOpGenericCastToPtrExplicit *>(node)))
          return true;
        break;
      case Op::OpGenericPtrMemSemantics:
        if (visitor(reinterpret_cast<NodeOpGenericPtrMemSemantics *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformPartitionNV:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformPartitionNV *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformQuadAllKHR:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformQuadAllKHR *>(node)))
          return true;
        break;
      case Op::OpGroupNonUniformQuadAnyKHR:
        if (visitor(reinterpret_cast<NodeOpGroupNonUniformQuadAnyKHR *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetCurrentTimeNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetCurrentTimeNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetGeometryIndexNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetGeometryIndexNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetHitKindNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetHitKindNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetInstanceCustomIndexNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetInstanceCustomIndexNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetInstanceIdNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetInstanceIdNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetObjectRayDirectionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetObjectRayDirectionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetObjectRayOriginNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetObjectRayOriginNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetObjectToWorldNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetObjectToWorldNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetPrimitiveIndexNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetPrimitiveIndexNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetRayTMaxNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetRayTMaxNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetRayTMinNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetRayTMinNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetShaderBindingTableRecordIndexNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetShaderBindingTableRecordIndexNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetShaderRecordBufferHandleNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetShaderRecordBufferHandleNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetWorldRayDirectionNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetWorldRayDirectionNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetWorldRayOriginNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetWorldRayOriginNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectGetWorldToObjectNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectGetWorldToObjectNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectIsEmptyNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectIsEmptyNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectIsHitNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectIsHitNV *>(node)))
          return true;
        break;
      case Op::OpHitObjectIsMissNV:
        if (visitor(reinterpret_cast<NodeOpHitObjectIsMissNV *>(node)))
          return true;
        break;
      case Op::OpImageSparseTexelsResident:
        if (visitor(reinterpret_cast<NodeOpImageSparseTexelsResident *>(node)))
          return true;
        break;
      case Op::OpIsFinite:
        if (visitor(reinterpret_cast<NodeOpIsFinite *>(node)))
          return true;
        break;
      case Op::OpIsInf:
        if (visitor(reinterpret_cast<NodeOpIsInf *>(node)))
          return true;
        break;
      case Op::OpIsNan:
        if (visitor(reinterpret_cast<NodeOpIsNan *>(node)))
          return true;
        break;
      case Op::OpIsNormal:
        if (visitor(reinterpret_cast<NodeOpIsNormal *>(node)))
          return true;
        break;
      case Op::OpIsValidEvent:
        if (visitor(reinterpret_cast<NodeOpIsValidEvent *>(node)))
          return true;
        break;
      case Op::OpIsValidReserveId:
        if (visitor(reinterpret_cast<NodeOpIsValidReserveId *>(node)))
          return true;
        break;
      case Op::OpLoad:
        if (visitor(reinterpret_cast<NodeOpLoad *>(node)))
          return true;
        break;
      case Op::OpLogicalNot:
        if (visitor(reinterpret_cast<NodeOpLogicalNot *>(node)))
          return true;
        break;
      case Op::OpMaskedGatherINTEL:
        if (visitor(reinterpret_cast<NodeOpMaskedGatherINTEL *>(node)))
          return true;
        break;
      case Op::OpNamedBarrierInitialize:
        if (visitor(reinterpret_cast<NodeOpNamedBarrierInitialize *>(node)))
          return true;
        break;
      case Op::OpNot:
        if (visitor(reinterpret_cast<NodeOpNot *>(node)))
          return true;
        break;
      case Op::OpPtrCastToCrossWorkgroupINTEL:
        if (visitor(reinterpret_cast<NodeOpPtrCastToCrossWorkgroupINTEL *>(node)))
          return true;
        break;
      case Op::OpPtrCastToGeneric:
        if (visitor(reinterpret_cast<NodeOpPtrCastToGeneric *>(node)))
          return true;
        break;
      case Op::OpQuantizeToF16:
        if (visitor(reinterpret_cast<NodeOpQuantizeToF16 *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetRayFlagsKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetRayFlagsKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetRayTMinKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetRayTMinKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetWorldRayDirectionKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetWorldRayDirectionKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryGetWorldRayOriginKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryGetWorldRayOriginKHR *>(node)))
          return true;
        break;
      case Op::OpRayQueryProceedKHR:
        if (visitor(reinterpret_cast<NodeOpRayQueryProceedKHR *>(node)))
          return true;
        break;
      case Op::OpSConvert:
        if (visitor(reinterpret_cast<NodeOpSConvert *>(node)))
          return true;
        break;
      case Op::OpSNegate:
        if (visitor(reinterpret_cast<NodeOpSNegate *>(node)))
          return true;
        break;
      case Op::OpSatConvertSToU:
        if (visitor(reinterpret_cast<NodeOpSatConvertSToU *>(node)))
          return true;
        break;
      case Op::OpSatConvertUToS:
        if (visitor(reinterpret_cast<NodeOpSatConvertUToS *>(node)))
          return true;
        break;
      case Op::OpSignBitSet:
        if (visitor(reinterpret_cast<NodeOpSignBitSet *>(node)))
          return true;
        break;
      case Op::OpSizeOf:
        if (visitor(reinterpret_cast<NodeOpSizeOf *>(node)))
          return true;
        break;
      case Op::OpSubgroupAllEqualKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupAllEqualKHR *>(node)))
          return true;
        break;
      case Op::OpSubgroupAllKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupAllKHR *>(node)))
          return true;
        break;
      case Op::OpSubgroupAnyKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupAnyKHR *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeConvertToMcePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeConvertToMcePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeConvertToMceResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeConvertToMceResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetDualReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetSingleReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeStripDualReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToImePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToImePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToImeResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToImeResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToRefPayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToRefPayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToRefResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToRefResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToSicPayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToSicPayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceConvertToSicResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceConvertToSicResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetBestInterDistortionsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterDirectionsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterDirectionsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterDistortionsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterDistortionsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterMajorShapeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterMajorShapeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterMinorShapeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterMinorShapeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterMotionVectorCountINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetInterReferenceIdsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetMotionVectorsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetMotionVectorsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceSetAcOnlyHaarINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefConvertToMcePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefConvertToMcePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefConvertToMceResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefConvertToMceResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefSetBidirectionalMixDisableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcRefSetBilinearFilterEnableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicConvertToMcePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicConvertToMcePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicConvertToMceResultINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicConvertToMceResultINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetInterRawSadsINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetInterRawSadsINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetIpeChromaModeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetIpeChromaModeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetIpeLumaShapeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetPackedIpeLumaModesINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicInitializeINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicInitializeINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcSicSetBilinearFilterEnableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupBallotKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupBallotKHR *>(node)))
          return true;
        break;
      case Op::OpSubgroupBlockReadINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupBlockReadINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupFirstInvocationKHR:
        if (visitor(reinterpret_cast<NodeOpSubgroupFirstInvocationKHR *>(node)))
          return true;
        break;
      case Op::OpTranspose:
        if (visitor(reinterpret_cast<NodeOpTranspose *>(node)))
          return true;
        break;
      case Op::OpUConvert:
        if (visitor(reinterpret_cast<NodeOpUConvert *>(node)))
          return true;
        break;
      case Op::OpUCountLeadingZerosINTEL:
        if (visitor(reinterpret_cast<NodeOpUCountLeadingZerosINTEL *>(node)))
          return true;
        break;
      case Op::OpUCountTrailingZerosINTEL:
        if (visitor(reinterpret_cast<NodeOpUCountTrailingZerosINTEL *>(node)))
          return true;
        break;
      case Op::OpVariableLengthArrayINTEL:
        if (visitor(reinterpret_cast<NodeOpVariableLengthArrayINTEL *>(node)))
          return true;
        break;
      case Op::OpExtInst:
        switch (node->grammarId)
        {
          default: break;
          case ExtendedGrammar::GLSL_std_450:
            switch (static_cast<GLSLstd450>(node->extOpCode))
            {
              default: break;
              case GLSLstd450::Acos:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Acos *>(node)))
                  return true;
                break;
              case GLSLstd450::Acosh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Acosh *>(node)))
                  return true;
                break;
              case GLSLstd450::Asin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Asin *>(node)))
                  return true;
                break;
              case GLSLstd450::Asinh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Asinh *>(node)))
                  return true;
                break;
              case GLSLstd450::Atan:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Atan *>(node)))
                  return true;
                break;
              case GLSLstd450::Atanh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Atanh *>(node)))
                  return true;
                break;
              case GLSLstd450::Ceil:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Ceil *>(node)))
                  return true;
                break;
              case GLSLstd450::Cos:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Cos *>(node)))
                  return true;
                break;
              case GLSLstd450::Cosh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Cosh *>(node)))
                  return true;
                break;
              case GLSLstd450::Degrees:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Degrees *>(node)))
                  return true;
                break;
              case GLSLstd450::Determinant:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Determinant *>(node)))
                  return true;
                break;
              case GLSLstd450::Exp:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Exp *>(node)))
                  return true;
                break;
              case GLSLstd450::Exp2:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Exp2 *>(node)))
                  return true;
                break;
              case GLSLstd450::FAbs:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FAbs *>(node)))
                  return true;
                break;
              case GLSLstd450::FSign:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FSign *>(node)))
                  return true;
                break;
              case GLSLstd450::FindILsb:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FindILsb *>(node)))
                  return true;
                break;
              case GLSLstd450::FindSMsb:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FindSMsb *>(node)))
                  return true;
                break;
              case GLSLstd450::FindUMsb:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FindUMsb *>(node)))
                  return true;
                break;
              case GLSLstd450::Floor:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Floor *>(node)))
                  return true;
                break;
              case GLSLstd450::Fract:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Fract *>(node)))
                  return true;
                break;
              case GLSLstd450::FrexpStruct:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450FrexpStruct *>(node)))
                  return true;
                break;
              case GLSLstd450::InterpolateAtCentroid:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450InterpolateAtCentroid *>(node)))
                  return true;
                break;
              case GLSLstd450::InverseSqrt:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450InverseSqrt *>(node)))
                  return true;
                break;
              case GLSLstd450::Length:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Length *>(node)))
                  return true;
                break;
              case GLSLstd450::Log:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Log *>(node)))
                  return true;
                break;
              case GLSLstd450::Log2:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Log2 *>(node)))
                  return true;
                break;
              case GLSLstd450::MatrixInverse:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450MatrixInverse *>(node)))
                  return true;
                break;
              case GLSLstd450::ModfStruct:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450ModfStruct *>(node)))
                  return true;
                break;
              case GLSLstd450::Normalize:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Normalize *>(node)))
                  return true;
                break;
              case GLSLstd450::PackDouble2x32:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackDouble2x32 *>(node)))
                  return true;
                break;
              case GLSLstd450::PackHalf2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackHalf2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::PackSnorm2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackSnorm2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::PackSnorm4x8:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackSnorm4x8 *>(node)))
                  return true;
                break;
              case GLSLstd450::PackUnorm2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackUnorm2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::PackUnorm4x8:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450PackUnorm4x8 *>(node)))
                  return true;
                break;
              case GLSLstd450::Radians:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Radians *>(node)))
                  return true;
                break;
              case GLSLstd450::Round:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Round *>(node)))
                  return true;
                break;
              case GLSLstd450::RoundEven:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450RoundEven *>(node)))
                  return true;
                break;
              case GLSLstd450::SAbs:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SAbs *>(node)))
                  return true;
                break;
              case GLSLstd450::SSign:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450SSign *>(node)))
                  return true;
                break;
              case GLSLstd450::Sin:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Sin *>(node)))
                  return true;
                break;
              case GLSLstd450::Sinh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Sinh *>(node)))
                  return true;
                break;
              case GLSLstd450::Sqrt:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Sqrt *>(node)))
                  return true;
                break;
              case GLSLstd450::Tan:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Tan *>(node)))
                  return true;
                break;
              case GLSLstd450::Tanh:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Tanh *>(node)))
                  return true;
                break;
              case GLSLstd450::Trunc:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450Trunc *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackDouble2x32:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackDouble2x32 *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackHalf2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackHalf2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackSnorm2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackSnorm2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackSnorm4x8:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackSnorm4x8 *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackUnorm2x16:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackUnorm2x16 *>(node)))
                  return true;
                break;
              case GLSLstd450::UnpackUnorm4x8:
                if (visitor(reinterpret_cast<NodeOpGLSLstd450UnpackUnorm4x8 *>(node)))
                  return true;
                break;
            }
            break;
          case ExtendedGrammar::AMD_gcn_shader:
            switch (static_cast<AMDGcnShader>(node->extOpCode))
            {
              default: break;
              case AMDGcnShader::CubeFaceCoordAMD:
                if (visitor(reinterpret_cast<NodeOpAMDGcnShaderCubeFaceCoord *>(node)))
                  return true;
                break;
              case AMDGcnShader::CubeFaceIndexAMD:
                if (visitor(reinterpret_cast<NodeOpAMDGcnShaderCubeFaceIndex *>(node)))
                  return true;
                break;
            }
            break;
          case ExtendedGrammar::AMD_shader_ballot: // only one instruction for this grammar
            if (static_cast<AMDShaderBallot>(node->extOpCode) == AMDShaderBallot::MbcntAMD)
            {
              if (visitor(reinterpret_cast<NodeOpAMDShaderBallotMbcnt *>(node)))
                return true;
            }
            break;
        }
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
struct NodeVariable : NodeOperation
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeVariable *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpAccessChain
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpAccessChain;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  eastl::vector<NodePointer<NodeId>> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    for (auto &&ref : indexes)
      visitor(ref);
  }
  NodeOpAccessChain() = default;
  ~NodeOpAccessChain() = default;
  NodeOpAccessChain(const NodeOpAccessChain &) = delete;
  NodeOpAccessChain &operator=(const NodeOpAccessChain &) = delete;
  NodeOpAccessChain(NodeOpAccessChain &&) = delete;
  NodeOpAccessChain &operator=(NodeOpAccessChain &&) = delete;
  NodeOpAccessChain(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base,
    NodePointer<NodeId> *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpFunctionParameter
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpFunctionParameter;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
  }
  NodeOpFunctionParameter() = default;
  ~NodeOpFunctionParameter() = default;
  NodeOpFunctionParameter(const NodeOpFunctionParameter &) = delete;
  NodeOpFunctionParameter &operator=(const NodeOpFunctionParameter &) = delete;
  NodeOpFunctionParameter(NodeOpFunctionParameter &&) = delete;
  NodeOpFunctionParameter &operator=(NodeOpFunctionParameter &&) = delete;
  NodeOpFunctionParameter(Id id_result, NodePointer<NodeTypedef> id_result_type)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpImageTexelPointer
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpImageTexelPointer;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> image;
  NodePointer<NodeId> coordinate;
  NodePointer<NodeId> sample;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(image);
    visitor(coordinate);
    visitor(sample);
  }
  NodeOpImageTexelPointer() = default;
  ~NodeOpImageTexelPointer() = default;
  NodeOpImageTexelPointer(const NodeOpImageTexelPointer &) = delete;
  NodeOpImageTexelPointer &operator=(const NodeOpImageTexelPointer &) = delete;
  NodeOpImageTexelPointer(NodeOpImageTexelPointer &&) = delete;
  NodeOpImageTexelPointer &operator=(NodeOpImageTexelPointer &&) = delete;
  NodeOpImageTexelPointer(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> image,
    NodePointer<NodeId> coordinate, NodePointer<NodeId> sample)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->image = image;
    this->coordinate = coordinate;
    this->sample = sample;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpInBoundsAccessChain
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpInBoundsAccessChain;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  eastl::vector<NodePointer<NodeId>> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    for (auto &&ref : indexes)
      visitor(ref);
  }
  NodeOpInBoundsAccessChain() = default;
  ~NodeOpInBoundsAccessChain() = default;
  NodeOpInBoundsAccessChain(const NodeOpInBoundsAccessChain &) = delete;
  NodeOpInBoundsAccessChain &operator=(const NodeOpInBoundsAccessChain &) = delete;
  NodeOpInBoundsAccessChain(NodeOpInBoundsAccessChain &&) = delete;
  NodeOpInBoundsAccessChain &operator=(NodeOpInBoundsAccessChain &&) = delete;
  NodeOpInBoundsAccessChain(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base,
    NodePointer<NodeId> *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpInBoundsPtrAccessChain
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpInBoundsPtrAccessChain;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> element;
  eastl::vector<NodePointer<NodeId>> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(element);
    for (auto &&ref : indexes)
      visitor(ref);
  }
  NodeOpInBoundsPtrAccessChain() = default;
  ~NodeOpInBoundsPtrAccessChain() = default;
  NodeOpInBoundsPtrAccessChain(const NodeOpInBoundsPtrAccessChain &) = delete;
  NodeOpInBoundsPtrAccessChain &operator=(const NodeOpInBoundsPtrAccessChain &) = delete;
  NodeOpInBoundsPtrAccessChain(NodeOpInBoundsPtrAccessChain &&) = delete;
  NodeOpInBoundsPtrAccessChain &operator=(NodeOpInBoundsPtrAccessChain &&) = delete;
  NodeOpInBoundsPtrAccessChain(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base,
    NodePointer<NodeId> element, NodePointer<NodeId> *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->element = element;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpPtrAccessChain
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpPtrAccessChain;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  NodePointer<NodeId> base;
  NodePointer<NodeId> element;
  eastl::vector<NodePointer<NodeId>> indexes;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    visitor(base);
    visitor(element);
    for (auto &&ref : indexes)
      visitor(ref);
  }
  NodeOpPtrAccessChain() = default;
  ~NodeOpPtrAccessChain() = default;
  NodeOpPtrAccessChain(const NodeOpPtrAccessChain &) = delete;
  NodeOpPtrAccessChain &operator=(const NodeOpPtrAccessChain &) = delete;
  NodeOpPtrAccessChain(NodeOpPtrAccessChain &&) = delete;
  NodeOpPtrAccessChain &operator=(NodeOpPtrAccessChain &&) = delete;
  NodeOpPtrAccessChain(Id id_result, NodePointer<NodeTypedef> id_result_type, NodePointer<NodeId> base, NodePointer<NodeId> element,
    NodePointer<NodeId> *indexes = nullptr, size_t indexes_count = 0)
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->base = base;
    this->element = element;
    this->indexes.assign(indexes, indexes + indexes_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpVariable
{
  const NodeKind nodeKind = NodeKind::Variable;
  const Op opCode = Op::OpVariable;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeTypedef> resultType;
  StorageClass storageClass;
  eastl::optional<NodePointer<NodeId>> initializer;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(resultType);
    if (initializer)
      visitor(*initializer);
  }
  NodeOpVariable() = default;
  ~NodeOpVariable() = default;
  NodeOpVariable(const NodeOpVariable &) = delete;
  NodeOpVariable &operator=(const NodeOpVariable &) = delete;
  NodeOpVariable(NodeOpVariable &&) = delete;
  NodeOpVariable &operator=(NodeOpVariable &&) = delete;
  NodeOpVariable(Id id_result, NodePointer<NodeTypedef> id_result_type, StorageClass storage_class,
    eastl::optional<NodePointer<NodeId>> initializer = {})
  {
    this->resultId = id_result;
    this->resultType = id_result_type;
    this->storageClass = storage_class;
    this->initializer = initializer;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeVariable::visit(NodeVariable *node, T visitor)
{
  if (node->nodeKind == NodeKind::Variable)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAccessChain:
        if (visitor(reinterpret_cast<NodeOpAccessChain *>(node)))
          return true;
        break;
      case Op::OpFunctionParameter:
        if (visitor(reinterpret_cast<NodeOpFunctionParameter *>(node)))
          return true;
        break;
      case Op::OpImageTexelPointer:
        if (visitor(reinterpret_cast<NodeOpImageTexelPointer *>(node)))
          return true;
        break;
      case Op::OpInBoundsAccessChain:
        if (visitor(reinterpret_cast<NodeOpInBoundsAccessChain *>(node)))
          return true;
        break;
      case Op::OpInBoundsPtrAccessChain:
        if (visitor(reinterpret_cast<NodeOpInBoundsPtrAccessChain *>(node)))
          return true;
        break;
      case Op::OpPtrAccessChain:
        if (visitor(reinterpret_cast<NodeOpPtrAccessChain *>(node)))
          return true;
        break;
      case Op::OpVariable:
        if (visitor(reinterpret_cast<NodeOpVariable *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
template <typename T>
inline bool NodeOperation::visit(NodeOperation *node, T visitor)
{
  if (node->nodeKind == NodeKind::Operation)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAsmTargetINTEL:
        if (visitor(reinterpret_cast<NodeOpAsmTargetINTEL *>(node)))
          return true;
        break;
      case Op::OpCompositeConstruct:
        if (visitor(reinterpret_cast<NodeOpCompositeConstruct *>(node)))
          return true;
        break;
      case Op::OpCompositeConstructContinuedINTEL:
        if (visitor(reinterpret_cast<NodeOpCompositeConstructContinuedINTEL *>(node)))
          return true;
        break;
      case Op::OpCreateUserEvent:
        if (visitor(reinterpret_cast<NodeOpCreateUserEvent *>(node)))
          return true;
        break;
      case Op::OpDepthAttachmentReadEXT:
        if (visitor(reinterpret_cast<NodeOpDepthAttachmentReadEXT *>(node)))
          return true;
        break;
      case Op::OpFunctionPointerCallINTEL:
        if (visitor(reinterpret_cast<NodeOpFunctionPointerCallINTEL *>(node)))
          return true;
        break;
      case Op::OpGetDefaultQueue:
        if (visitor(reinterpret_cast<NodeOpGetDefaultQueue *>(node)))
          return true;
        break;
      case Op::OpIsHelperInvocationEXT:
        if (visitor(reinterpret_cast<NodeOpIsHelperInvocationEXT *>(node)))
          return true;
        break;
      case Op::OpSaveMemoryINTEL:
        if (visitor(reinterpret_cast<NodeOpSaveMemoryINTEL *>(node)))
          return true;
        break;
      case Op::OpStencilAttachmentReadEXT:
        if (visitor(reinterpret_cast<NodeOpStencilAttachmentReadEXT *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL *>(node)))
          return true;
        break;
      case Op::OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL:
        if (visitor(reinterpret_cast<NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL *>(node)))
          return true;
        break;
      case Op::OpUndef:
        if (visitor(reinterpret_cast<NodeOpUndef *>(node)))
          return true;
        break;
      case Op::OpExtInst: // only one extended grammar is used here
        if (node->grammarId == ExtendedGrammar::AMD_gcn_shader)
        { // only one instruction for this grammar
          if (static_cast<AMDGcnShader>(node->extOpCode) == AMDGcnShader::TimeAMD)
          {
            if (visitor(reinterpret_cast<NodeOpAMDGcnShaderTime *>(node)))
              return true;
          }
        }
        break;
    }
  }
  else
  {
    if (NodeBinaryOperation::is(node))
    {
      if (NodeBinaryOperation::visit(reinterpret_cast<NodeBinaryOperation *>(node), visitor))
        return true;
    }
    else if (NodeConstant::is(node))
    {
      if (NodeConstant::visit(reinterpret_cast<NodeConstant *>(node), visitor))
        return true;
    }
    else if (NodeFunction::is(node))
    {
      if (NodeFunction::visit(reinterpret_cast<NodeFunction *>(node), visitor))
        return true;
    }
    else if (NodeFunctionCall::is(node))
    {
      if (NodeFunctionCall::visit(reinterpret_cast<NodeFunctionCall *>(node), visitor))
        return true;
    }
    else if (NodeImageOperation::is(node))
    {
      if (NodeImageOperation::visit(reinterpret_cast<NodeImageOperation *>(node), visitor))
        return true;
    }
    else if (NodeMultinaryOperation::is(node))
    {
      if (NodeMultinaryOperation::visit(reinterpret_cast<NodeMultinaryOperation *>(node), visitor))
        return true;
    }
    else if (NodePhi::is(node))
    {
      if (NodePhi::visit(reinterpret_cast<NodePhi *>(node), visitor))
        return true;
    }
    else if (NodeScopedOperation::is(node))
    {
      if (NodeScopedOperation::visit(reinterpret_cast<NodeScopedOperation *>(node), visitor))
        return true;
    }
    else if (NodeSpecConstant::is(node))
    {
      if (NodeSpecConstant::visit(reinterpret_cast<NodeSpecConstant *>(node), visitor))
        return true;
    }
    else if (NodeTrinaryOperation::is(node))
    {
      if (NodeTrinaryOperation::visit(reinterpret_cast<NodeTrinaryOperation *>(node), visitor))
        return true;
    }
    else if (NodeUnaryOperation::is(node))
    {
      if (NodeUnaryOperation::visit(reinterpret_cast<NodeUnaryOperation *>(node), visitor))
        return true;
    }
    else if (NodeVariable::is(node))
    {
      if (NodeVariable::visit(reinterpret_cast<NodeVariable *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
struct NodeTypedef : NodeId
{
  template <typename T>
  static constexpr bool is(const T *value);
  template <typename T>
  static bool visit(NodeTypedef *node, T visitor);
  template <typename T>
  void visitRefs(T)
  {}
};
struct NodeOpTypeAccelerationStructureKHR
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAccelerationStructureKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAccelerationStructureKHR() = default;
  ~NodeOpTypeAccelerationStructureKHR() = default;
  NodeOpTypeAccelerationStructureKHR(const NodeOpTypeAccelerationStructureKHR &) = delete;
  NodeOpTypeAccelerationStructureKHR &operator=(const NodeOpTypeAccelerationStructureKHR &) = delete;
  NodeOpTypeAccelerationStructureKHR(NodeOpTypeAccelerationStructureKHR &&) = delete;
  NodeOpTypeAccelerationStructureKHR &operator=(NodeOpTypeAccelerationStructureKHR &&) = delete;
  NodeOpTypeAccelerationStructureKHR(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAccelerationStructureNV
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAccelerationStructureNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAccelerationStructureNV() = default;
  ~NodeOpTypeAccelerationStructureNV() = default;
  NodeOpTypeAccelerationStructureNV(const NodeOpTypeAccelerationStructureNV &) = delete;
  NodeOpTypeAccelerationStructureNV &operator=(const NodeOpTypeAccelerationStructureNV &) = delete;
  NodeOpTypeAccelerationStructureNV(NodeOpTypeAccelerationStructureNV &&) = delete;
  NodeOpTypeAccelerationStructureNV &operator=(NodeOpTypeAccelerationStructureNV &&) = delete;
  NodeOpTypeAccelerationStructureNV(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeArray
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeArray;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> elementType;
  NodePointer<NodeId> length;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(elementType);
    visitor(length);
  }
  NodeOpTypeArray() = default;
  ~NodeOpTypeArray() = default;
  NodeOpTypeArray(const NodeOpTypeArray &) = delete;
  NodeOpTypeArray &operator=(const NodeOpTypeArray &) = delete;
  NodeOpTypeArray(NodeOpTypeArray &&) = delete;
  NodeOpTypeArray &operator=(NodeOpTypeArray &&) = delete;
  NodeOpTypeArray(Id id_result, NodePointer<NodeId> element_type, NodePointer<NodeId> length)
  {
    this->resultId = id_result;
    this->elementType = element_type;
    this->length = length;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImeDualReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImeDualReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImeDualReferenceStreaminINTEL() = default;
  ~NodeOpTypeAvcImeDualReferenceStreaminINTEL() = default;
  NodeOpTypeAvcImeDualReferenceStreaminINTEL(const NodeOpTypeAvcImeDualReferenceStreaminINTEL &) = delete;
  NodeOpTypeAvcImeDualReferenceStreaminINTEL &operator=(const NodeOpTypeAvcImeDualReferenceStreaminINTEL &) = delete;
  NodeOpTypeAvcImeDualReferenceStreaminINTEL(NodeOpTypeAvcImeDualReferenceStreaminINTEL &&) = delete;
  NodeOpTypeAvcImeDualReferenceStreaminINTEL &operator=(NodeOpTypeAvcImeDualReferenceStreaminINTEL &&) = delete;
  NodeOpTypeAvcImeDualReferenceStreaminINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImePayloadINTEL() = default;
  ~NodeOpTypeAvcImePayloadINTEL() = default;
  NodeOpTypeAvcImePayloadINTEL(const NodeOpTypeAvcImePayloadINTEL &) = delete;
  NodeOpTypeAvcImePayloadINTEL &operator=(const NodeOpTypeAvcImePayloadINTEL &) = delete;
  NodeOpTypeAvcImePayloadINTEL(NodeOpTypeAvcImePayloadINTEL &&) = delete;
  NodeOpTypeAvcImePayloadINTEL &operator=(NodeOpTypeAvcImePayloadINTEL &&) = delete;
  NodeOpTypeAvcImePayloadINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImeResultDualReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL() = default;
  ~NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL() = default;
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL(const NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &) = delete;
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &operator=(const NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &) = delete;
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL(NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &&) = delete;
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &operator=(NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL &&) = delete;
  NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImeResultINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImeResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImeResultINTEL() = default;
  ~NodeOpTypeAvcImeResultINTEL() = default;
  NodeOpTypeAvcImeResultINTEL(const NodeOpTypeAvcImeResultINTEL &) = delete;
  NodeOpTypeAvcImeResultINTEL &operator=(const NodeOpTypeAvcImeResultINTEL &) = delete;
  NodeOpTypeAvcImeResultINTEL(NodeOpTypeAvcImeResultINTEL &&) = delete;
  NodeOpTypeAvcImeResultINTEL &operator=(NodeOpTypeAvcImeResultINTEL &&) = delete;
  NodeOpTypeAvcImeResultINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImeResultSingleReferenceStreamoutINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL() = default;
  ~NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL() = default;
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL(const NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &) = delete;
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &operator=(const NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &) = delete;
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL(NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &operator=(NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL &&) = delete;
  NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcImeSingleReferenceStreaminINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcImeSingleReferenceStreaminINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL() = default;
  ~NodeOpTypeAvcImeSingleReferenceStreaminINTEL() = default;
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL(const NodeOpTypeAvcImeSingleReferenceStreaminINTEL &) = delete;
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL &operator=(const NodeOpTypeAvcImeSingleReferenceStreaminINTEL &) = delete;
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL(NodeOpTypeAvcImeSingleReferenceStreaminINTEL &&) = delete;
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL &operator=(NodeOpTypeAvcImeSingleReferenceStreaminINTEL &&) = delete;
  NodeOpTypeAvcImeSingleReferenceStreaminINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcMcePayloadINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcMcePayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcMcePayloadINTEL() = default;
  ~NodeOpTypeAvcMcePayloadINTEL() = default;
  NodeOpTypeAvcMcePayloadINTEL(const NodeOpTypeAvcMcePayloadINTEL &) = delete;
  NodeOpTypeAvcMcePayloadINTEL &operator=(const NodeOpTypeAvcMcePayloadINTEL &) = delete;
  NodeOpTypeAvcMcePayloadINTEL(NodeOpTypeAvcMcePayloadINTEL &&) = delete;
  NodeOpTypeAvcMcePayloadINTEL &operator=(NodeOpTypeAvcMcePayloadINTEL &&) = delete;
  NodeOpTypeAvcMcePayloadINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcMceResultINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcMceResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcMceResultINTEL() = default;
  ~NodeOpTypeAvcMceResultINTEL() = default;
  NodeOpTypeAvcMceResultINTEL(const NodeOpTypeAvcMceResultINTEL &) = delete;
  NodeOpTypeAvcMceResultINTEL &operator=(const NodeOpTypeAvcMceResultINTEL &) = delete;
  NodeOpTypeAvcMceResultINTEL(NodeOpTypeAvcMceResultINTEL &&) = delete;
  NodeOpTypeAvcMceResultINTEL &operator=(NodeOpTypeAvcMceResultINTEL &&) = delete;
  NodeOpTypeAvcMceResultINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcRefPayloadINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcRefPayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcRefPayloadINTEL() = default;
  ~NodeOpTypeAvcRefPayloadINTEL() = default;
  NodeOpTypeAvcRefPayloadINTEL(const NodeOpTypeAvcRefPayloadINTEL &) = delete;
  NodeOpTypeAvcRefPayloadINTEL &operator=(const NodeOpTypeAvcRefPayloadINTEL &) = delete;
  NodeOpTypeAvcRefPayloadINTEL(NodeOpTypeAvcRefPayloadINTEL &&) = delete;
  NodeOpTypeAvcRefPayloadINTEL &operator=(NodeOpTypeAvcRefPayloadINTEL &&) = delete;
  NodeOpTypeAvcRefPayloadINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcRefResultINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcRefResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcRefResultINTEL() = default;
  ~NodeOpTypeAvcRefResultINTEL() = default;
  NodeOpTypeAvcRefResultINTEL(const NodeOpTypeAvcRefResultINTEL &) = delete;
  NodeOpTypeAvcRefResultINTEL &operator=(const NodeOpTypeAvcRefResultINTEL &) = delete;
  NodeOpTypeAvcRefResultINTEL(NodeOpTypeAvcRefResultINTEL &&) = delete;
  NodeOpTypeAvcRefResultINTEL &operator=(NodeOpTypeAvcRefResultINTEL &&) = delete;
  NodeOpTypeAvcRefResultINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcSicPayloadINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcSicPayloadINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcSicPayloadINTEL() = default;
  ~NodeOpTypeAvcSicPayloadINTEL() = default;
  NodeOpTypeAvcSicPayloadINTEL(const NodeOpTypeAvcSicPayloadINTEL &) = delete;
  NodeOpTypeAvcSicPayloadINTEL &operator=(const NodeOpTypeAvcSicPayloadINTEL &) = delete;
  NodeOpTypeAvcSicPayloadINTEL(NodeOpTypeAvcSicPayloadINTEL &&) = delete;
  NodeOpTypeAvcSicPayloadINTEL &operator=(NodeOpTypeAvcSicPayloadINTEL &&) = delete;
  NodeOpTypeAvcSicPayloadINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeAvcSicResultINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeAvcSicResultINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeAvcSicResultINTEL() = default;
  ~NodeOpTypeAvcSicResultINTEL() = default;
  NodeOpTypeAvcSicResultINTEL(const NodeOpTypeAvcSicResultINTEL &) = delete;
  NodeOpTypeAvcSicResultINTEL &operator=(const NodeOpTypeAvcSicResultINTEL &) = delete;
  NodeOpTypeAvcSicResultINTEL(NodeOpTypeAvcSicResultINTEL &&) = delete;
  NodeOpTypeAvcSicResultINTEL &operator=(NodeOpTypeAvcSicResultINTEL &&) = delete;
  NodeOpTypeAvcSicResultINTEL(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeBool
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeBool;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeBool() = default;
  ~NodeOpTypeBool() = default;
  NodeOpTypeBool(const NodeOpTypeBool &) = delete;
  NodeOpTypeBool &operator=(const NodeOpTypeBool &) = delete;
  NodeOpTypeBool(NodeOpTypeBool &&) = delete;
  NodeOpTypeBool &operator=(NodeOpTypeBool &&) = delete;
  NodeOpTypeBool(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeBufferSurfaceINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeBufferSurfaceINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  AccessQualifier accessQualifier;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeBufferSurfaceINTEL() = default;
  ~NodeOpTypeBufferSurfaceINTEL() = default;
  NodeOpTypeBufferSurfaceINTEL(const NodeOpTypeBufferSurfaceINTEL &) = delete;
  NodeOpTypeBufferSurfaceINTEL &operator=(const NodeOpTypeBufferSurfaceINTEL &) = delete;
  NodeOpTypeBufferSurfaceINTEL(NodeOpTypeBufferSurfaceINTEL &&) = delete;
  NodeOpTypeBufferSurfaceINTEL &operator=(NodeOpTypeBufferSurfaceINTEL &&) = delete;
  NodeOpTypeBufferSurfaceINTEL(Id id_result, AccessQualifier access_qualifier)
  {
    this->resultId = id_result;
    this->accessQualifier = access_qualifier;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeCooperativeMatrixKHR
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeCooperativeMatrixKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> componentType;
  NodePointer<NodeOperation> scope;
  NodePointer<NodeId> rows;
  NodePointer<NodeId> columns;
  NodePointer<NodeId> use;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(componentType);
    visitor(scope);
    visitor(rows);
    visitor(columns);
    visitor(use);
  }
  NodeOpTypeCooperativeMatrixKHR() = default;
  ~NodeOpTypeCooperativeMatrixKHR() = default;
  NodeOpTypeCooperativeMatrixKHR(const NodeOpTypeCooperativeMatrixKHR &) = delete;
  NodeOpTypeCooperativeMatrixKHR &operator=(const NodeOpTypeCooperativeMatrixKHR &) = delete;
  NodeOpTypeCooperativeMatrixKHR(NodeOpTypeCooperativeMatrixKHR &&) = delete;
  NodeOpTypeCooperativeMatrixKHR &operator=(NodeOpTypeCooperativeMatrixKHR &&) = delete;
  NodeOpTypeCooperativeMatrixKHR(Id id_result, NodePointer<NodeId> component_type, NodePointer<NodeOperation> scope,
    NodePointer<NodeId> rows, NodePointer<NodeId> columns, NodePointer<NodeId> use)
  {
    this->resultId = id_result;
    this->componentType = component_type;
    this->scope = scope;
    this->rows = rows;
    this->columns = columns;
    this->use = use;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeCooperativeMatrixNV
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeCooperativeMatrixNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> componentType;
  NodePointer<NodeOperation> execution;
  NodePointer<NodeId> rows;
  NodePointer<NodeId> columns;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(componentType);
    visitor(execution);
    visitor(rows);
    visitor(columns);
  }
  NodeOpTypeCooperativeMatrixNV() = default;
  ~NodeOpTypeCooperativeMatrixNV() = default;
  NodeOpTypeCooperativeMatrixNV(const NodeOpTypeCooperativeMatrixNV &) = delete;
  NodeOpTypeCooperativeMatrixNV &operator=(const NodeOpTypeCooperativeMatrixNV &) = delete;
  NodeOpTypeCooperativeMatrixNV(NodeOpTypeCooperativeMatrixNV &&) = delete;
  NodeOpTypeCooperativeMatrixNV &operator=(NodeOpTypeCooperativeMatrixNV &&) = delete;
  NodeOpTypeCooperativeMatrixNV(Id id_result, NodePointer<NodeId> component_type, NodePointer<NodeOperation> execution,
    NodePointer<NodeId> rows, NodePointer<NodeId> columns)
  {
    this->resultId = id_result;
    this->componentType = component_type;
    this->execution = execution;
    this->rows = rows;
    this->columns = columns;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeDeviceEvent
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeDeviceEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeDeviceEvent() = default;
  ~NodeOpTypeDeviceEvent() = default;
  NodeOpTypeDeviceEvent(const NodeOpTypeDeviceEvent &) = delete;
  NodeOpTypeDeviceEvent &operator=(const NodeOpTypeDeviceEvent &) = delete;
  NodeOpTypeDeviceEvent(NodeOpTypeDeviceEvent &&) = delete;
  NodeOpTypeDeviceEvent &operator=(NodeOpTypeDeviceEvent &&) = delete;
  NodeOpTypeDeviceEvent(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeEvent
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeEvent;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeEvent() = default;
  ~NodeOpTypeEvent() = default;
  NodeOpTypeEvent(const NodeOpTypeEvent &) = delete;
  NodeOpTypeEvent &operator=(const NodeOpTypeEvent &) = delete;
  NodeOpTypeEvent(NodeOpTypeEvent &&) = delete;
  NodeOpTypeEvent &operator=(NodeOpTypeEvent &&) = delete;
  NodeOpTypeEvent(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeFloat
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeFloat;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  LiteralInteger width;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeFloat() = default;
  ~NodeOpTypeFloat() = default;
  NodeOpTypeFloat(const NodeOpTypeFloat &) = delete;
  NodeOpTypeFloat &operator=(const NodeOpTypeFloat &) = delete;
  NodeOpTypeFloat(NodeOpTypeFloat &&) = delete;
  NodeOpTypeFloat &operator=(NodeOpTypeFloat &&) = delete;
  NodeOpTypeFloat(Id id_result, LiteralInteger width)
  {
    this->resultId = id_result;
    this->width = width;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeFunction
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeFunction;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> returnType;
  eastl::vector<NodePointer<NodeId>> param2;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(returnType);
    for (auto &&ref : param2)
      visitor(ref);
  }
  NodeOpTypeFunction() = default;
  ~NodeOpTypeFunction() = default;
  NodeOpTypeFunction(const NodeOpTypeFunction &) = delete;
  NodeOpTypeFunction &operator=(const NodeOpTypeFunction &) = delete;
  NodeOpTypeFunction(NodeOpTypeFunction &&) = delete;
  NodeOpTypeFunction &operator=(NodeOpTypeFunction &&) = delete;
  NodeOpTypeFunction(Id id_result, NodePointer<NodeId> return_type, NodePointer<NodeId> *param_2 = nullptr, size_t param_2_count = 0)
  {
    this->resultId = id_result;
    this->returnType = return_type;
    this->param2.assign(param_2, param_2 + param_2_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeHitObjectNV
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeHitObjectNV;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeHitObjectNV() = default;
  ~NodeOpTypeHitObjectNV() = default;
  NodeOpTypeHitObjectNV(const NodeOpTypeHitObjectNV &) = delete;
  NodeOpTypeHitObjectNV &operator=(const NodeOpTypeHitObjectNV &) = delete;
  NodeOpTypeHitObjectNV(NodeOpTypeHitObjectNV &&) = delete;
  NodeOpTypeHitObjectNV &operator=(NodeOpTypeHitObjectNV &&) = delete;
  NodeOpTypeHitObjectNV(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeImage
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeImage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> sampledType;
  Dim dim;
  LiteralInteger depth;
  LiteralInteger arrayed;
  LiteralInteger mS;
  LiteralInteger sampled;
  ImageFormat imageFormat;
  eastl::optional<AccessQualifier> accessQualifier;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(sampledType);
  }
  NodeOpTypeImage() = default;
  ~NodeOpTypeImage() = default;
  NodeOpTypeImage(const NodeOpTypeImage &) = delete;
  NodeOpTypeImage &operator=(const NodeOpTypeImage &) = delete;
  NodeOpTypeImage(NodeOpTypeImage &&) = delete;
  NodeOpTypeImage &operator=(NodeOpTypeImage &&) = delete;
  NodeOpTypeImage(Id id_result, NodePointer<NodeId> sampled_type, Dim dim, LiteralInteger depth, LiteralInteger arrayed,
    LiteralInteger m_s, LiteralInteger sampled, ImageFormat image_format, eastl::optional<AccessQualifier> access_qualifier = {})
  {
    this->resultId = id_result;
    this->sampledType = sampled_type;
    this->dim = dim;
    this->depth = depth;
    this->arrayed = arrayed;
    this->mS = m_s;
    this->sampled = sampled;
    this->imageFormat = image_format;
    this->accessQualifier = access_qualifier;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeInt
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeInt;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  LiteralInteger width;
  LiteralInteger signedness;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeInt() = default;
  ~NodeOpTypeInt() = default;
  NodeOpTypeInt(const NodeOpTypeInt &) = delete;
  NodeOpTypeInt &operator=(const NodeOpTypeInt &) = delete;
  NodeOpTypeInt(NodeOpTypeInt &&) = delete;
  NodeOpTypeInt &operator=(NodeOpTypeInt &&) = delete;
  NodeOpTypeInt(Id id_result, LiteralInteger width, LiteralInteger signedness)
  {
    this->resultId = id_result;
    this->width = width;
    this->signedness = signedness;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeMatrix
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeMatrix;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> columnType;
  LiteralInteger columnCount;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(columnType);
  }
  NodeOpTypeMatrix() = default;
  ~NodeOpTypeMatrix() = default;
  NodeOpTypeMatrix(const NodeOpTypeMatrix &) = delete;
  NodeOpTypeMatrix &operator=(const NodeOpTypeMatrix &) = delete;
  NodeOpTypeMatrix(NodeOpTypeMatrix &&) = delete;
  NodeOpTypeMatrix &operator=(NodeOpTypeMatrix &&) = delete;
  NodeOpTypeMatrix(Id id_result, NodePointer<NodeId> column_type, LiteralInteger column_count)
  {
    this->resultId = id_result;
    this->columnType = column_type;
    this->columnCount = column_count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeNamedBarrier
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeNamedBarrier;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeNamedBarrier() = default;
  ~NodeOpTypeNamedBarrier() = default;
  NodeOpTypeNamedBarrier(const NodeOpTypeNamedBarrier &) = delete;
  NodeOpTypeNamedBarrier &operator=(const NodeOpTypeNamedBarrier &) = delete;
  NodeOpTypeNamedBarrier(NodeOpTypeNamedBarrier &&) = delete;
  NodeOpTypeNamedBarrier &operator=(NodeOpTypeNamedBarrier &&) = delete;
  NodeOpTypeNamedBarrier(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeOpaque
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeOpaque;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::string theNameOfTheOpaqueType;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeOpaque() = default;
  ~NodeOpTypeOpaque() = default;
  NodeOpTypeOpaque(const NodeOpTypeOpaque &) = delete;
  NodeOpTypeOpaque &operator=(const NodeOpTypeOpaque &) = delete;
  NodeOpTypeOpaque(NodeOpTypeOpaque &&) = delete;
  NodeOpTypeOpaque &operator=(NodeOpTypeOpaque &&) = delete;
  NodeOpTypeOpaque(Id id_result, eastl::string the_name_of_the_opaque_type)
  {
    this->resultId = id_result;
    this->theNameOfTheOpaqueType = the_name_of_the_opaque_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypePipe
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypePipe;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  AccessQualifier qualifier;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypePipe() = default;
  ~NodeOpTypePipe() = default;
  NodeOpTypePipe(const NodeOpTypePipe &) = delete;
  NodeOpTypePipe &operator=(const NodeOpTypePipe &) = delete;
  NodeOpTypePipe(NodeOpTypePipe &&) = delete;
  NodeOpTypePipe &operator=(NodeOpTypePipe &&) = delete;
  NodeOpTypePipe(Id id_result, AccessQualifier qualifier)
  {
    this->resultId = id_result;
    this->qualifier = qualifier;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypePipeStorage
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypePipeStorage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypePipeStorage() = default;
  ~NodeOpTypePipeStorage() = default;
  NodeOpTypePipeStorage(const NodeOpTypePipeStorage &) = delete;
  NodeOpTypePipeStorage &operator=(const NodeOpTypePipeStorage &) = delete;
  NodeOpTypePipeStorage(NodeOpTypePipeStorage &&) = delete;
  NodeOpTypePipeStorage &operator=(NodeOpTypePipeStorage &&) = delete;
  NodeOpTypePipeStorage(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypePointer
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypePointer;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  StorageClass storageClass;
  NodePointer<NodeId> type;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(type);
  }
  NodeOpTypePointer() = default;
  ~NodeOpTypePointer() = default;
  NodeOpTypePointer(const NodeOpTypePointer &) = delete;
  NodeOpTypePointer &operator=(const NodeOpTypePointer &) = delete;
  NodeOpTypePointer(NodeOpTypePointer &&) = delete;
  NodeOpTypePointer &operator=(NodeOpTypePointer &&) = delete;
  NodeOpTypePointer(Id id_result, StorageClass storage_class, NodePointer<NodeId> type)
  {
    this->resultId = id_result;
    this->storageClass = storage_class;
    this->type = type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeQueue
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeQueue;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeQueue() = default;
  ~NodeOpTypeQueue() = default;
  NodeOpTypeQueue(const NodeOpTypeQueue &) = delete;
  NodeOpTypeQueue &operator=(const NodeOpTypeQueue &) = delete;
  NodeOpTypeQueue(NodeOpTypeQueue &&) = delete;
  NodeOpTypeQueue &operator=(NodeOpTypeQueue &&) = delete;
  NodeOpTypeQueue(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeRayQueryKHR
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeRayQueryKHR;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeRayQueryKHR() = default;
  ~NodeOpTypeRayQueryKHR() = default;
  NodeOpTypeRayQueryKHR(const NodeOpTypeRayQueryKHR &) = delete;
  NodeOpTypeRayQueryKHR &operator=(const NodeOpTypeRayQueryKHR &) = delete;
  NodeOpTypeRayQueryKHR(NodeOpTypeRayQueryKHR &&) = delete;
  NodeOpTypeRayQueryKHR &operator=(NodeOpTypeRayQueryKHR &&) = delete;
  NodeOpTypeRayQueryKHR(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeReserveId
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeReserveId;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeReserveId() = default;
  ~NodeOpTypeReserveId() = default;
  NodeOpTypeReserveId(const NodeOpTypeReserveId &) = delete;
  NodeOpTypeReserveId &operator=(const NodeOpTypeReserveId &) = delete;
  NodeOpTypeReserveId(NodeOpTypeReserveId &&) = delete;
  NodeOpTypeReserveId &operator=(NodeOpTypeReserveId &&) = delete;
  NodeOpTypeReserveId(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeRuntimeArray
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeRuntimeArray;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> elementType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(elementType);
  }
  NodeOpTypeRuntimeArray() = default;
  ~NodeOpTypeRuntimeArray() = default;
  NodeOpTypeRuntimeArray(const NodeOpTypeRuntimeArray &) = delete;
  NodeOpTypeRuntimeArray &operator=(const NodeOpTypeRuntimeArray &) = delete;
  NodeOpTypeRuntimeArray(NodeOpTypeRuntimeArray &&) = delete;
  NodeOpTypeRuntimeArray &operator=(NodeOpTypeRuntimeArray &&) = delete;
  NodeOpTypeRuntimeArray(Id id_result, NodePointer<NodeId> element_type)
  {
    this->resultId = id_result;
    this->elementType = element_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeSampledImage
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeSampledImage;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> imageType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(imageType);
  }
  NodeOpTypeSampledImage() = default;
  ~NodeOpTypeSampledImage() = default;
  NodeOpTypeSampledImage(const NodeOpTypeSampledImage &) = delete;
  NodeOpTypeSampledImage &operator=(const NodeOpTypeSampledImage &) = delete;
  NodeOpTypeSampledImage(NodeOpTypeSampledImage &&) = delete;
  NodeOpTypeSampledImage &operator=(NodeOpTypeSampledImage &&) = delete;
  NodeOpTypeSampledImage(Id id_result, NodePointer<NodeId> image_type)
  {
    this->resultId = id_result;
    this->imageType = image_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeSampler
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeSampler;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeSampler() = default;
  ~NodeOpTypeSampler() = default;
  NodeOpTypeSampler(const NodeOpTypeSampler &) = delete;
  NodeOpTypeSampler &operator=(const NodeOpTypeSampler &) = delete;
  NodeOpTypeSampler(NodeOpTypeSampler &&) = delete;
  NodeOpTypeSampler &operator=(NodeOpTypeSampler &&) = delete;
  NodeOpTypeSampler(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeStruct
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeStruct;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  eastl::vector<NodePointer<NodeId>> param1;
  template <typename T>
  void visitRefs(T visitor)
  {
    for (auto &&ref : param1)
      visitor(ref);
  }
  NodeOpTypeStruct() = default;
  ~NodeOpTypeStruct() = default;
  NodeOpTypeStruct(const NodeOpTypeStruct &) = delete;
  NodeOpTypeStruct &operator=(const NodeOpTypeStruct &) = delete;
  NodeOpTypeStruct(NodeOpTypeStruct &&) = delete;
  NodeOpTypeStruct &operator=(NodeOpTypeStruct &&) = delete;
  NodeOpTypeStruct(Id id_result, NodePointer<NodeId> *param_1 = nullptr, size_t param_1_count = 0)
  {
    this->resultId = id_result;
    this->param1.assign(param_1, param_1 + param_1_count);
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeVector
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeVector;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> componentType;
  LiteralInteger componentCount;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(componentType);
  }
  NodeOpTypeVector() = default;
  ~NodeOpTypeVector() = default;
  NodeOpTypeVector(const NodeOpTypeVector &) = delete;
  NodeOpTypeVector &operator=(const NodeOpTypeVector &) = delete;
  NodeOpTypeVector(NodeOpTypeVector &&) = delete;
  NodeOpTypeVector &operator=(NodeOpTypeVector &&) = delete;
  NodeOpTypeVector(Id id_result, NodePointer<NodeId> component_type, LiteralInteger component_count)
  {
    this->resultId = id_result;
    this->componentType = component_type;
    this->componentCount = component_count;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeVmeImageINTEL
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeVmeImageINTEL;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  NodePointer<NodeId> imageType;
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(imageType);
  }
  NodeOpTypeVmeImageINTEL() = default;
  ~NodeOpTypeVmeImageINTEL() = default;
  NodeOpTypeVmeImageINTEL(const NodeOpTypeVmeImageINTEL &) = delete;
  NodeOpTypeVmeImageINTEL &operator=(const NodeOpTypeVmeImageINTEL &) = delete;
  NodeOpTypeVmeImageINTEL(NodeOpTypeVmeImageINTEL &&) = delete;
  NodeOpTypeVmeImageINTEL &operator=(NodeOpTypeVmeImageINTEL &&) = delete;
  NodeOpTypeVmeImageINTEL(Id id_result, NodePointer<NodeId> image_type)
  {
    this->resultId = id_result;
    this->imageType = image_type;
  }
  template <typename T>
  static constexpr bool is(const T *value);
};
struct NodeOpTypeVoid
{
  const NodeKind nodeKind = NodeKind::Typedef;
  const Op opCode = Op::OpTypeVoid;
  const Id extOpCode = {};
  const ExtendedGrammar grammarId = ExtendedGrammar::Count;
  Id resultId = 0;
  eastl::vector<CastableUniquePointer<Property>> properties;
  template <typename T>
  void visitRefs(T)
  {}
  NodeOpTypeVoid() = default;
  ~NodeOpTypeVoid() = default;
  NodeOpTypeVoid(const NodeOpTypeVoid &) = delete;
  NodeOpTypeVoid &operator=(const NodeOpTypeVoid &) = delete;
  NodeOpTypeVoid(NodeOpTypeVoid &&) = delete;
  NodeOpTypeVoid &operator=(NodeOpTypeVoid &&) = delete;
  NodeOpTypeVoid(Id id_result) { this->resultId = id_result; }
  template <typename T>
  static constexpr bool is(const T *value);
};
template <typename T>
inline bool NodeTypedef::visit(NodeTypedef *node, T visitor)
{
  if (node->nodeKind == NodeKind::Typedef)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpTypeAccelerationStructureKHR:
        if (visitor(reinterpret_cast<NodeOpTypeAccelerationStructureKHR *>(node)))
          return true;
        break;
      // duplicated OpTypeAccelerationStructureNV = 5341
      case Op::OpTypeArray:
        if (visitor(reinterpret_cast<NodeOpTypeArray *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImeDualReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImeDualReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImeResultDualReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImeResultINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImeResultINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImeResultSingleReferenceStreamoutINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcImeSingleReferenceStreaminINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcImeSingleReferenceStreaminINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcMcePayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcMcePayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcMceResultINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcMceResultINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcRefPayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcRefPayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcRefResultINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcRefResultINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcSicPayloadINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcSicPayloadINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeAvcSicResultINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeAvcSicResultINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeBool:
        if (visitor(reinterpret_cast<NodeOpTypeBool *>(node)))
          return true;
        break;
      case Op::OpTypeBufferSurfaceINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeBufferSurfaceINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeCooperativeMatrixKHR:
        if (visitor(reinterpret_cast<NodeOpTypeCooperativeMatrixKHR *>(node)))
          return true;
        break;
      case Op::OpTypeCooperativeMatrixNV:
        if (visitor(reinterpret_cast<NodeOpTypeCooperativeMatrixNV *>(node)))
          return true;
        break;
      case Op::OpTypeDeviceEvent:
        if (visitor(reinterpret_cast<NodeOpTypeDeviceEvent *>(node)))
          return true;
        break;
      case Op::OpTypeEvent:
        if (visitor(reinterpret_cast<NodeOpTypeEvent *>(node)))
          return true;
        break;
      case Op::OpTypeFloat:
        if (visitor(reinterpret_cast<NodeOpTypeFloat *>(node)))
          return true;
        break;
      case Op::OpTypeFunction:
        if (visitor(reinterpret_cast<NodeOpTypeFunction *>(node)))
          return true;
        break;
      case Op::OpTypeHitObjectNV:
        if (visitor(reinterpret_cast<NodeOpTypeHitObjectNV *>(node)))
          return true;
        break;
      case Op::OpTypeImage:
        if (visitor(reinterpret_cast<NodeOpTypeImage *>(node)))
          return true;
        break;
      case Op::OpTypeInt:
        if (visitor(reinterpret_cast<NodeOpTypeInt *>(node)))
          return true;
        break;
      case Op::OpTypeMatrix:
        if (visitor(reinterpret_cast<NodeOpTypeMatrix *>(node)))
          return true;
        break;
      case Op::OpTypeNamedBarrier:
        if (visitor(reinterpret_cast<NodeOpTypeNamedBarrier *>(node)))
          return true;
        break;
      case Op::OpTypeOpaque:
        if (visitor(reinterpret_cast<NodeOpTypeOpaque *>(node)))
          return true;
        break;
      case Op::OpTypePipe:
        if (visitor(reinterpret_cast<NodeOpTypePipe *>(node)))
          return true;
        break;
      case Op::OpTypePipeStorage:
        if (visitor(reinterpret_cast<NodeOpTypePipeStorage *>(node)))
          return true;
        break;
      case Op::OpTypePointer:
        if (visitor(reinterpret_cast<NodeOpTypePointer *>(node)))
          return true;
        break;
      case Op::OpTypeQueue:
        if (visitor(reinterpret_cast<NodeOpTypeQueue *>(node)))
          return true;
        break;
      case Op::OpTypeRayQueryKHR:
        if (visitor(reinterpret_cast<NodeOpTypeRayQueryKHR *>(node)))
          return true;
        break;
      case Op::OpTypeReserveId:
        if (visitor(reinterpret_cast<NodeOpTypeReserveId *>(node)))
          return true;
        break;
      case Op::OpTypeRuntimeArray:
        if (visitor(reinterpret_cast<NodeOpTypeRuntimeArray *>(node)))
          return true;
        break;
      case Op::OpTypeSampledImage:
        if (visitor(reinterpret_cast<NodeOpTypeSampledImage *>(node)))
          return true;
        break;
      case Op::OpTypeSampler:
        if (visitor(reinterpret_cast<NodeOpTypeSampler *>(node)))
          return true;
        break;
      case Op::OpTypeStruct:
        if (visitor(reinterpret_cast<NodeOpTypeStruct *>(node)))
          return true;
        break;
      case Op::OpTypeVector:
        if (visitor(reinterpret_cast<NodeOpTypeVector *>(node)))
          return true;
        break;
      case Op::OpTypeVmeImageINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeVmeImageINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeVoid:
        if (visitor(reinterpret_cast<NodeOpTypeVoid *>(node)))
          return true;
        break;
    }
  }
  else
  {
    return false;
  }
  return visitor(node);
}
template <typename T>
inline bool NodeId::visit(NodeId *node, T visitor)
{
  if (node->nodeKind == NodeKind::Id)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpAliasDomainDeclINTEL:
        if (visitor(reinterpret_cast<NodeOpAliasDomainDeclINTEL *>(node)))
          return true;
        break;
      case Op::OpAliasScopeDeclINTEL:
        if (visitor(reinterpret_cast<NodeOpAliasScopeDeclINTEL *>(node)))
          return true;
        break;
      case Op::OpAliasScopeListDeclINTEL:
        if (visitor(reinterpret_cast<NodeOpAliasScopeListDeclINTEL *>(node)))
          return true;
        break;
      case Op::OpDecorationGroup:
        if (visitor(reinterpret_cast<NodeOpDecorationGroup *>(node)))
          return true;
        break;
      case Op::OpString:
        if (visitor(reinterpret_cast<NodeOpString *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeBlock::is(node))
    {
      if (NodeBlock::visit(reinterpret_cast<NodeBlock *>(node), visitor))
        return true;
    }
    else if (NodeOperation::is(node))
    {
      if (NodeOperation::visit(reinterpret_cast<NodeOperation *>(node), visitor))
        return true;
    }
    else if (NodeTypedef::is(node))
    {
      if (NodeTypedef::visit(reinterpret_cast<NodeTypedef *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
template <typename T>
inline bool Node::visit(Node *node, T visitor)
{
  if (node->nodeKind == NodeKind::Node)
  {
    switch (node->opCode)
    {
      default: break;
      case Op::OpConstantCompositeContinuedINTEL:
        if (visitor(reinterpret_cast<NodeOpConstantCompositeContinuedINTEL *>(node)))
          return true;
        break;
      case Op::OpNop:
        if (visitor(reinterpret_cast<NodeOpNop *>(node)))
          return true;
        break;
      case Op::OpSpecConstantCompositeContinuedINTEL:
        if (visitor(reinterpret_cast<NodeOpSpecConstantCompositeContinuedINTEL *>(node)))
          return true;
        break;
      case Op::OpTypeStructContinuedINTEL:
        if (visitor(reinterpret_cast<NodeOpTypeStructContinuedINTEL *>(node)))
          return true;
        break;
    }
  }
  else
  {
    if (NodeAction::is(node))
    {
      if (NodeAction::visit(reinterpret_cast<NodeAction *>(node), visitor))
        return true;
    }
    else if (NodeBlockEnd::is(node))
    {
      if (NodeBlockEnd::visit(reinterpret_cast<NodeBlockEnd *>(node), visitor))
        return true;
    }
    else if (NodeId::is(node))
    {
      if (NodeId::visit(reinterpret_cast<NodeId *>(node), visitor))
        return true;
    }
    else
    {
      return false;
    }
  }
  return visitor(node);
}
template <typename T, typename U>
inline bool visitNode(T *node, U visitor)
{
  return T::visit(node, visitor);
}
template <typename T, typename U>
inline bool visitNode(NodePointer<T> node, U visitor)
{
  return T::visit(node.get(), visitor);
}
template <typename T>
inline constexpr bool Node::is(const T *val)
{
  return true;
}
template <typename T>
inline constexpr bool NodeOpConstantCompositeContinuedINTEL::is(const T *val)
{
  return val->opCode == Op::OpConstantCompositeContinuedINTEL;
}
template <typename T>
inline constexpr bool NodeOpNop::is(const T *val)
{
  return val->opCode == Op::OpNop;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantCompositeContinuedINTEL::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantCompositeContinuedINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeStructContinuedINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeStructContinuedINTEL;
}
template <typename T>
inline constexpr bool NodeAction::is(const T *val)
{
  return val->nodeKind == NodeKind::Action || NodeBinaryAction::is(val) || NodeImageAction::is(val) || NodeMultinaryAction::is(val) ||
         NodeScopedAction::is(val) || NodeTrinaryAction::is(val) || NodeUnaryAction::is(val);
}
template <typename T>
inline constexpr bool NodeOpBeginInvocationInterlockEXT::is(const T *val)
{
  return val->opCode == Op::OpBeginInvocationInterlockEXT;
}
template <typename T>
inline constexpr bool NodeOpDemoteToHelperInvocation::is(const T *val)
{
  return val->opCode == Op::OpDemoteToHelperInvocation;
}
template <typename T>
inline constexpr bool NodeOpDemoteToHelperInvocationEXT::is(const T *val)
{
  return val->opCode == Op::OpDemoteToHelperInvocationEXT;
}
template <typename T>
inline constexpr bool NodeOpEmitVertex::is(const T *val)
{
  return val->opCode == Op::OpEmitVertex;
}
template <typename T>
inline constexpr bool NodeOpEndInvocationInterlockEXT::is(const T *val)
{
  return val->opCode == Op::OpEndInvocationInterlockEXT;
}
template <typename T>
inline constexpr bool NodeOpEndPrimitive::is(const T *val)
{
  return val->opCode == Op::OpEndPrimitive;
}
template <typename T>
inline constexpr bool NodeOpIgnoreIntersectionKHR::is(const T *val)
{
  return val->opCode == Op::OpIgnoreIntersectionKHR;
}
template <typename T>
inline constexpr bool NodeOpIgnoreIntersectionNV::is(const T *val)
{
  return val->opCode == Op::OpIgnoreIntersectionNV;
}
template <typename T>
inline constexpr bool NodeOpLine::is(const T *val)
{
  return val->opCode == Op::OpLine;
}
template <typename T>
inline constexpr bool NodeOpNoLine::is(const T *val)
{
  return val->opCode == Op::OpNoLine;
}
template <typename T>
inline constexpr bool NodeOpTerminateInvocation::is(const T *val)
{
  return val->opCode == Op::OpTerminateInvocation;
}
template <typename T>
inline constexpr bool NodeOpTerminateRayKHR::is(const T *val)
{
  return val->opCode == Op::OpTerminateRayKHR;
}
template <typename T>
inline constexpr bool NodeOpTerminateRayNV::is(const T *val)
{
  return val->opCode == Op::OpTerminateRayNV;
}
template <typename T>
inline constexpr bool NodeBinaryAction::is(const T *val)
{
  return val->nodeKind == NodeKind::BinaryAction;
}
template <typename T>
inline constexpr bool NodeOpCopyMemory::is(const T *val)
{
  return val->opCode == Op::OpCopyMemory;
}
template <typename T>
inline constexpr bool NodeOpExecuteCallableKHR::is(const T *val)
{
  return val->opCode == Op::OpExecuteCallableKHR;
}
template <typename T>
inline constexpr bool NodeOpExecuteCallableNV::is(const T *val)
{
  return val->opCode == Op::OpExecuteCallableNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectExecuteShaderNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectExecuteShaderNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetAttributesNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetAttributesNV;
}
template <typename T>
inline constexpr bool NodeOpMaskedScatterINTEL::is(const T *val)
{
  return val->opCode == Op::OpMaskedScatterINTEL;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGenerateIntersectionKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGenerateIntersectionKHR;
}
template <typename T>
inline constexpr bool NodeOpReorderThreadWithHintNV::is(const T *val)
{
  return val->opCode == Op::OpReorderThreadWithHintNV;
}
template <typename T>
inline constexpr bool NodeOpSetMeshOutputsEXT::is(const T *val)
{
  return val->opCode == Op::OpSetMeshOutputsEXT;
}
template <typename T>
inline constexpr bool NodeOpSetUserEventStatus::is(const T *val)
{
  return val->opCode == Op::OpSetUserEventStatus;
}
template <typename T>
inline constexpr bool NodeOpStore::is(const T *val)
{
  return val->opCode == Op::OpStore;
}
template <typename T>
inline constexpr bool NodeOpSubgroupBlockWriteINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupBlockWriteINTEL;
}
template <typename T>
inline constexpr bool NodeOpWritePackedPrimitiveIndices4x8NV::is(const T *val)
{
  return val->opCode == Op::OpWritePackedPrimitiveIndices4x8NV;
}
template <typename T>
inline constexpr bool NodeImageAction::is(const T *val)
{
  return val->nodeKind == NodeKind::ImageAction;
}
template <typename T>
inline constexpr bool NodeOpImageWrite::is(const T *val)
{
  return val->opCode == Op::OpImageWrite;
}
template <typename T>
inline constexpr bool NodeOpSubgroupImageBlockWriteINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupImageBlockWriteINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupImageMediaBlockWriteINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupImageMediaBlockWriteINTEL;
}
template <typename T>
inline constexpr bool NodeMultinaryAction::is(const T *val)
{
  return val->nodeKind == NodeKind::MultinaryAction;
}
template <typename T>
inline constexpr bool NodeOpCommitReadPipe::is(const T *val)
{
  return val->opCode == Op::OpCommitReadPipe;
}
template <typename T>
inline constexpr bool NodeOpCommitWritePipe::is(const T *val)
{
  return val->opCode == Op::OpCommitWritePipe;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixStoreNV::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixStoreNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordHitMotionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordHitMotionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordHitNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordHitNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordHitWithIndexMotionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordHitWithIndexMotionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordHitWithIndexNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordHitWithIndexNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordMissMotionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordMissMotionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordMissNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordMissNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectTraceRayMotionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectTraceRayMotionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectTraceRayNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectTraceRayNV;
}
template <typename T>
inline constexpr bool NodeOpRayQueryInitializeKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryInitializeKHR;
}
template <typename T>
inline constexpr bool NodeOpTraceMotionNV::is(const T *val)
{
  return val->opCode == Op::OpTraceMotionNV;
}
template <typename T>
inline constexpr bool NodeOpTraceNV::is(const T *val)
{
  return val->opCode == Op::OpTraceNV;
}
template <typename T>
inline constexpr bool NodeOpTraceRayKHR::is(const T *val)
{
  return val->opCode == Op::OpTraceRayKHR;
}
template <typename T>
inline constexpr bool NodeOpTraceRayMotionNV::is(const T *val)
{
  return val->opCode == Op::OpTraceRayMotionNV;
}
template <typename T>
inline constexpr bool NodeScopedAction::is(const T *val)
{
  return val->nodeKind == NodeKind::ScopedAction || NodeGroupedAction::is(val);
}
template <typename T>
inline constexpr bool NodeOpControlBarrier::is(const T *val)
{
  return val->opCode == Op::OpControlBarrier;
}
template <typename T>
inline constexpr bool NodeOpControlBarrierArriveINTEL::is(const T *val)
{
  return val->opCode == Op::OpControlBarrierArriveINTEL;
}
template <typename T>
inline constexpr bool NodeOpControlBarrierWaitINTEL::is(const T *val)
{
  return val->opCode == Op::OpControlBarrierWaitINTEL;
}
template <typename T>
inline constexpr bool NodeOpGroupCommitReadPipe::is(const T *val)
{
  return val->opCode == Op::OpGroupCommitReadPipe;
}
template <typename T>
inline constexpr bool NodeOpGroupCommitWritePipe::is(const T *val)
{
  return val->opCode == Op::OpGroupCommitWritePipe;
}
template <typename T>
inline constexpr bool NodeOpGroupWaitEvents::is(const T *val)
{
  return val->opCode == Op::OpGroupWaitEvents;
}
template <typename T>
inline constexpr bool NodeOpMemoryBarrier::is(const T *val)
{
  return val->opCode == Op::OpMemoryBarrier;
}
template <typename T>
inline constexpr bool NodeGroupedAction::is(const T *val)
{
  return val->nodeKind == NodeKind::GroupedAction;
}
template <typename T>
inline constexpr bool NodeTrinaryAction::is(const T *val)
{
  return val->nodeKind == NodeKind::TrinaryAction;
}
template <typename T>
inline constexpr bool NodeOpCaptureEventProfilingInfo::is(const T *val)
{
  return val->opCode == Op::OpCaptureEventProfilingInfo;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixStoreKHR::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixStoreKHR;
}
template <typename T>
inline constexpr bool NodeOpCopyMemorySized::is(const T *val)
{
  return val->opCode == Op::OpCopyMemorySized;
}
template <typename T>
inline constexpr bool NodeOpEmitMeshTasksEXT::is(const T *val)
{
  return val->opCode == Op::OpEmitMeshTasksEXT;
}
template <typename T>
inline constexpr bool NodeUnaryAction::is(const T *val)
{
  return val->nodeKind == NodeKind::UnaryAction;
}
template <typename T>
inline constexpr bool NodeOpAssumeTrueKHR::is(const T *val)
{
  return val->opCode == Op::OpAssumeTrueKHR;
}
template <typename T>
inline constexpr bool NodeOpAtomicFlagClear::is(const T *val)
{
  return val->opCode == Op::OpAtomicFlagClear;
}
template <typename T>
inline constexpr bool NodeOpAtomicStore::is(const T *val)
{
  return val->opCode == Op::OpAtomicStore;
}
template <typename T>
inline constexpr bool NodeOpEmitStreamVertex::is(const T *val)
{
  return val->opCode == Op::OpEmitStreamVertex;
}
template <typename T>
inline constexpr bool NodeOpEndStreamPrimitive::is(const T *val)
{
  return val->opCode == Op::OpEndStreamPrimitive;
}
template <typename T>
inline constexpr bool NodeOpFinalizeNodePayloadsAMDX::is(const T *val)
{
  return val->opCode == Op::OpFinalizeNodePayloadsAMDX;
}
template <typename T>
inline constexpr bool NodeOpHitObjectRecordEmptyNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectRecordEmptyNV;
}
template <typename T>
inline constexpr bool NodeOpInitializeNodePayloadsAMDX::is(const T *val)
{
  return val->opCode == Op::OpInitializeNodePayloadsAMDX;
}
template <typename T>
inline constexpr bool NodeOpLifetimeStart::is(const T *val)
{
  return val->opCode == Op::OpLifetimeStart;
}
template <typename T>
inline constexpr bool NodeOpLifetimeStop::is(const T *val)
{
  return val->opCode == Op::OpLifetimeStop;
}
template <typename T>
inline constexpr bool NodeOpMemoryNamedBarrier::is(const T *val)
{
  return val->opCode == Op::OpMemoryNamedBarrier;
}
template <typename T>
inline constexpr bool NodeOpRayQueryConfirmIntersectionKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryConfirmIntersectionKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryTerminateKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryTerminateKHR;
}
template <typename T>
inline constexpr bool NodeOpReleaseEvent::is(const T *val)
{
  return val->opCode == Op::OpReleaseEvent;
}
template <typename T>
inline constexpr bool NodeOpReorderThreadWithHitObjectNV::is(const T *val)
{
  return val->opCode == Op::OpReorderThreadWithHitObjectNV;
}
template <typename T>
inline constexpr bool NodeOpRestoreMemoryINTEL::is(const T *val)
{
  return val->opCode == Op::OpRestoreMemoryINTEL;
}
template <typename T>
inline constexpr bool NodeOpRetainEvent::is(const T *val)
{
  return val->opCode == Op::OpRetainEvent;
}
template <typename T>
inline constexpr bool NodeBlockEnd::is(const T *val)
{
  return val->nodeKind == NodeKind::BlockEnd || NodeBranch::is(val) || NodeExit::is(val) || NodeReturn::is(val) || NodeSwitch::is(val);
}
template <typename T>
inline constexpr bool NodeOpUnreachable::is(const T *val)
{
  return val->opCode == Op::OpUnreachable;
}
template <typename T>
inline constexpr bool NodeBranch::is(const T *val)
{
  return val->nodeKind == NodeKind::Branch;
}
template <typename T>
inline constexpr bool NodeOpBranch::is(const T *val)
{
  return val->opCode == Op::OpBranch;
}
template <typename T>
inline constexpr bool NodeOpBranchConditional::is(const T *val)
{
  return val->opCode == Op::OpBranchConditional;
}
template <typename T>
inline constexpr bool NodeExit::is(const T *val)
{
  return val->nodeKind == NodeKind::Exit;
}
template <typename T>
inline constexpr bool NodeOpKill::is(const T *val)
{
  return val->opCode == Op::OpKill;
}
template <typename T>
inline constexpr bool NodeReturn::is(const T *val)
{
  return val->nodeKind == NodeKind::Return;
}
template <typename T>
inline constexpr bool NodeOpReturn::is(const T *val)
{
  return val->opCode == Op::OpReturn;
}
template <typename T>
inline constexpr bool NodeOpReturnValue::is(const T *val)
{
  return val->opCode == Op::OpReturnValue;
}
template <typename T>
inline constexpr bool NodeSwitch::is(const T *val)
{
  return val->nodeKind == NodeKind::Switch;
}
template <typename T>
inline constexpr bool NodeOpSwitch::is(const T *val)
{
  return val->opCode == Op::OpSwitch;
}
template <typename T>
inline constexpr bool NodeId::is(const T *val)
{
  return val->nodeKind == NodeKind::Id || NodeBlock::is(val) || NodeOperation::is(val) || NodeTypedef::is(val);
}
template <typename T>
inline constexpr bool NodeOpAliasDomainDeclINTEL::is(const T *val)
{
  return val->opCode == Op::OpAliasDomainDeclINTEL;
}
template <typename T>
inline constexpr bool NodeOpAliasScopeDeclINTEL::is(const T *val)
{
  return val->opCode == Op::OpAliasScopeDeclINTEL;
}
template <typename T>
inline constexpr bool NodeOpAliasScopeListDeclINTEL::is(const T *val)
{
  return val->opCode == Op::OpAliasScopeListDeclINTEL;
}
template <typename T>
inline constexpr bool NodeOpDecorationGroup::is(const T *val)
{
  return val->opCode == Op::OpDecorationGroup;
}
template <typename T>
inline constexpr bool NodeOpString::is(const T *val)
{
  return val->opCode == Op::OpString;
}
template <typename T>
inline constexpr bool NodeBlock::is(const T *val)
{
  return val->nodeKind == NodeKind::Block;
}
template <typename T>
inline constexpr bool NodeOpLabel::is(const T *val)
{
  return val->opCode == Op::OpLabel;
}
template <typename T>
inline constexpr bool NodeOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::Operation || NodeBinaryOperation::is(val) || NodeConstant::is(val) || NodeFunction::is(val) ||
         NodeFunctionCall::is(val) || NodeImageOperation::is(val) || NodeMultinaryOperation::is(val) || NodePhi::is(val) ||
         NodeScopedOperation::is(val) || NodeSpecConstant::is(val) || NodeTrinaryOperation::is(val) || NodeUnaryOperation::is(val) ||
         NodeVariable::is(val);
}
template <typename T>
inline constexpr bool NodeOpAsmTargetINTEL::is(const T *val)
{
  return val->opCode == Op::OpAsmTargetINTEL;
}
template <typename T>
inline constexpr bool NodeOpCompositeConstruct::is(const T *val)
{
  return val->opCode == Op::OpCompositeConstruct;
}
template <typename T>
inline constexpr bool NodeOpCompositeConstructContinuedINTEL::is(const T *val)
{
  return val->opCode == Op::OpCompositeConstructContinuedINTEL;
}
template <typename T>
inline constexpr bool NodeOpCreateUserEvent::is(const T *val)
{
  return val->opCode == Op::OpCreateUserEvent;
}
template <typename T>
inline constexpr bool NodeOpDepthAttachmentReadEXT::is(const T *val)
{
  return val->opCode == Op::OpDepthAttachmentReadEXT;
}
template <typename T>
inline constexpr bool NodeOpFunctionPointerCallINTEL::is(const T *val)
{
  return val->opCode == Op::OpFunctionPointerCallINTEL;
}
template <typename T>
inline constexpr bool NodeOpGetDefaultQueue::is(const T *val)
{
  return val->opCode == Op::OpGetDefaultQueue;
}
template <typename T>
inline constexpr bool NodeOpIsHelperInvocationEXT::is(const T *val)
{
  return val->opCode == Op::OpIsHelperInvocationEXT;
}
template <typename T>
inline constexpr bool NodeOpSaveMemoryINTEL::is(const T *val)
{
  return val->opCode == Op::OpSaveMemoryINTEL;
}
template <typename T>
inline constexpr bool NodeOpStencilAttachmentReadEXT::is(const T *val)
{
  return val->opCode == Op::OpStencilAttachmentReadEXT;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpUndef::is(const T *val)
{
  return val->opCode == Op::OpUndef;
}
template <typename T>
inline constexpr bool NodeOpAMDGcnShaderTime::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_gcn_shader &&
         static_cast<AMDGcnShader>(val->extOpCode) == AMDGcnShader::TimeAMD;
}
template <typename T>
inline constexpr bool NodeBinaryOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::BinaryOperation;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Atan2::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Atan2;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Cross::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Cross;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Distance::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Distance;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FMax::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FMax;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FMin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FMin;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Frexp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Frexp;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450InterpolateAtOffset::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::InterpolateAtOffset;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450InterpolateAtSample::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::InterpolateAtSample;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderExplicitVertexParameterInterpolateAtVertex::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_explicit_vertex_parameter &&
         static_cast<AMDShaderExplicitVertexParameter>(val->extOpCode) == AMDShaderExplicitVertexParameter::InterpolateAtVertexAMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Ldexp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Ldexp;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Modf::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Modf;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450NMax::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::NMax;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450NMin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::NMin;
}
template <typename T>
inline constexpr bool NodeOpAbsISubINTEL::is(const T *val)
{
  return val->opCode == Op::OpAbsISubINTEL;
}
template <typename T>
inline constexpr bool NodeOpAbsUSubINTEL::is(const T *val)
{
  return val->opCode == Op::OpAbsUSubINTEL;
}
template <typename T>
inline constexpr bool NodeOpAsmINTEL::is(const T *val)
{
  return val->opCode == Op::OpAsmINTEL;
}
template <typename T>
inline constexpr bool NodeOpBitwiseAnd::is(const T *val)
{
  return val->opCode == Op::OpBitwiseAnd;
}
template <typename T>
inline constexpr bool NodeOpBitwiseOr::is(const T *val)
{
  return val->opCode == Op::OpBitwiseOr;
}
template <typename T>
inline constexpr bool NodeOpBitwiseXor::is(const T *val)
{
  return val->opCode == Op::OpBitwiseXor;
}
template <typename T>
inline constexpr bool NodeOpCompositeInsert::is(const T *val)
{
  return val->opCode == Op::OpCompositeInsert;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixLoadKHR::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixLoadKHR;
}
template <typename T>
inline constexpr bool NodeOpDot::is(const T *val)
{
  return val->opCode == Op::OpDot;
}
template <typename T>
inline constexpr bool NodeOpExpectKHR::is(const T *val)
{
  return val->opCode == Op::OpExpectKHR;
}
template <typename T>
inline constexpr bool NodeOpFAdd::is(const T *val)
{
  return val->opCode == Op::OpFAdd;
}
template <typename T>
inline constexpr bool NodeOpFDiv::is(const T *val)
{
  return val->opCode == Op::OpFDiv;
}
template <typename T>
inline constexpr bool NodeOpFMod::is(const T *val)
{
  return val->opCode == Op::OpFMod;
}
template <typename T>
inline constexpr bool NodeOpFMul::is(const T *val)
{
  return val->opCode == Op::OpFMul;
}
template <typename T>
inline constexpr bool NodeOpFOrdEqual::is(const T *val)
{
  return val->opCode == Op::OpFOrdEqual;
}
template <typename T>
inline constexpr bool NodeOpFOrdGreaterThan::is(const T *val)
{
  return val->opCode == Op::OpFOrdGreaterThan;
}
template <typename T>
inline constexpr bool NodeOpFOrdGreaterThanEqual::is(const T *val)
{
  return val->opCode == Op::OpFOrdGreaterThanEqual;
}
template <typename T>
inline constexpr bool NodeOpFOrdLessThan::is(const T *val)
{
  return val->opCode == Op::OpFOrdLessThan;
}
template <typename T>
inline constexpr bool NodeOpFOrdLessThanEqual::is(const T *val)
{
  return val->opCode == Op::OpFOrdLessThanEqual;
}
template <typename T>
inline constexpr bool NodeOpFOrdNotEqual::is(const T *val)
{
  return val->opCode == Op::OpFOrdNotEqual;
}
template <typename T>
inline constexpr bool NodeOpFPGARegINTEL::is(const T *val)
{
  return val->opCode == Op::OpFPGARegINTEL;
}
template <typename T>
inline constexpr bool NodeOpFRem::is(const T *val)
{
  return val->opCode == Op::OpFRem;
}
template <typename T>
inline constexpr bool NodeOpFSub::is(const T *val)
{
  return val->opCode == Op::OpFSub;
}
template <typename T>
inline constexpr bool NodeOpFUnordEqual::is(const T *val)
{
  return val->opCode == Op::OpFUnordEqual;
}
template <typename T>
inline constexpr bool NodeOpFUnordGreaterThan::is(const T *val)
{
  return val->opCode == Op::OpFUnordGreaterThan;
}
template <typename T>
inline constexpr bool NodeOpFUnordGreaterThanEqual::is(const T *val)
{
  return val->opCode == Op::OpFUnordGreaterThanEqual;
}
template <typename T>
inline constexpr bool NodeOpFUnordLessThan::is(const T *val)
{
  return val->opCode == Op::OpFUnordLessThan;
}
template <typename T>
inline constexpr bool NodeOpFUnordLessThanEqual::is(const T *val)
{
  return val->opCode == Op::OpFUnordLessThanEqual;
}
template <typename T>
inline constexpr bool NodeOpFUnordNotEqual::is(const T *val)
{
  return val->opCode == Op::OpFUnordNotEqual;
}
template <typename T>
inline constexpr bool NodeOpFixedCosINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedCosINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedCosPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedCosPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedExpINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedExpINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedLogINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedLogINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedRecipINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedRecipINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedRsqrtINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedRsqrtINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedSinCosINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedSinCosINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedSinCosPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedSinCosPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedSinINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedSinINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedSinPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedSinPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpFixedSqrtINTEL::is(const T *val)
{
  return val->opCode == Op::OpFixedSqrtINTEL;
}
template <typename T>
inline constexpr bool NodeOpIAdd::is(const T *val)
{
  return val->opCode == Op::OpIAdd;
}
template <typename T>
inline constexpr bool NodeOpIAddCarry::is(const T *val)
{
  return val->opCode == Op::OpIAddCarry;
}
template <typename T>
inline constexpr bool NodeOpIAddSatINTEL::is(const T *val)
{
  return val->opCode == Op::OpIAddSatINTEL;
}
template <typename T>
inline constexpr bool NodeOpIAverageINTEL::is(const T *val)
{
  return val->opCode == Op::OpIAverageINTEL;
}
template <typename T>
inline constexpr bool NodeOpIAverageRoundedINTEL::is(const T *val)
{
  return val->opCode == Op::OpIAverageRoundedINTEL;
}
template <typename T>
inline constexpr bool NodeOpIEqual::is(const T *val)
{
  return val->opCode == Op::OpIEqual;
}
template <typename T>
inline constexpr bool NodeOpIMul::is(const T *val)
{
  return val->opCode == Op::OpIMul;
}
template <typename T>
inline constexpr bool NodeOpIMul32x16INTEL::is(const T *val)
{
  return val->opCode == Op::OpIMul32x16INTEL;
}
template <typename T>
inline constexpr bool NodeOpINotEqual::is(const T *val)
{
  return val->opCode == Op::OpINotEqual;
}
template <typename T>
inline constexpr bool NodeOpISub::is(const T *val)
{
  return val->opCode == Op::OpISub;
}
template <typename T>
inline constexpr bool NodeOpISubBorrow::is(const T *val)
{
  return val->opCode == Op::OpISubBorrow;
}
template <typename T>
inline constexpr bool NodeOpISubSatINTEL::is(const T *val)
{
  return val->opCode == Op::OpISubSatINTEL;
}
template <typename T>
inline constexpr bool NodeOpLessOrGreater::is(const T *val)
{
  return val->opCode == Op::OpLessOrGreater;
}
template <typename T>
inline constexpr bool NodeOpLogicalAnd::is(const T *val)
{
  return val->opCode == Op::OpLogicalAnd;
}
template <typename T>
inline constexpr bool NodeOpLogicalEqual::is(const T *val)
{
  return val->opCode == Op::OpLogicalEqual;
}
template <typename T>
inline constexpr bool NodeOpLogicalNotEqual::is(const T *val)
{
  return val->opCode == Op::OpLogicalNotEqual;
}
template <typename T>
inline constexpr bool NodeOpLogicalOr::is(const T *val)
{
  return val->opCode == Op::OpLogicalOr;
}
template <typename T>
inline constexpr bool NodeOpMatrixTimesMatrix::is(const T *val)
{
  return val->opCode == Op::OpMatrixTimesMatrix;
}
template <typename T>
inline constexpr bool NodeOpMatrixTimesScalar::is(const T *val)
{
  return val->opCode == Op::OpMatrixTimesScalar;
}
template <typename T>
inline constexpr bool NodeOpMatrixTimesVector::is(const T *val)
{
  return val->opCode == Op::OpMatrixTimesVector;
}
template <typename T>
inline constexpr bool NodeOpOrdered::is(const T *val)
{
  return val->opCode == Op::OpOrdered;
}
template <typename T>
inline constexpr bool NodeOpOuterProduct::is(const T *val)
{
  return val->opCode == Op::OpOuterProduct;
}
template <typename T>
inline constexpr bool NodeOpPtrDiff::is(const T *val)
{
  return val->opCode == Op::OpPtrDiff;
}
template <typename T>
inline constexpr bool NodeOpPtrEqual::is(const T *val)
{
  return val->opCode == Op::OpPtrEqual;
}
template <typename T>
inline constexpr bool NodeOpPtrNotEqual::is(const T *val)
{
  return val->opCode == Op::OpPtrNotEqual;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionBarycentricsKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionBarycentricsKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionFrontFaceKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionFrontFaceKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionGeometryIndexKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionGeometryIndexKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionInstanceCustomIndexKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionInstanceCustomIndexKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionInstanceIdKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionInstanceIdKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionObjectRayDirectionKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionObjectRayDirectionKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionObjectRayOriginKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionObjectRayOriginKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionObjectToWorldKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionObjectToWorldKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionPrimitiveIndexKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionPrimitiveIndexKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionTKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionTKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionTriangleVertexPositionsKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionTriangleVertexPositionsKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionTypeKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionTypeKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionWorldToObjectKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionWorldToObjectKHR;
}
template <typename T>
inline constexpr bool NodeOpReadPipeBlockingINTEL::is(const T *val)
{
  return val->opCode == Op::OpReadPipeBlockingINTEL;
}
template <typename T>
inline constexpr bool NodeOpReportIntersectionKHR::is(const T *val)
{
  return val->opCode == Op::OpReportIntersectionKHR;
}
template <typename T>
inline constexpr bool NodeOpReportIntersectionNV::is(const T *val)
{
  return val->opCode == Op::OpReportIntersectionNV;
}
template <typename T>
inline constexpr bool NodeOpSDiv::is(const T *val)
{
  return val->opCode == Op::OpSDiv;
}
template <typename T>
inline constexpr bool NodeOpSDot::is(const T *val)
{
  return val->opCode == Op::OpSDot;
}
template <typename T>
inline constexpr bool NodeOpSDotKHR::is(const T *val)
{
  return val->opCode == Op::OpSDotKHR;
}
template <typename T>
inline constexpr bool NodeOpSGreaterThan::is(const T *val)
{
  return val->opCode == Op::OpSGreaterThan;
}
template <typename T>
inline constexpr bool NodeOpSGreaterThanEqual::is(const T *val)
{
  return val->opCode == Op::OpSGreaterThanEqual;
}
template <typename T>
inline constexpr bool NodeOpSLessThan::is(const T *val)
{
  return val->opCode == Op::OpSLessThan;
}
template <typename T>
inline constexpr bool NodeOpSLessThanEqual::is(const T *val)
{
  return val->opCode == Op::OpSLessThanEqual;
}
template <typename T>
inline constexpr bool NodeOpSMod::is(const T *val)
{
  return val->opCode == Op::OpSMod;
}
template <typename T>
inline constexpr bool NodeOpSMulExtended::is(const T *val)
{
  return val->opCode == Op::OpSMulExtended;
}
template <typename T>
inline constexpr bool NodeOpSRem::is(const T *val)
{
  return val->opCode == Op::OpSRem;
}
template <typename T>
inline constexpr bool NodeOpSUDot::is(const T *val)
{
  return val->opCode == Op::OpSUDot;
}
template <typename T>
inline constexpr bool NodeOpSUDotKHR::is(const T *val)
{
  return val->opCode == Op::OpSUDotKHR;
}
template <typename T>
inline constexpr bool NodeOpShiftLeftLogical::is(const T *val)
{
  return val->opCode == Op::OpShiftLeftLogical;
}
template <typename T>
inline constexpr bool NodeOpShiftRightArithmetic::is(const T *val)
{
  return val->opCode == Op::OpShiftRightArithmetic;
}
template <typename T>
inline constexpr bool NodeOpShiftRightLogical::is(const T *val)
{
  return val->opCode == Op::OpShiftRightLogical;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetBorderReachedINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetBorderReachedINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeRefWindowSizeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeRefWindowSizeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetEarlySearchTerminationThresholdINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetMaxMotionVectorCountINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetMaxMotionVectorCountINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetWeightedSadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetWeightedSadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultInterShapePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetInterDirectionPenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetInterDirectionPenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetInterShapePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetInterShapePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicEvaluateIpeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicEvaluateIpeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetMotionVectorMaskINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetMotionVectorMaskINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetBlockBasedRawSkipSadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetIntraChromaModeCostFunctionINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetIntraLumaShapePenaltyINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetSkcForwardTransformEnableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetSkcForwardTransformEnableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupReadInvocationKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupReadInvocationKHR;
}
template <typename T>
inline constexpr bool NodeOpSubgroupShuffleINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupShuffleINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupShuffleXorINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupShuffleXorINTEL;
}
template <typename T>
inline constexpr bool NodeOpUAddSatINTEL::is(const T *val)
{
  return val->opCode == Op::OpUAddSatINTEL;
}
template <typename T>
inline constexpr bool NodeOpUAverageINTEL::is(const T *val)
{
  return val->opCode == Op::OpUAverageINTEL;
}
template <typename T>
inline constexpr bool NodeOpUAverageRoundedINTEL::is(const T *val)
{
  return val->opCode == Op::OpUAverageRoundedINTEL;
}
template <typename T>
inline constexpr bool NodeOpUDiv::is(const T *val)
{
  return val->opCode == Op::OpUDiv;
}
template <typename T>
inline constexpr bool NodeOpUDot::is(const T *val)
{
  return val->opCode == Op::OpUDot;
}
template <typename T>
inline constexpr bool NodeOpUDotKHR::is(const T *val)
{
  return val->opCode == Op::OpUDotKHR;
}
template <typename T>
inline constexpr bool NodeOpUGreaterThan::is(const T *val)
{
  return val->opCode == Op::OpUGreaterThan;
}
template <typename T>
inline constexpr bool NodeOpUGreaterThanEqual::is(const T *val)
{
  return val->opCode == Op::OpUGreaterThanEqual;
}
template <typename T>
inline constexpr bool NodeOpULessThan::is(const T *val)
{
  return val->opCode == Op::OpULessThan;
}
template <typename T>
inline constexpr bool NodeOpULessThanEqual::is(const T *val)
{
  return val->opCode == Op::OpULessThanEqual;
}
template <typename T>
inline constexpr bool NodeOpUMod::is(const T *val)
{
  return val->opCode == Op::OpUMod;
}
template <typename T>
inline constexpr bool NodeOpUMul32x16INTEL::is(const T *val)
{
  return val->opCode == Op::OpUMul32x16INTEL;
}
template <typename T>
inline constexpr bool NodeOpUMulExtended::is(const T *val)
{
  return val->opCode == Op::OpUMulExtended;
}
template <typename T>
inline constexpr bool NodeOpUSubSatINTEL::is(const T *val)
{
  return val->opCode == Op::OpUSubSatINTEL;
}
template <typename T>
inline constexpr bool NodeOpUnordered::is(const T *val)
{
  return val->opCode == Op::OpUnordered;
}
template <typename T>
inline constexpr bool NodeOpVectorExtractDynamic::is(const T *val)
{
  return val->opCode == Op::OpVectorExtractDynamic;
}
template <typename T>
inline constexpr bool NodeOpVectorShuffle::is(const T *val)
{
  return val->opCode == Op::OpVectorShuffle;
}
template <typename T>
inline constexpr bool NodeOpVectorTimesMatrix::is(const T *val)
{
  return val->opCode == Op::OpVectorTimesMatrix;
}
template <typename T>
inline constexpr bool NodeOpVectorTimesScalar::is(const T *val)
{
  return val->opCode == Op::OpVectorTimesScalar;
}
template <typename T>
inline constexpr bool NodeOpVmeImageINTEL::is(const T *val)
{
  return val->opCode == Op::OpVmeImageINTEL;
}
template <typename T>
inline constexpr bool NodeOpWritePipeBlockingINTEL::is(const T *val)
{
  return val->opCode == Op::OpWritePipeBlockingINTEL;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Pow::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Pow;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Reflect::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Reflect;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SMax::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SMax;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SMin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SMin;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Step::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Step;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderBallotSwizzleInvocations::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_ballot &&
         static_cast<AMDShaderBallot>(val->extOpCode) == AMDShaderBallot::SwizzleInvocationsAMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderBallotSwizzleInvocationsMasked::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_ballot &&
         static_cast<AMDShaderBallot>(val->extOpCode) == AMDShaderBallot::SwizzleInvocationsMaskedAMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UMax::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UMax;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UMin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UMin;
}
template <typename T>
inline constexpr bool NodeConstant::is(const T *val)
{
  return val->nodeKind == NodeKind::Constant || NodeConstantComposite::is(val) || NodeConstantSampler::is(val);
}
template <typename T>
inline constexpr bool NodeOpConstant::is(const T *val)
{
  return val->opCode == Op::OpConstant;
}
template <typename T>
inline constexpr bool NodeOpConstantFalse::is(const T *val)
{
  return val->opCode == Op::OpConstantFalse;
}
template <typename T>
inline constexpr bool NodeOpConstantFunctionPointerINTEL::is(const T *val)
{
  return val->opCode == Op::OpConstantFunctionPointerINTEL;
}
template <typename T>
inline constexpr bool NodeOpConstantNull::is(const T *val)
{
  return val->opCode == Op::OpConstantNull;
}
template <typename T>
inline constexpr bool NodeOpConstantPipeStorage::is(const T *val)
{
  return val->opCode == Op::OpConstantPipeStorage;
}
template <typename T>
inline constexpr bool NodeOpConstantTrue::is(const T *val)
{
  return val->opCode == Op::OpConstantTrue;
}
template <typename T>
inline constexpr bool NodeConstantComposite::is(const T *val)
{
  return val->nodeKind == NodeKind::ConstantComposite;
}
template <typename T>
inline constexpr bool NodeOpConstantComposite::is(const T *val)
{
  return val->opCode == Op::OpConstantComposite;
}
template <typename T>
inline constexpr bool NodeOpConstantCompositeReplicateEXT::is(const T *val)
{
  return val->opCode == Op::OpConstantCompositeReplicateEXT;
}
template <typename T>
inline constexpr bool NodeConstantSampler::is(const T *val)
{
  return val->nodeKind == NodeKind::ConstantSampler;
}
template <typename T>
inline constexpr bool NodeOpConstantSampler::is(const T *val)
{
  return val->opCode == Op::OpConstantSampler;
}
template <typename T>
inline constexpr bool NodeFunction::is(const T *val)
{
  return val->nodeKind == NodeKind::Function;
}
template <typename T>
inline constexpr bool NodeOpFunction::is(const T *val)
{
  return val->opCode == Op::OpFunction;
}
template <typename T>
inline constexpr bool NodeFunctionCall::is(const T *val)
{
  return val->nodeKind == NodeKind::FunctionCall;
}
template <typename T>
inline constexpr bool NodeOpFunctionCall::is(const T *val)
{
  return val->opCode == Op::OpFunctionCall;
}
template <typename T>
inline constexpr bool NodeImageOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::ImageOperation;
}
template <typename T>
inline constexpr bool NodeOpFragmentFetchAMD::is(const T *val)
{
  return val->opCode == Op::OpFragmentFetchAMD;
}
template <typename T>
inline constexpr bool NodeOpFragmentMaskFetchAMD::is(const T *val)
{
  return val->opCode == Op::OpFragmentMaskFetchAMD;
}
template <typename T>
inline constexpr bool NodeOpImage::is(const T *val)
{
  return val->opCode == Op::OpImage;
}
template <typename T>
inline constexpr bool NodeOpImageDrefGather::is(const T *val)
{
  return val->opCode == Op::OpImageDrefGather;
}
template <typename T>
inline constexpr bool NodeOpImageFetch::is(const T *val)
{
  return val->opCode == Op::OpImageFetch;
}
template <typename T>
inline constexpr bool NodeOpImageGather::is(const T *val)
{
  return val->opCode == Op::OpImageGather;
}
template <typename T>
inline constexpr bool NodeOpImageQueryFormat::is(const T *val)
{
  return val->opCode == Op::OpImageQueryFormat;
}
template <typename T>
inline constexpr bool NodeOpImageQueryLevels::is(const T *val)
{
  return val->opCode == Op::OpImageQueryLevels;
}
template <typename T>
inline constexpr bool NodeOpImageQueryLod::is(const T *val)
{
  return val->opCode == Op::OpImageQueryLod;
}
template <typename T>
inline constexpr bool NodeOpImageQueryOrder::is(const T *val)
{
  return val->opCode == Op::OpImageQueryOrder;
}
template <typename T>
inline constexpr bool NodeOpImageQuerySamples::is(const T *val)
{
  return val->opCode == Op::OpImageQuerySamples;
}
template <typename T>
inline constexpr bool NodeOpImageQuerySize::is(const T *val)
{
  return val->opCode == Op::OpImageQuerySize;
}
template <typename T>
inline constexpr bool NodeOpImageQuerySizeLod::is(const T *val)
{
  return val->opCode == Op::OpImageQuerySizeLod;
}
template <typename T>
inline constexpr bool NodeOpImageRead::is(const T *val)
{
  return val->opCode == Op::OpImageRead;
}
template <typename T>
inline constexpr bool NodeOpImageSampleDrefExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleDrefExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleDrefImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleDrefImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleFootprintNV::is(const T *val)
{
  return val->opCode == Op::OpImageSampleFootprintNV;
}
template <typename T>
inline constexpr bool NodeOpImageSampleImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleProjDrefExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleProjDrefExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleProjDrefImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleProjDrefImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleProjExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleProjExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSampleProjImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSampleProjImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseDrefGather::is(const T *val)
{
  return val->opCode == Op::OpImageSparseDrefGather;
}
template <typename T>
inline constexpr bool NodeOpImageSparseFetch::is(const T *val)
{
  return val->opCode == Op::OpImageSparseFetch;
}
template <typename T>
inline constexpr bool NodeOpImageSparseGather::is(const T *val)
{
  return val->opCode == Op::OpImageSparseGather;
}
template <typename T>
inline constexpr bool NodeOpImageSparseRead::is(const T *val)
{
  return val->opCode == Op::OpImageSparseRead;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleDrefExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleDrefExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleDrefImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleDrefImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleProjDrefExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleProjDrefExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleProjDrefImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleProjDrefImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleProjExplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleProjExplicitLod;
}
template <typename T>
inline constexpr bool NodeOpImageSparseSampleProjImplicitLod::is(const T *val)
{
  return val->opCode == Op::OpImageSparseSampleProjImplicitLod;
}
template <typename T>
inline constexpr bool NodeOpSampledImage::is(const T *val)
{
  return val->opCode == Op::OpSampledImage;
}
template <typename T>
inline constexpr bool NodeOpSubgroupImageBlockReadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupImageBlockReadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupImageMediaBlockReadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupImageMediaBlockReadINTEL;
}
template <typename T>
inline constexpr bool NodeMultinaryOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::MultinaryOperation;
}
template <typename T>
inline constexpr bool NodeOpBitFieldInsert::is(const T *val)
{
  return val->opCode == Op::OpBitFieldInsert;
}
template <typename T>
inline constexpr bool NodeOpEnqueueKernel::is(const T *val)
{
  return val->opCode == Op::OpEnqueueKernel;
}
template <typename T>
inline constexpr bool NodeOpEnqueueMarker::is(const T *val)
{
  return val->opCode == Op::OpEnqueueMarker;
}
template <typename T>
inline constexpr bool NodeOpFetchMicroTriangleVertexBarycentricNV::is(const T *val)
{
  return val->opCode == Op::OpFetchMicroTriangleVertexBarycentricNV;
}
template <typename T>
inline constexpr bool NodeOpFetchMicroTriangleVertexPositionNV::is(const T *val)
{
  return val->opCode == Op::OpFetchMicroTriangleVertexPositionNV;
}
template <typename T>
inline constexpr bool NodeOpGetKernelLocalSizeForSubgroupCount::is(const T *val)
{
  return val->opCode == Op::OpGetKernelLocalSizeForSubgroupCount;
}
template <typename T>
inline constexpr bool NodeOpGetKernelMaxNumSubgroups::is(const T *val)
{
  return val->opCode == Op::OpGetKernelMaxNumSubgroups;
}
template <typename T>
inline constexpr bool NodeOpGetKernelNDrangeMaxSubGroupSize::is(const T *val)
{
  return val->opCode == Op::OpGetKernelNDrangeMaxSubGroupSize;
}
template <typename T>
inline constexpr bool NodeOpGetKernelNDrangeSubGroupCount::is(const T *val)
{
  return val->opCode == Op::OpGetKernelNDrangeSubGroupCount;
}
template <typename T>
inline constexpr bool NodeOpGetKernelPreferredWorkGroupSizeMultiple::is(const T *val)
{
  return val->opCode == Op::OpGetKernelPreferredWorkGroupSizeMultiple;
}
template <typename T>
inline constexpr bool NodeOpGetKernelWorkGroupSize::is(const T *val)
{
  return val->opCode == Op::OpGetKernelWorkGroupSize;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchGatherSADQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchGatherSADQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchGatherSSDQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchGatherSSDQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchSADQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchSADQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchSSDQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchSSDQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchWindowSADQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchWindowSADQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageBlockMatchWindowSSDQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBlockMatchWindowSSDQCOM;
}
template <typename T>
inline constexpr bool NodeOpRawAccessChainNV::is(const T *val)
{
  return val->opCode == Op::OpRawAccessChainNV;
}
template <typename T>
inline constexpr bool NodeOpReadPipe::is(const T *val)
{
  return val->opCode == Op::OpReadPipe;
}
template <typename T>
inline constexpr bool NodeOpReserveReadPipePackets::is(const T *val)
{
  return val->opCode == Op::OpReserveReadPipePackets;
}
template <typename T>
inline constexpr bool NodeOpReserveWritePipePackets::is(const T *val)
{
  return val->opCode == Op::OpReserveWritePipePackets;
}
template <typename T>
inline constexpr bool NodeOpReservedReadPipe::is(const T *val)
{
  return val->opCode == Op::OpReservedReadPipe;
}
template <typename T>
inline constexpr bool NodeOpReservedWritePipe::is(const T *val)
{
  return val->opCode == Op::OpReservedWritePipe;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcBmeInitializeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcBmeInitializeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcFmeInitializeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcFmeInitializeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeAdjustRefOffsetINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeAdjustRefOffsetINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithDualReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithDualReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetDualReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetDualReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetMotionVectorCostFunctionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetMotionVectorCostFunctionINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefEvaluateWithDualReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefEvaluateWithDualReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicConfigureIpeLumaChromaINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicConfigureIpeLumaChromaINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicConfigureIpeLumaINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicConfigureIpeLumaINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicConfigureSkcINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicConfigureSkcINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicEvaluateWithDualReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicEvaluateWithDualReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetIntraLumaModeCostFunctionINTEL;
}
template <typename T>
inline constexpr bool NodeOpWritePipe::is(const T *val)
{
  return val->opCode == Op::OpWritePipe;
}
template <typename T>
inline constexpr bool NodePhi::is(const T *val)
{
  return val->nodeKind == NodeKind::Phi;
}
template <typename T>
inline constexpr bool NodeOpPhi::is(const T *val)
{
  return val->opCode == Op::OpPhi;
}
template <typename T>
inline constexpr bool NodeScopedOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::ScopedOperation || NodeGroupedOperation::is(val);
}
template <typename T>
inline constexpr bool NodeOpGroupAll::is(const T *val)
{
  return val->opCode == Op::OpGroupAll;
}
template <typename T>
inline constexpr bool NodeOpGroupAny::is(const T *val)
{
  return val->opCode == Op::OpGroupAny;
}
template <typename T>
inline constexpr bool NodeOpGroupAsyncCopy::is(const T *val)
{
  return val->opCode == Op::OpGroupAsyncCopy;
}
template <typename T>
inline constexpr bool NodeOpGroupBroadcast::is(const T *val)
{
  return val->opCode == Op::OpGroupBroadcast;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformAll::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformAll;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformAllEqual::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformAllEqual;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformAny::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformAny;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBallot::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBallot;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBallotBitExtract::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBallotBitExtract;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBallotFindLSB::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBallotFindLSB;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBallotFindMSB::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBallotFindMSB;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBroadcast::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBroadcast;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBroadcastFirst::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBroadcastFirst;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformElect::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformElect;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformInverseBallot::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformInverseBallot;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformQuadBroadcast::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformQuadBroadcast;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformQuadSwap::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformQuadSwap;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformRotateKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformRotateKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformShuffle::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformShuffle;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformShuffleDown::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformShuffleDown;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformShuffleUp::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformShuffleUp;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformShuffleXor::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformShuffleXor;
}
template <typename T>
inline constexpr bool NodeOpGroupReserveReadPipePackets::is(const T *val)
{
  return val->opCode == Op::OpGroupReserveReadPipePackets;
}
template <typename T>
inline constexpr bool NodeOpGroupReserveWritePipePackets::is(const T *val)
{
  return val->opCode == Op::OpGroupReserveWritePipePackets;
}
template <typename T>
inline constexpr bool NodeOpReadClockKHR::is(const T *val)
{
  return val->opCode == Op::OpReadClockKHR;
}
template <typename T>
inline constexpr bool NodeGroupedOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::GroupedOperation;
}
template <typename T>
inline constexpr bool NodeOpGroupBitwiseAndKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupBitwiseAndKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupBitwiseOrKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupBitwiseOrKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupBitwiseXorKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupBitwiseXorKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupFAdd::is(const T *val)
{
  return val->opCode == Op::OpGroupFAdd;
}
template <typename T>
inline constexpr bool NodeOpGroupFAddNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupFAddNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupFMax::is(const T *val)
{
  return val->opCode == Op::OpGroupFMax;
}
template <typename T>
inline constexpr bool NodeOpGroupFMaxNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupFMaxNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupFMin::is(const T *val)
{
  return val->opCode == Op::OpGroupFMin;
}
template <typename T>
inline constexpr bool NodeOpGroupFMinNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupFMinNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupFMulKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupFMulKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupIAdd::is(const T *val)
{
  return val->opCode == Op::OpGroupIAdd;
}
template <typename T>
inline constexpr bool NodeOpGroupIAddNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupIAddNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupIMulKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupIMulKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupLogicalAndKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupLogicalAndKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupLogicalOrKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupLogicalOrKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupLogicalXorKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupLogicalXorKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBallotBitCount::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBallotBitCount;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBitwiseAnd::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBitwiseAnd;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBitwiseOr::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBitwiseOr;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformBitwiseXor::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformBitwiseXor;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformFAdd::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformFAdd;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformFMax::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformFMax;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformFMin::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformFMin;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformFMul::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformFMul;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformIAdd::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformIAdd;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformIMul::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformIMul;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformLogicalAnd::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformLogicalAnd;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformLogicalOr::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformLogicalOr;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformLogicalXor::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformLogicalXor;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformSMax::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformSMax;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformSMin::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformSMin;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformUMax::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformUMax;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformUMin::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformUMin;
}
template <typename T>
inline constexpr bool NodeOpGroupSMax::is(const T *val)
{
  return val->opCode == Op::OpGroupSMax;
}
template <typename T>
inline constexpr bool NodeOpGroupSMaxNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupSMaxNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupSMin::is(const T *val)
{
  return val->opCode == Op::OpGroupSMin;
}
template <typename T>
inline constexpr bool NodeOpGroupSMinNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupSMinNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupUMax::is(const T *val)
{
  return val->opCode == Op::OpGroupUMax;
}
template <typename T>
inline constexpr bool NodeOpGroupUMaxNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupUMaxNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeOpGroupUMin::is(const T *val)
{
  return val->opCode == Op::OpGroupUMin;
}
template <typename T>
inline constexpr bool NodeOpGroupUMinNonUniformAMD::is(const T *val)
{
  return val->opCode == Op::OpGroupUMinNonUniformAMD;
}
template <typename T>
inline constexpr bool NodeSpecConstant::is(const T *val)
{
  return val->nodeKind == NodeKind::SpecConstant || NodeSpecConstantComposite::is(val) || NodeSpecConstantOperation::is(val);
}
template <typename T>
inline constexpr bool NodeOpSpecConstant::is(const T *val)
{
  return val->opCode == Op::OpSpecConstant;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantFalse::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantFalse;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantTrue::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantTrue;
}
template <typename T>
inline constexpr bool NodeSpecConstantComposite::is(const T *val)
{
  return val->nodeKind == NodeKind::SpecConstantComposite;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantComposite::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantComposite;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantCompositeReplicateEXT::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantCompositeReplicateEXT;
}
template <typename T>
inline constexpr bool NodeSpecConstantOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::SpecConstantOperation;
}
template <typename T>
inline constexpr bool NodeOpSpecConstantOp::is(const T *val)
{
  return val->opCode == Op::OpSpecConstantOp;
}
template <typename T>
inline constexpr bool NodeTrinaryOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::TrinaryOperation;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FClamp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FClamp;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxFMax3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::FMax3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxFMid3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::FMid3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxFMin3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::FMin3AMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FMix::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FMix;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FaceForward::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FaceForward;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Fma::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Fma;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450IMix::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::IMix;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450NClamp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::NClamp;
}
template <typename T>
inline constexpr bool NodeOpBitFieldSExtract::is(const T *val)
{
  return val->opCode == Op::OpBitFieldSExtract;
}
template <typename T>
inline constexpr bool NodeOpBitFieldUExtract::is(const T *val)
{
  return val->opCode == Op::OpBitFieldUExtract;
}
template <typename T>
inline constexpr bool NodeOpBuildNDRange::is(const T *val)
{
  return val->opCode == Op::OpBuildNDRange;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixLoadNV::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixLoadNV;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixMulAddKHR::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixMulAddKHR;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixMulAddNV::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixMulAddNV;
}
template <typename T>
inline constexpr bool NodeOpGetMaxPipePackets::is(const T *val)
{
  return val->opCode == Op::OpGetMaxPipePackets;
}
template <typename T>
inline constexpr bool NodeOpGetNumPipePackets::is(const T *val)
{
  return val->opCode == Op::OpGetNumPipePackets;
}
template <typename T>
inline constexpr bool NodeOpImageBoxFilterQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageBoxFilterQCOM;
}
template <typename T>
inline constexpr bool NodeOpImageSampleWeightedQCOM::is(const T *val)
{
  return val->opCode == Op::OpImageSampleWeightedQCOM;
}
template <typename T>
inline constexpr bool NodeOpSDotAccSat::is(const T *val)
{
  return val->opCode == Op::OpSDotAccSat;
}
template <typename T>
inline constexpr bool NodeOpSDotAccSatKHR::is(const T *val)
{
  return val->opCode == Op::OpSDotAccSatKHR;
}
template <typename T>
inline constexpr bool NodeOpSUDotAccSat::is(const T *val)
{
  return val->opCode == Op::OpSUDotAccSat;
}
template <typename T>
inline constexpr bool NodeOpSUDotAccSatKHR::is(const T *val)
{
  return val->opCode == Op::OpSUDotAccSatKHR;
}
template <typename T>
inline constexpr bool NodeOpSelect::is(const T *val)
{
  return val->opCode == Op::OpSelect;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithSingleReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithSingleReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeInitializeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeInitializeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetSingleReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetSingleReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefEvaluateWithMultiReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefEvaluateWithMultiReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefEvaluateWithSingleReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefEvaluateWithSingleReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicEvaluateWithMultiReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicEvaluateWithMultiReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicEvaluateWithSingleReferenceINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicEvaluateWithSingleReferenceINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupShuffleDownINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupShuffleDownINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupShuffleUpINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupShuffleUpINTEL;
}
template <typename T>
inline constexpr bool NodeOpUDotAccSat::is(const T *val)
{
  return val->opCode == Op::OpUDotAccSat;
}
template <typename T>
inline constexpr bool NodeOpUDotAccSatKHR::is(const T *val)
{
  return val->opCode == Op::OpUDotAccSatKHR;
}
template <typename T>
inline constexpr bool NodeOpVectorInsertDynamic::is(const T *val)
{
  return val->opCode == Op::OpVectorInsertDynamic;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Refract::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Refract;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SClamp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SClamp;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxSMax3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::SMax3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxSMid3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::SMid3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxSMin3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::SMin3AMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SmoothStep::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SmoothStep;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UClamp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UClamp;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxUMax3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::UMax3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxUMid3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::UMid3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderTrinaryMinmaxUMin3::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_trinary_minmax &&
         static_cast<AMDShaderTrinaryMinmax>(val->extOpCode) == AMDShaderTrinaryMinmax::UMin3AMD;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderBallotWriteInvocation::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_ballot &&
         static_cast<AMDShaderBallot>(val->extOpCode) == AMDShaderBallot::WriteInvocationAMD;
}
template <typename T>
inline constexpr bool NodeUnaryOperation::is(const T *val)
{
  return val->nodeKind == NodeKind::UnaryOperation;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Acos::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Acos;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Acosh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Acosh;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Asin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Asin;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Asinh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Asinh;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Atan::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Atan;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Atanh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Atanh;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Ceil::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Ceil;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Cos::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Cos;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Cosh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Cosh;
}
template <typename T>
inline constexpr bool NodeOpAMDGcnShaderCubeFaceCoord::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_gcn_shader &&
         static_cast<AMDGcnShader>(val->extOpCode) == AMDGcnShader::CubeFaceCoordAMD;
}
template <typename T>
inline constexpr bool NodeOpAMDGcnShaderCubeFaceIndex::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_gcn_shader &&
         static_cast<AMDGcnShader>(val->extOpCode) == AMDGcnShader::CubeFaceIndexAMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Degrees::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Degrees;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Determinant::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Determinant;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Exp::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Exp;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Exp2::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Exp2;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FAbs::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FAbs;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FSign::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FSign;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FindILsb::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FindILsb;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FindSMsb::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FindSMsb;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FindUMsb::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FindUMsb;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Floor::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Floor;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Fract::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Fract;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450FrexpStruct::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::FrexpStruct;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450InterpolateAtCentroid::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::InterpolateAtCentroid;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450InverseSqrt::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::InverseSqrt;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Length::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Length;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Log::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Log;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Log2::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Log2;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450MatrixInverse::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::MatrixInverse;
}
template <typename T>
inline constexpr bool NodeOpAMDShaderBallotMbcnt::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::AMD_shader_ballot &&
         static_cast<AMDShaderBallot>(val->extOpCode) == AMDShaderBallot::MbcntAMD;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450ModfStruct::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::ModfStruct;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Normalize::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Normalize;
}
template <typename T>
inline constexpr bool NodeOpAll::is(const T *val)
{
  return val->opCode == Op::OpAll;
}
template <typename T>
inline constexpr bool NodeOpAny::is(const T *val)
{
  return val->opCode == Op::OpAny;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatACosINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatACosINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatACosPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatACosPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatASinINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatASinINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatASinPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatASinPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatATan2INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatATan2INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatATanINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatATanINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatATanPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatATanPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatAddINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatAddINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCastFromIntINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCastFromIntINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCastINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCastINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCastToIntINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCastToIntINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCbrtINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCbrtINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCosINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCosINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatCosPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatCosPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatDivINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatDivINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatEQINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatEQINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatExp10INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatExp10INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatExp2INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatExp2INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatExpINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatExpINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatExpm1INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatExpm1INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatGEINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatGEINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatGTINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatGTINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatHypotINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatHypotINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLEINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLEINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLTINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLTINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLog10INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLog10INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLog1pINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLog1pINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLog2INTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLog2INTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatLogINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatLogINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatMulINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatMulINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatPowINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatPowINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatPowNINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatPowNINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatPowRINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatPowRINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatRSqrtINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatRSqrtINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatRecipINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatRecipINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSinCosINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSinCosINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSinCosPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSinCosPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSinINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSinINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSinPiINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSinPiINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSqrtINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSqrtINTEL;
}
template <typename T>
inline constexpr bool NodeOpArbitraryFloatSubINTEL::is(const T *val)
{
  return val->opCode == Op::OpArbitraryFloatSubINTEL;
}
template <typename T>
inline constexpr bool NodeOpArrayLength::is(const T *val)
{
  return val->opCode == Op::OpArrayLength;
}
template <typename T>
inline constexpr bool NodeOpAsmCallINTEL::is(const T *val)
{
  return val->opCode == Op::OpAsmCallINTEL;
}
template <typename T>
inline constexpr bool NodeOpAtomicAnd::is(const T *val)
{
  return val->opCode == Op::OpAtomicAnd;
}
template <typename T>
inline constexpr bool NodeOpAtomicCompareExchange::is(const T *val)
{
  return val->opCode == Op::OpAtomicCompareExchange;
}
template <typename T>
inline constexpr bool NodeOpAtomicCompareExchangeWeak::is(const T *val)
{
  return val->opCode == Op::OpAtomicCompareExchangeWeak;
}
template <typename T>
inline constexpr bool NodeOpAtomicExchange::is(const T *val)
{
  return val->opCode == Op::OpAtomicExchange;
}
template <typename T>
inline constexpr bool NodeOpAtomicFAddEXT::is(const T *val)
{
  return val->opCode == Op::OpAtomicFAddEXT;
}
template <typename T>
inline constexpr bool NodeOpAtomicFMaxEXT::is(const T *val)
{
  return val->opCode == Op::OpAtomicFMaxEXT;
}
template <typename T>
inline constexpr bool NodeOpAtomicFMinEXT::is(const T *val)
{
  return val->opCode == Op::OpAtomicFMinEXT;
}
template <typename T>
inline constexpr bool NodeOpAtomicFlagTestAndSet::is(const T *val)
{
  return val->opCode == Op::OpAtomicFlagTestAndSet;
}
template <typename T>
inline constexpr bool NodeOpAtomicIAdd::is(const T *val)
{
  return val->opCode == Op::OpAtomicIAdd;
}
template <typename T>
inline constexpr bool NodeOpAtomicIDecrement::is(const T *val)
{
  return val->opCode == Op::OpAtomicIDecrement;
}
template <typename T>
inline constexpr bool NodeOpAtomicIIncrement::is(const T *val)
{
  return val->opCode == Op::OpAtomicIIncrement;
}
template <typename T>
inline constexpr bool NodeOpAtomicISub::is(const T *val)
{
  return val->opCode == Op::OpAtomicISub;
}
template <typename T>
inline constexpr bool NodeOpAtomicLoad::is(const T *val)
{
  return val->opCode == Op::OpAtomicLoad;
}
template <typename T>
inline constexpr bool NodeOpAtomicOr::is(const T *val)
{
  return val->opCode == Op::OpAtomicOr;
}
template <typename T>
inline constexpr bool NodeOpAtomicSMax::is(const T *val)
{
  return val->opCode == Op::OpAtomicSMax;
}
template <typename T>
inline constexpr bool NodeOpAtomicSMin::is(const T *val)
{
  return val->opCode == Op::OpAtomicSMin;
}
template <typename T>
inline constexpr bool NodeOpAtomicUMax::is(const T *val)
{
  return val->opCode == Op::OpAtomicUMax;
}
template <typename T>
inline constexpr bool NodeOpAtomicUMin::is(const T *val)
{
  return val->opCode == Op::OpAtomicUMin;
}
template <typename T>
inline constexpr bool NodeOpAtomicXor::is(const T *val)
{
  return val->opCode == Op::OpAtomicXor;
}
template <typename T>
inline constexpr bool NodeOpBitCount::is(const T *val)
{
  return val->opCode == Op::OpBitCount;
}
template <typename T>
inline constexpr bool NodeOpBitReverse::is(const T *val)
{
  return val->opCode == Op::OpBitReverse;
}
template <typename T>
inline constexpr bool NodeOpBitcast::is(const T *val)
{
  return val->opCode == Op::OpBitcast;
}
template <typename T>
inline constexpr bool NodeOpColorAttachmentReadEXT::is(const T *val)
{
  return val->opCode == Op::OpColorAttachmentReadEXT;
}
template <typename T>
inline constexpr bool NodeOpCompositeConstructReplicateEXT::is(const T *val)
{
  return val->opCode == Op::OpCompositeConstructReplicateEXT;
}
template <typename T>
inline constexpr bool NodeOpCompositeExtract::is(const T *val)
{
  return val->opCode == Op::OpCompositeExtract;
}
template <typename T>
inline constexpr bool NodeOpConvertBF16ToFINTEL::is(const T *val)
{
  return val->opCode == Op::OpConvertBF16ToFINTEL;
}
template <typename T>
inline constexpr bool NodeOpConvertFToBF16INTEL::is(const T *val)
{
  return val->opCode == Op::OpConvertFToBF16INTEL;
}
template <typename T>
inline constexpr bool NodeOpConvertFToS::is(const T *val)
{
  return val->opCode == Op::OpConvertFToS;
}
template <typename T>
inline constexpr bool NodeOpConvertFToU::is(const T *val)
{
  return val->opCode == Op::OpConvertFToU;
}
template <typename T>
inline constexpr bool NodeOpConvertImageToUNV::is(const T *val)
{
  return val->opCode == Op::OpConvertImageToUNV;
}
template <typename T>
inline constexpr bool NodeOpConvertPtrToU::is(const T *val)
{
  return val->opCode == Op::OpConvertPtrToU;
}
template <typename T>
inline constexpr bool NodeOpConvertSToF::is(const T *val)
{
  return val->opCode == Op::OpConvertSToF;
}
template <typename T>
inline constexpr bool NodeOpConvertSampledImageToUNV::is(const T *val)
{
  return val->opCode == Op::OpConvertSampledImageToUNV;
}
template <typename T>
inline constexpr bool NodeOpConvertSamplerToUNV::is(const T *val)
{
  return val->opCode == Op::OpConvertSamplerToUNV;
}
template <typename T>
inline constexpr bool NodeOpConvertUToAccelerationStructureKHR::is(const T *val)
{
  return val->opCode == Op::OpConvertUToAccelerationStructureKHR;
}
template <typename T>
inline constexpr bool NodeOpConvertUToF::is(const T *val)
{
  return val->opCode == Op::OpConvertUToF;
}
template <typename T>
inline constexpr bool NodeOpConvertUToImageNV::is(const T *val)
{
  return val->opCode == Op::OpConvertUToImageNV;
}
template <typename T>
inline constexpr bool NodeOpConvertUToPtr::is(const T *val)
{
  return val->opCode == Op::OpConvertUToPtr;
}
template <typename T>
inline constexpr bool NodeOpConvertUToSampledImageNV::is(const T *val)
{
  return val->opCode == Op::OpConvertUToSampledImageNV;
}
template <typename T>
inline constexpr bool NodeOpConvertUToSamplerNV::is(const T *val)
{
  return val->opCode == Op::OpConvertUToSamplerNV;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixLengthKHR::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixLengthKHR;
}
template <typename T>
inline constexpr bool NodeOpCooperativeMatrixLengthNV::is(const T *val)
{
  return val->opCode == Op::OpCooperativeMatrixLengthNV;
}
template <typename T>
inline constexpr bool NodeOpCopyLogical::is(const T *val)
{
  return val->opCode == Op::OpCopyLogical;
}
template <typename T>
inline constexpr bool NodeOpCopyObject::is(const T *val)
{
  return val->opCode == Op::OpCopyObject;
}
template <typename T>
inline constexpr bool NodeOpCreatePipeFromPipeStorage::is(const T *val)
{
  return val->opCode == Op::OpCreatePipeFromPipeStorage;
}
template <typename T>
inline constexpr bool NodeOpCrossWorkgroupCastToPtrINTEL::is(const T *val)
{
  return val->opCode == Op::OpCrossWorkgroupCastToPtrINTEL;
}
template <typename T>
inline constexpr bool NodeOpDPdx::is(const T *val)
{
  return val->opCode == Op::OpDPdx;
}
template <typename T>
inline constexpr bool NodeOpDPdxCoarse::is(const T *val)
{
  return val->opCode == Op::OpDPdxCoarse;
}
template <typename T>
inline constexpr bool NodeOpDPdxFine::is(const T *val)
{
  return val->opCode == Op::OpDPdxFine;
}
template <typename T>
inline constexpr bool NodeOpDPdy::is(const T *val)
{
  return val->opCode == Op::OpDPdy;
}
template <typename T>
inline constexpr bool NodeOpDPdyCoarse::is(const T *val)
{
  return val->opCode == Op::OpDPdyCoarse;
}
template <typename T>
inline constexpr bool NodeOpDPdyFine::is(const T *val)
{
  return val->opCode == Op::OpDPdyFine;
}
template <typename T>
inline constexpr bool NodeOpExtInstWithForwardRefsKHR::is(const T *val)
{
  return val->opCode == Op::OpExtInstWithForwardRefsKHR;
}
template <typename T>
inline constexpr bool NodeOpFConvert::is(const T *val)
{
  return val->opCode == Op::OpFConvert;
}
template <typename T>
inline constexpr bool NodeOpFNegate::is(const T *val)
{
  return val->opCode == Op::OpFNegate;
}
template <typename T>
inline constexpr bool NodeOpFinishWritingNodePayloadAMDX::is(const T *val)
{
  return val->opCode == Op::OpFinishWritingNodePayloadAMDX;
}
template <typename T>
inline constexpr bool NodeOpFwidth::is(const T *val)
{
  return val->opCode == Op::OpFwidth;
}
template <typename T>
inline constexpr bool NodeOpFwidthCoarse::is(const T *val)
{
  return val->opCode == Op::OpFwidthCoarse;
}
template <typename T>
inline constexpr bool NodeOpFwidthFine::is(const T *val)
{
  return val->opCode == Op::OpFwidthFine;
}
template <typename T>
inline constexpr bool NodeOpGenericCastToPtr::is(const T *val)
{
  return val->opCode == Op::OpGenericCastToPtr;
}
template <typename T>
inline constexpr bool NodeOpGenericCastToPtrExplicit::is(const T *val)
{
  return val->opCode == Op::OpGenericCastToPtrExplicit;
}
template <typename T>
inline constexpr bool NodeOpGenericPtrMemSemantics::is(const T *val)
{
  return val->opCode == Op::OpGenericPtrMemSemantics;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformPartitionNV::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformPartitionNV;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformQuadAllKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformQuadAllKHR;
}
template <typename T>
inline constexpr bool NodeOpGroupNonUniformQuadAnyKHR::is(const T *val)
{
  return val->opCode == Op::OpGroupNonUniformQuadAnyKHR;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetCurrentTimeNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetCurrentTimeNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetGeometryIndexNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetGeometryIndexNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetHitKindNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetHitKindNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetInstanceCustomIndexNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetInstanceCustomIndexNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetInstanceIdNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetInstanceIdNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetObjectRayDirectionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetObjectRayDirectionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetObjectRayOriginNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetObjectRayOriginNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetObjectToWorldNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetObjectToWorldNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetPrimitiveIndexNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetPrimitiveIndexNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetRayTMaxNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetRayTMaxNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetRayTMinNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetRayTMinNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetShaderBindingTableRecordIndexNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetShaderBindingTableRecordIndexNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetShaderRecordBufferHandleNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetShaderRecordBufferHandleNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetWorldRayDirectionNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetWorldRayDirectionNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetWorldRayOriginNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetWorldRayOriginNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectGetWorldToObjectNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectGetWorldToObjectNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectIsEmptyNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectIsEmptyNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectIsHitNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectIsHitNV;
}
template <typename T>
inline constexpr bool NodeOpHitObjectIsMissNV::is(const T *val)
{
  return val->opCode == Op::OpHitObjectIsMissNV;
}
template <typename T>
inline constexpr bool NodeOpImageSparseTexelsResident::is(const T *val)
{
  return val->opCode == Op::OpImageSparseTexelsResident;
}
template <typename T>
inline constexpr bool NodeOpIsFinite::is(const T *val)
{
  return val->opCode == Op::OpIsFinite;
}
template <typename T>
inline constexpr bool NodeOpIsInf::is(const T *val)
{
  return val->opCode == Op::OpIsInf;
}
template <typename T>
inline constexpr bool NodeOpIsNan::is(const T *val)
{
  return val->opCode == Op::OpIsNan;
}
template <typename T>
inline constexpr bool NodeOpIsNormal::is(const T *val)
{
  return val->opCode == Op::OpIsNormal;
}
template <typename T>
inline constexpr bool NodeOpIsValidEvent::is(const T *val)
{
  return val->opCode == Op::OpIsValidEvent;
}
template <typename T>
inline constexpr bool NodeOpIsValidReserveId::is(const T *val)
{
  return val->opCode == Op::OpIsValidReserveId;
}
template <typename T>
inline constexpr bool NodeOpLoad::is(const T *val)
{
  return val->opCode == Op::OpLoad;
}
template <typename T>
inline constexpr bool NodeOpLogicalNot::is(const T *val)
{
  return val->opCode == Op::OpLogicalNot;
}
template <typename T>
inline constexpr bool NodeOpMaskedGatherINTEL::is(const T *val)
{
  return val->opCode == Op::OpMaskedGatherINTEL;
}
template <typename T>
inline constexpr bool NodeOpNamedBarrierInitialize::is(const T *val)
{
  return val->opCode == Op::OpNamedBarrierInitialize;
}
template <typename T>
inline constexpr bool NodeOpNot::is(const T *val)
{
  return val->opCode == Op::OpNot;
}
template <typename T>
inline constexpr bool NodeOpPtrCastToCrossWorkgroupINTEL::is(const T *val)
{
  return val->opCode == Op::OpPtrCastToCrossWorkgroupINTEL;
}
template <typename T>
inline constexpr bool NodeOpPtrCastToGeneric::is(const T *val)
{
  return val->opCode == Op::OpPtrCastToGeneric;
}
template <typename T>
inline constexpr bool NodeOpQuantizeToF16::is(const T *val)
{
  return val->opCode == Op::OpQuantizeToF16;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetIntersectionCandidateAABBOpaqueKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetIntersectionCandidateAABBOpaqueKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetRayFlagsKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetRayFlagsKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetRayTMinKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetRayTMinKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetWorldRayDirectionKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetWorldRayDirectionKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryGetWorldRayOriginKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryGetWorldRayOriginKHR;
}
template <typename T>
inline constexpr bool NodeOpRayQueryProceedKHR::is(const T *val)
{
  return val->opCode == Op::OpRayQueryProceedKHR;
}
template <typename T>
inline constexpr bool NodeOpSConvert::is(const T *val)
{
  return val->opCode == Op::OpSConvert;
}
template <typename T>
inline constexpr bool NodeOpSNegate::is(const T *val)
{
  return val->opCode == Op::OpSNegate;
}
template <typename T>
inline constexpr bool NodeOpSatConvertSToU::is(const T *val)
{
  return val->opCode == Op::OpSatConvertSToU;
}
template <typename T>
inline constexpr bool NodeOpSatConvertUToS::is(const T *val)
{
  return val->opCode == Op::OpSatConvertUToS;
}
template <typename T>
inline constexpr bool NodeOpSignBitSet::is(const T *val)
{
  return val->opCode == Op::OpSignBitSet;
}
template <typename T>
inline constexpr bool NodeOpSizeOf::is(const T *val)
{
  return val->opCode == Op::OpSizeOf;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAllEqualKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAllEqualKHR;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAllKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAllKHR;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAnyKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAnyKHR;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeConvertToMcePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeConvertToMcePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeConvertToMceResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeConvertToMceResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetDualReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetDualReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetSingleReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetSingleReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetTruncatedSearchIndicationINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetTruncatedSearchIndicationINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeSetUnidirectionalMixDisableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeSetUnidirectionalMixDisableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeStripDualReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeStripDualReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcImeStripSingleReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcImeStripSingleReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToImePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToImePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToImeResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToImeResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToRefPayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToRefPayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToRefResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToRefResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToSicPayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToSicPayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceConvertToSicResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceConvertToSicResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetBestInterDistortionsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetBestInterDistortionsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterDirectionsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterDirectionsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterDistortionsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterDistortionsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterMajorShapeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterMajorShapeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterMinorShapeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterMinorShapeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterMotionVectorCountINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterMotionVectorCountINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetInterReferenceIdsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetInterReferenceIdsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceGetMotionVectorsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceGetMotionVectorsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcMceSetAcOnlyHaarINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcMceSetAcOnlyHaarINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefConvertToMcePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefConvertToMcePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefConvertToMceResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefConvertToMceResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefSetBidirectionalMixDisableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefSetBidirectionalMixDisableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcRefSetBilinearFilterEnableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcRefSetBilinearFilterEnableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicConvertToMcePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicConvertToMcePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicConvertToMceResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicConvertToMceResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetBestIpeChromaDistortionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetBestIpeChromaDistortionINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetBestIpeLumaDistortionINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetBestIpeLumaDistortionINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetInterRawSadsINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetInterRawSadsINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetIpeChromaModeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetIpeChromaModeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetIpeLumaShapeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetIpeLumaShapeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetPackedIpeLumaModesINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetPackedIpeLumaModesINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicInitializeINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicInitializeINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupAvcSicSetBilinearFilterEnableINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupAvcSicSetBilinearFilterEnableINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupBallotKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupBallotKHR;
}
template <typename T>
inline constexpr bool NodeOpSubgroupBlockReadINTEL::is(const T *val)
{
  return val->opCode == Op::OpSubgroupBlockReadINTEL;
}
template <typename T>
inline constexpr bool NodeOpSubgroupFirstInvocationKHR::is(const T *val)
{
  return val->opCode == Op::OpSubgroupFirstInvocationKHR;
}
template <typename T>
inline constexpr bool NodeOpTranspose::is(const T *val)
{
  return val->opCode == Op::OpTranspose;
}
template <typename T>
inline constexpr bool NodeOpUConvert::is(const T *val)
{
  return val->opCode == Op::OpUConvert;
}
template <typename T>
inline constexpr bool NodeOpUCountLeadingZerosINTEL::is(const T *val)
{
  return val->opCode == Op::OpUCountLeadingZerosINTEL;
}
template <typename T>
inline constexpr bool NodeOpUCountTrailingZerosINTEL::is(const T *val)
{
  return val->opCode == Op::OpUCountTrailingZerosINTEL;
}
template <typename T>
inline constexpr bool NodeOpVariableLengthArrayINTEL::is(const T *val)
{
  return val->opCode == Op::OpVariableLengthArrayINTEL;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackDouble2x32::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackDouble2x32;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackHalf2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackHalf2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackSnorm2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackSnorm2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackSnorm4x8::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackSnorm4x8;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackUnorm2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackUnorm2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450PackUnorm4x8::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::PackUnorm4x8;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Radians::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Radians;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Round::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Round;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450RoundEven::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::RoundEven;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SAbs::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SAbs;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450SSign::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::SSign;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Sin::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Sin;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Sinh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Sinh;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Sqrt::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Sqrt;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Tan::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Tan;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Tanh::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Tanh;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450Trunc::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::Trunc;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackDouble2x32::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackDouble2x32;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackHalf2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackHalf2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackSnorm2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackSnorm2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackSnorm4x8::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackSnorm4x8;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackUnorm2x16::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackUnorm2x16;
}
template <typename T>
inline constexpr bool NodeOpGLSLstd450UnpackUnorm4x8::is(const T *val)
{
  return val->opCode == Op::OpExtInst && val->grammarId == ExtendedGrammar::GLSL_std_450 &&
         static_cast<GLSLstd450>(val->extOpCode) == GLSLstd450::UnpackUnorm4x8;
}
template <typename T>
inline constexpr bool NodeVariable::is(const T *val)
{
  return val->nodeKind == NodeKind::Variable;
}
template <typename T>
inline constexpr bool NodeOpAccessChain::is(const T *val)
{
  return val->opCode == Op::OpAccessChain;
}
template <typename T>
inline constexpr bool NodeOpFunctionParameter::is(const T *val)
{
  return val->opCode == Op::OpFunctionParameter;
}
template <typename T>
inline constexpr bool NodeOpImageTexelPointer::is(const T *val)
{
  return val->opCode == Op::OpImageTexelPointer;
}
template <typename T>
inline constexpr bool NodeOpInBoundsAccessChain::is(const T *val)
{
  return val->opCode == Op::OpInBoundsAccessChain;
}
template <typename T>
inline constexpr bool NodeOpInBoundsPtrAccessChain::is(const T *val)
{
  return val->opCode == Op::OpInBoundsPtrAccessChain;
}
template <typename T>
inline constexpr bool NodeOpPtrAccessChain::is(const T *val)
{
  return val->opCode == Op::OpPtrAccessChain;
}
template <typename T>
inline constexpr bool NodeOpVariable::is(const T *val)
{
  return val->opCode == Op::OpVariable;
}
template <typename T>
inline constexpr bool NodeTypedef::is(const T *val)
{
  return val->nodeKind == NodeKind::Typedef;
}
template <typename T>
inline constexpr bool NodeOpTypeAccelerationStructureKHR::is(const T *val)
{
  return val->opCode == Op::OpTypeAccelerationStructureKHR;
}
template <typename T>
inline constexpr bool NodeOpTypeAccelerationStructureNV::is(const T *val)
{
  return val->opCode == Op::OpTypeAccelerationStructureNV;
}
template <typename T>
inline constexpr bool NodeOpTypeArray::is(const T *val)
{
  return val->opCode == Op::OpTypeArray;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImeDualReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImeDualReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImeResultDualReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImeResultDualReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImeResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImeResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImeResultSingleReferenceStreamoutINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImeResultSingleReferenceStreamoutINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcImeSingleReferenceStreaminINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcImeSingleReferenceStreaminINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcMcePayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcMcePayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcMceResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcMceResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcRefPayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcRefPayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcRefResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcRefResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcSicPayloadINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcSicPayloadINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeAvcSicResultINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeAvcSicResultINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeBool::is(const T *val)
{
  return val->opCode == Op::OpTypeBool;
}
template <typename T>
inline constexpr bool NodeOpTypeBufferSurfaceINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeBufferSurfaceINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeCooperativeMatrixKHR::is(const T *val)
{
  return val->opCode == Op::OpTypeCooperativeMatrixKHR;
}
template <typename T>
inline constexpr bool NodeOpTypeCooperativeMatrixNV::is(const T *val)
{
  return val->opCode == Op::OpTypeCooperativeMatrixNV;
}
template <typename T>
inline constexpr bool NodeOpTypeDeviceEvent::is(const T *val)
{
  return val->opCode == Op::OpTypeDeviceEvent;
}
template <typename T>
inline constexpr bool NodeOpTypeEvent::is(const T *val)
{
  return val->opCode == Op::OpTypeEvent;
}
template <typename T>
inline constexpr bool NodeOpTypeFloat::is(const T *val)
{
  return val->opCode == Op::OpTypeFloat;
}
template <typename T>
inline constexpr bool NodeOpTypeFunction::is(const T *val)
{
  return val->opCode == Op::OpTypeFunction;
}
template <typename T>
inline constexpr bool NodeOpTypeHitObjectNV::is(const T *val)
{
  return val->opCode == Op::OpTypeHitObjectNV;
}
template <typename T>
inline constexpr bool NodeOpTypeImage::is(const T *val)
{
  return val->opCode == Op::OpTypeImage;
}
template <typename T>
inline constexpr bool NodeOpTypeInt::is(const T *val)
{
  return val->opCode == Op::OpTypeInt;
}
template <typename T>
inline constexpr bool NodeOpTypeMatrix::is(const T *val)
{
  return val->opCode == Op::OpTypeMatrix;
}
template <typename T>
inline constexpr bool NodeOpTypeNamedBarrier::is(const T *val)
{
  return val->opCode == Op::OpTypeNamedBarrier;
}
template <typename T>
inline constexpr bool NodeOpTypeOpaque::is(const T *val)
{
  return val->opCode == Op::OpTypeOpaque;
}
template <typename T>
inline constexpr bool NodeOpTypePipe::is(const T *val)
{
  return val->opCode == Op::OpTypePipe;
}
template <typename T>
inline constexpr bool NodeOpTypePipeStorage::is(const T *val)
{
  return val->opCode == Op::OpTypePipeStorage;
}
template <typename T>
inline constexpr bool NodeOpTypePointer::is(const T *val)
{
  return val->opCode == Op::OpTypePointer;
}
template <typename T>
inline constexpr bool NodeOpTypeQueue::is(const T *val)
{
  return val->opCode == Op::OpTypeQueue;
}
template <typename T>
inline constexpr bool NodeOpTypeRayQueryKHR::is(const T *val)
{
  return val->opCode == Op::OpTypeRayQueryKHR;
}
template <typename T>
inline constexpr bool NodeOpTypeReserveId::is(const T *val)
{
  return val->opCode == Op::OpTypeReserveId;
}
template <typename T>
inline constexpr bool NodeOpTypeRuntimeArray::is(const T *val)
{
  return val->opCode == Op::OpTypeRuntimeArray;
}
template <typename T>
inline constexpr bool NodeOpTypeSampledImage::is(const T *val)
{
  return val->opCode == Op::OpTypeSampledImage;
}
template <typename T>
inline constexpr bool NodeOpTypeSampler::is(const T *val)
{
  return val->opCode == Op::OpTypeSampler;
}
template <typename T>
inline constexpr bool NodeOpTypeStruct::is(const T *val)
{
  return val->opCode == Op::OpTypeStruct;
}
template <typename T>
inline constexpr bool NodeOpTypeVector::is(const T *val)
{
  return val->opCode == Op::OpTypeVector;
}
template <typename T>
inline constexpr bool NodeOpTypeVmeImageINTEL::is(const T *val)
{
  return val->opCode == Op::OpTypeVmeImageINTEL;
}
template <typename T>
inline constexpr bool NodeOpTypeVoid::is(const T *val)
{
  return val->opCode == Op::OpTypeVoid;
}
// property visitor
template <typename T, typename U>
inline auto visitProperty(T *p, U u)
{
  switch (p->type)
  {
    case Decoration::RelaxedPrecision: return u(reinterpret_cast<PropertyRelaxedPrecision *>(p));
    case Decoration::SpecId: return u(reinterpret_cast<PropertySpecId *>(p));
    case Decoration::Block: return u(reinterpret_cast<PropertyBlock *>(p));
    case Decoration::BufferBlock: return u(reinterpret_cast<PropertyBufferBlock *>(p));
    case Decoration::RowMajor: return u(reinterpret_cast<PropertyRowMajor *>(p));
    case Decoration::ColMajor: return u(reinterpret_cast<PropertyColMajor *>(p));
    case Decoration::ArrayStride: return u(reinterpret_cast<PropertyArrayStride *>(p));
    case Decoration::MatrixStride: return u(reinterpret_cast<PropertyMatrixStride *>(p));
    case Decoration::GLSLShared: return u(reinterpret_cast<PropertyGLSLShared *>(p));
    case Decoration::GLSLPacked: return u(reinterpret_cast<PropertyGLSLPacked *>(p));
    case Decoration::CPacked: return u(reinterpret_cast<PropertyCPacked *>(p));
    case Decoration::BuiltIn: return u(reinterpret_cast<PropertyBuiltIn *>(p));
    case Decoration::NoPerspective: return u(reinterpret_cast<PropertyNoPerspective *>(p));
    case Decoration::Flat: return u(reinterpret_cast<PropertyFlat *>(p));
    case Decoration::Patch: return u(reinterpret_cast<PropertyPatch *>(p));
    case Decoration::Centroid: return u(reinterpret_cast<PropertyCentroid *>(p));
    case Decoration::Sample: return u(reinterpret_cast<PropertySample *>(p));
    case Decoration::Invariant: return u(reinterpret_cast<PropertyInvariant *>(p));
    case Decoration::Restrict: return u(reinterpret_cast<PropertyRestrict *>(p));
    case Decoration::Aliased: return u(reinterpret_cast<PropertyAliased *>(p));
    case Decoration::Volatile: return u(reinterpret_cast<PropertyVolatile *>(p));
    case Decoration::Constant: return u(reinterpret_cast<PropertyConstant *>(p));
    case Decoration::Coherent: return u(reinterpret_cast<PropertyCoherent *>(p));
    case Decoration::NonWritable: return u(reinterpret_cast<PropertyNonWritable *>(p));
    case Decoration::NonReadable: return u(reinterpret_cast<PropertyNonReadable *>(p));
    case Decoration::Uniform: return u(reinterpret_cast<PropertyUniform *>(p));
    case Decoration::UniformId: return u(reinterpret_cast<PropertyUniformId *>(p));
    case Decoration::SaturatedConversion: return u(reinterpret_cast<PropertySaturatedConversion *>(p));
    case Decoration::Stream: return u(reinterpret_cast<PropertyStream *>(p));
    case Decoration::Location: return u(reinterpret_cast<PropertyLocation *>(p));
    case Decoration::Component: return u(reinterpret_cast<PropertyComponent *>(p));
    case Decoration::Index: return u(reinterpret_cast<PropertyIndex *>(p));
    case Decoration::Binding: return u(reinterpret_cast<PropertyBinding *>(p));
    case Decoration::DescriptorSet: return u(reinterpret_cast<PropertyDescriptorSet *>(p));
    case Decoration::Offset: return u(reinterpret_cast<PropertyOffset *>(p));
    case Decoration::XfbBuffer: return u(reinterpret_cast<PropertyXfbBuffer *>(p));
    case Decoration::XfbStride: return u(reinterpret_cast<PropertyXfbStride *>(p));
    case Decoration::FuncParamAttr: return u(reinterpret_cast<PropertyFuncParamAttr *>(p));
    case Decoration::FPRoundingMode: return u(reinterpret_cast<PropertyFPRoundingMode *>(p));
    case Decoration::FPFastMathMode: return u(reinterpret_cast<PropertyFPFastMathMode *>(p));
    case Decoration::LinkageAttributes: return u(reinterpret_cast<PropertyLinkageAttributes *>(p));
    case Decoration::NoContraction: return u(reinterpret_cast<PropertyNoContraction *>(p));
    case Decoration::InputAttachmentIndex: return u(reinterpret_cast<PropertyInputAttachmentIndex *>(p));
    case Decoration::Alignment: return u(reinterpret_cast<PropertyAlignment *>(p));
    case Decoration::MaxByteOffset: return u(reinterpret_cast<PropertyMaxByteOffset *>(p));
    case Decoration::AlignmentId: return u(reinterpret_cast<PropertyAlignmentId *>(p));
    case Decoration::MaxByteOffsetId: return u(reinterpret_cast<PropertyMaxByteOffsetId *>(p));
    case Decoration::NoSignedWrap: return u(reinterpret_cast<PropertyNoSignedWrap *>(p));
    case Decoration::NoUnsignedWrap: return u(reinterpret_cast<PropertyNoUnsignedWrap *>(p));
    case Decoration::WeightTextureQCOM: return u(reinterpret_cast<PropertyWeightTextureQCOM *>(p));
    case Decoration::BlockMatchTextureQCOM: return u(reinterpret_cast<PropertyBlockMatchTextureQCOM *>(p));
    case Decoration::BlockMatchSamplerQCOM: return u(reinterpret_cast<PropertyBlockMatchSamplerQCOM *>(p));
    case Decoration::ExplicitInterpAMD: return u(reinterpret_cast<PropertyExplicitInterpAMD *>(p));
    case Decoration::NodeSharesPayloadLimitsWithAMDX: return u(reinterpret_cast<PropertyNodeSharesPayloadLimitsWithAMDX *>(p));
    case Decoration::NodeMaxPayloadsAMDX: return u(reinterpret_cast<PropertyNodeMaxPayloadsAMDX *>(p));
    case Decoration::TrackFinishWritingAMDX: return u(reinterpret_cast<PropertyTrackFinishWritingAMDX *>(p));
    case Decoration::PayloadNodeNameAMDX: return u(reinterpret_cast<PropertyPayloadNodeNameAMDX *>(p));
    case Decoration::OverrideCoverageNV: return u(reinterpret_cast<PropertyOverrideCoverageNV *>(p));
    case Decoration::PassthroughNV: return u(reinterpret_cast<PropertyPassthroughNV *>(p));
    case Decoration::ViewportRelativeNV: return u(reinterpret_cast<PropertyViewportRelativeNV *>(p));
    case Decoration::SecondaryViewportRelativeNV: return u(reinterpret_cast<PropertySecondaryViewportRelativeNV *>(p));
    case Decoration::PerPrimitiveEXT: return u(reinterpret_cast<PropertyPerPrimitiveEXT *>(p));
    case Decoration::PerViewNV: return u(reinterpret_cast<PropertyPerViewNV *>(p));
    case Decoration::PerTaskNV: return u(reinterpret_cast<PropertyPerTaskNV *>(p));
    case Decoration::PerVertexKHR: return u(reinterpret_cast<PropertyPerVertexKHR *>(p));
    case Decoration::NonUniform: return u(reinterpret_cast<PropertyNonUniform *>(p));
    case Decoration::RestrictPointer: return u(reinterpret_cast<PropertyRestrictPointer *>(p));
    case Decoration::AliasedPointer: return u(reinterpret_cast<PropertyAliasedPointer *>(p));
    case Decoration::HitObjectShaderRecordBufferNV: return u(reinterpret_cast<PropertyHitObjectShaderRecordBufferNV *>(p));
    case Decoration::BindlessSamplerNV: return u(reinterpret_cast<PropertyBindlessSamplerNV *>(p));
    case Decoration::BindlessImageNV: return u(reinterpret_cast<PropertyBindlessImageNV *>(p));
    case Decoration::BoundSamplerNV: return u(reinterpret_cast<PropertyBoundSamplerNV *>(p));
    case Decoration::BoundImageNV: return u(reinterpret_cast<PropertyBoundImageNV *>(p));
    case Decoration::SIMTCallINTEL: return u(reinterpret_cast<PropertySIMTCallINTEL *>(p));
    case Decoration::ReferencedIndirectlyINTEL: return u(reinterpret_cast<PropertyReferencedIndirectlyINTEL *>(p));
    case Decoration::ClobberINTEL: return u(reinterpret_cast<PropertyClobberINTEL *>(p));
    case Decoration::SideEffectsINTEL: return u(reinterpret_cast<PropertySideEffectsINTEL *>(p));
    case Decoration::VectorComputeVariableINTEL: return u(reinterpret_cast<PropertyVectorComputeVariableINTEL *>(p));
    case Decoration::FuncParamIOKindINTEL: return u(reinterpret_cast<PropertyFuncParamIOKindINTEL *>(p));
    case Decoration::VectorComputeFunctionINTEL: return u(reinterpret_cast<PropertyVectorComputeFunctionINTEL *>(p));
    case Decoration::StackCallINTEL: return u(reinterpret_cast<PropertyStackCallINTEL *>(p));
    case Decoration::GlobalVariableOffsetINTEL: return u(reinterpret_cast<PropertyGlobalVariableOffsetINTEL *>(p));
    case Decoration::CounterBuffer: return u(reinterpret_cast<PropertyCounterBuffer *>(p));
    case Decoration::UserSemantic: return u(reinterpret_cast<PropertyUserSemantic *>(p));
    case Decoration::UserTypeGOOGLE: return u(reinterpret_cast<PropertyUserTypeGOOGLE *>(p));
    case Decoration::FunctionRoundingModeINTEL: return u(reinterpret_cast<PropertyFunctionRoundingModeINTEL *>(p));
    case Decoration::FunctionDenormModeINTEL: return u(reinterpret_cast<PropertyFunctionDenormModeINTEL *>(p));
    case Decoration::RegisterINTEL: return u(reinterpret_cast<PropertyRegisterINTEL *>(p));
    case Decoration::MemoryINTEL: return u(reinterpret_cast<PropertyMemoryINTEL *>(p));
    case Decoration::NumbanksINTEL: return u(reinterpret_cast<PropertyNumbanksINTEL *>(p));
    case Decoration::BankwidthINTEL: return u(reinterpret_cast<PropertyBankwidthINTEL *>(p));
    case Decoration::MaxPrivateCopiesINTEL: return u(reinterpret_cast<PropertyMaxPrivateCopiesINTEL *>(p));
    case Decoration::SinglepumpINTEL: return u(reinterpret_cast<PropertySinglepumpINTEL *>(p));
    case Decoration::DoublepumpINTEL: return u(reinterpret_cast<PropertyDoublepumpINTEL *>(p));
    case Decoration::MaxReplicatesINTEL: return u(reinterpret_cast<PropertyMaxReplicatesINTEL *>(p));
    case Decoration::SimpleDualPortINTEL: return u(reinterpret_cast<PropertySimpleDualPortINTEL *>(p));
    case Decoration::MergeINTEL: return u(reinterpret_cast<PropertyMergeINTEL *>(p));
    case Decoration::BankBitsINTEL: return u(reinterpret_cast<PropertyBankBitsINTEL *>(p));
    case Decoration::ForcePow2DepthINTEL: return u(reinterpret_cast<PropertyForcePow2DepthINTEL *>(p));
    case Decoration::StridesizeINTEL: return u(reinterpret_cast<PropertyStridesizeINTEL *>(p));
    case Decoration::WordsizeINTEL: return u(reinterpret_cast<PropertyWordsizeINTEL *>(p));
    case Decoration::TrueDualPortINTEL: return u(reinterpret_cast<PropertyTrueDualPortINTEL *>(p));
    case Decoration::BurstCoalesceINTEL: return u(reinterpret_cast<PropertyBurstCoalesceINTEL *>(p));
    case Decoration::CacheSizeINTEL: return u(reinterpret_cast<PropertyCacheSizeINTEL *>(p));
    case Decoration::DontStaticallyCoalesceINTEL: return u(reinterpret_cast<PropertyDontStaticallyCoalesceINTEL *>(p));
    case Decoration::PrefetchINTEL: return u(reinterpret_cast<PropertyPrefetchINTEL *>(p));
    case Decoration::StallEnableINTEL: return u(reinterpret_cast<PropertyStallEnableINTEL *>(p));
    case Decoration::FuseLoopsInFunctionINTEL: return u(reinterpret_cast<PropertyFuseLoopsInFunctionINTEL *>(p));
    case Decoration::MathOpDSPModeINTEL: return u(reinterpret_cast<PropertyMathOpDSPModeINTEL *>(p));
    case Decoration::AliasScopeINTEL: return u(reinterpret_cast<PropertyAliasScopeINTEL *>(p));
    case Decoration::NoAliasINTEL: return u(reinterpret_cast<PropertyNoAliasINTEL *>(p));
    case Decoration::InitiationIntervalINTEL: return u(reinterpret_cast<PropertyInitiationIntervalINTEL *>(p));
    case Decoration::MaxConcurrencyINTEL: return u(reinterpret_cast<PropertyMaxConcurrencyINTEL *>(p));
    case Decoration::PipelineEnableINTEL: return u(reinterpret_cast<PropertyPipelineEnableINTEL *>(p));
    case Decoration::BufferLocationINTEL: return u(reinterpret_cast<PropertyBufferLocationINTEL *>(p));
    case Decoration::IOPipeStorageINTEL: return u(reinterpret_cast<PropertyIOPipeStorageINTEL *>(p));
    case Decoration::FunctionFloatingPointModeINTEL: return u(reinterpret_cast<PropertyFunctionFloatingPointModeINTEL *>(p));
    case Decoration::SingleElementVectorINTEL: return u(reinterpret_cast<PropertySingleElementVectorINTEL *>(p));
    case Decoration::VectorComputeCallableFunctionINTEL: return u(reinterpret_cast<PropertyVectorComputeCallableFunctionINTEL *>(p));
    case Decoration::MediaBlockIOINTEL: return u(reinterpret_cast<PropertyMediaBlockIOINTEL *>(p));
    case Decoration::StallFreeINTEL: return u(reinterpret_cast<PropertyStallFreeINTEL *>(p));
    case Decoration::FPMaxErrorDecorationINTEL: return u(reinterpret_cast<PropertyFPMaxErrorDecorationINTEL *>(p));
    case Decoration::LatencyControlLabelINTEL: return u(reinterpret_cast<PropertyLatencyControlLabelINTEL *>(p));
    case Decoration::LatencyControlConstraintINTEL: return u(reinterpret_cast<PropertyLatencyControlConstraintINTEL *>(p));
    case Decoration::ConduitKernelArgumentINTEL: return u(reinterpret_cast<PropertyConduitKernelArgumentINTEL *>(p));
    case Decoration::RegisterMapKernelArgumentINTEL: return u(reinterpret_cast<PropertyRegisterMapKernelArgumentINTEL *>(p));
    case Decoration::MMHostInterfaceAddressWidthINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceAddressWidthINTEL *>(p));
    case Decoration::MMHostInterfaceDataWidthINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceDataWidthINTEL *>(p));
    case Decoration::MMHostInterfaceLatencyINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceLatencyINTEL *>(p));
    case Decoration::MMHostInterfaceReadWriteModeINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceReadWriteModeINTEL *>(p));
    case Decoration::MMHostInterfaceMaxBurstINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceMaxBurstINTEL *>(p));
    case Decoration::MMHostInterfaceWaitRequestINTEL: return u(reinterpret_cast<PropertyMMHostInterfaceWaitRequestINTEL *>(p));
    case Decoration::StableKernelArgumentINTEL: return u(reinterpret_cast<PropertyStableKernelArgumentINTEL *>(p));
    case Decoration::HostAccessINTEL: return u(reinterpret_cast<PropertyHostAccessINTEL *>(p));
    case Decoration::InitModeINTEL: return u(reinterpret_cast<PropertyInitModeINTEL *>(p));
    case Decoration::ImplementInRegisterMapINTEL: return u(reinterpret_cast<PropertyImplementInRegisterMapINTEL *>(p));
    case Decoration::CacheControlLoadINTEL: return u(reinterpret_cast<PropertyCacheControlLoadINTEL *>(p));
    case Decoration::CacheControlStoreINTEL: return u(reinterpret_cast<PropertyCacheControlStoreINTEL *>(p));
  }
  if (p->type == DecorationName)
  {
    return u(reinterpret_cast<PropertyName *>(p));
  }
  if (p->type == DecorationForwardDeclaration)
  {
    return u(reinterpret_cast<PropertyForwardDeclaration *>(p));
  }
  if (p->type == DecorationSelectionMerge)
  {
    return u(reinterpret_cast<PropertySelectionMerge *>(p));
  }
  if (p->type == DecorationLoopMerge)
  {
    return u(reinterpret_cast<PorpertyLoopMerge *>(p));
  }
  return detail::make_default<decltype(u(reinterpret_cast<PorpertyLoopMerge *>(p)))>();
}
template <typename T, typename U>
inline auto visitProperty(const CastableUniquePointer<T> &p, U u)
{
  return visitProperty(p.get(), u);
}
template <typename T, typename U>
inline auto visitProperty(CastableUniquePointer<T> &p, U u)
{
  return visitProperty(p.get(), u);
}
// property writes
template <typename N, typename T>
void PropertyName::write(N node, T &target) const
{
  auto nameLen = (name.length() + sizeof(unsigned)) / sizeof(unsigned);
  if (memberIndex)
  {
    target.beginInstruction(Op::OpMemberName, 2 + nameLen);
    target.writeWord(node->resultId);
    target.writeWord(*memberIndex);
  }
  else
  {
    target.beginInstruction(Op::OpName, 1 + nameLen);
    target.writeWord(node->resultId);
  }
  target.writeString(name.c_str());
  target.endWrite();
}
template <typename N, typename T>
void PropertyForwardDeclaration::write(N node, T &target) const
{
  target.beginInstruction(Op::OpTypeForwardPointer, 2);
  target.writeWord(node->resultId);
  target.writeWord(static_cast<unsigned>(as<NodeOpTypePointer>(node)->storageClass));
  target.endWrite();
}
template <typename N, typename T>
void PropertySelectionMerge::write(N, T &target) const
{
  target.beginInstruction(Op::OpSelectionMerge, 2);
  target.writeWord(mergeBlock->resultId);
  target.writeWord(static_cast<unsigned>(controlMask));
  target.endWrite();
}
template <typename N, typename T>
void PorpertyLoopMerge::write(N, T &target) const
{
  target.beginInstruction(Op::OpLoopMerge, 3 + (bool(controlMask & LoopControlMask::DependencyLength) ? 1 : 0));
  target.writeWord(mergeBlock->resultId);
  target.writeWord(continueBlock->resultId);
  target.writeWord(static_cast<unsigned>(controlMask));
  if (bool(controlMask & LoopControlMask::DependencyLength))
    target.writeWord(static_cast<unsigned>(dependencyLength.value));
  target.endWrite();
}
// execution mode infos
struct ExecutionModeBase
{
  const ExecutionMode mode;
  template <typename T>
  static constexpr bool is(const T *)
  {
    return true;
  }

protected:
  ExecutionModeBase(ExecutionMode m) : mode{m} {}
};
struct ExecutionModeInvocations : ExecutionModeBase
{
  LiteralInteger numberOfInvocationInvocations;
  ExecutionModeInvocations() : ExecutionModeBase(ExecutionMode::Invocations) {}
  ~ExecutionModeInvocations() = default;
  ExecutionModeInvocations(LiteralInteger number_of_invocation_invocations) : ExecutionModeBase(ExecutionMode::Invocations)
  {
    numberOfInvocationInvocations = number_of_invocation_invocations;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Invocations;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSpacingEqual : ExecutionModeBase
{
  ExecutionModeSpacingEqual() : ExecutionModeBase(ExecutionMode::SpacingEqual) {}
  ~ExecutionModeSpacingEqual() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SpacingEqual;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSpacingFractionalEven : ExecutionModeBase
{
  ExecutionModeSpacingFractionalEven() : ExecutionModeBase(ExecutionMode::SpacingFractionalEven) {}
  ~ExecutionModeSpacingFractionalEven() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SpacingFractionalEven;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSpacingFractionalOdd : ExecutionModeBase
{
  ExecutionModeSpacingFractionalOdd() : ExecutionModeBase(ExecutionMode::SpacingFractionalOdd) {}
  ~ExecutionModeSpacingFractionalOdd() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SpacingFractionalOdd;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeVertexOrderCw : ExecutionModeBase
{
  ExecutionModeVertexOrderCw() : ExecutionModeBase(ExecutionMode::VertexOrderCw) {}
  ~ExecutionModeVertexOrderCw() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::VertexOrderCw;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeVertexOrderCcw : ExecutionModeBase
{
  ExecutionModeVertexOrderCcw() : ExecutionModeBase(ExecutionMode::VertexOrderCcw) {}
  ~ExecutionModeVertexOrderCcw() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::VertexOrderCcw;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModePixelCenterInteger : ExecutionModeBase
{
  ExecutionModePixelCenterInteger() : ExecutionModeBase(ExecutionMode::PixelCenterInteger) {}
  ~ExecutionModePixelCenterInteger() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::PixelCenterInteger;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOriginUpperLeft : ExecutionModeBase
{
  ExecutionModeOriginUpperLeft() : ExecutionModeBase(ExecutionMode::OriginUpperLeft) {}
  ~ExecutionModeOriginUpperLeft() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OriginUpperLeft;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOriginLowerLeft : ExecutionModeBase
{
  ExecutionModeOriginLowerLeft() : ExecutionModeBase(ExecutionMode::OriginLowerLeft) {}
  ~ExecutionModeOriginLowerLeft() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OriginLowerLeft;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeEarlyFragmentTests : ExecutionModeBase
{
  ExecutionModeEarlyFragmentTests() : ExecutionModeBase(ExecutionMode::EarlyFragmentTests) {}
  ~ExecutionModeEarlyFragmentTests() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::EarlyFragmentTests;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModePointMode : ExecutionModeBase
{
  ExecutionModePointMode() : ExecutionModeBase(ExecutionMode::PointMode) {}
  ~ExecutionModePointMode() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::PointMode;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeXfb : ExecutionModeBase
{
  ExecutionModeXfb() : ExecutionModeBase(ExecutionMode::Xfb) {}
  ~ExecutionModeXfb() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Xfb;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDepthReplacing : ExecutionModeBase
{
  ExecutionModeDepthReplacing() : ExecutionModeBase(ExecutionMode::DepthReplacing) {}
  ~ExecutionModeDepthReplacing() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DepthReplacing;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDepthGreater : ExecutionModeBase
{
  ExecutionModeDepthGreater() : ExecutionModeBase(ExecutionMode::DepthGreater) {}
  ~ExecutionModeDepthGreater() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DepthGreater;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDepthLess : ExecutionModeBase
{
  ExecutionModeDepthLess() : ExecutionModeBase(ExecutionMode::DepthLess) {}
  ~ExecutionModeDepthLess() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DepthLess;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDepthUnchanged : ExecutionModeBase
{
  ExecutionModeDepthUnchanged() : ExecutionModeBase(ExecutionMode::DepthUnchanged) {}
  ~ExecutionModeDepthUnchanged() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DepthUnchanged;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeLocalSize : ExecutionModeBase
{
  LiteralInteger xSize;
  LiteralInteger ySize;
  LiteralInteger zSize;
  ExecutionModeLocalSize() : ExecutionModeBase(ExecutionMode::LocalSize) {}
  ~ExecutionModeLocalSize() = default;
  ExecutionModeLocalSize(LiteralInteger x_size, LiteralInteger y_size, LiteralInteger z_size) :
    ExecutionModeBase(ExecutionMode::LocalSize)
  {
    xSize = x_size;
    ySize = y_size;
    zSize = z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::LocalSize;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeLocalSizeHint : ExecutionModeBase
{
  LiteralInteger xSize;
  LiteralInteger ySize;
  LiteralInteger zSize;
  ExecutionModeLocalSizeHint() : ExecutionModeBase(ExecutionMode::LocalSizeHint) {}
  ~ExecutionModeLocalSizeHint() = default;
  ExecutionModeLocalSizeHint(LiteralInteger x_size, LiteralInteger y_size, LiteralInteger z_size) :
    ExecutionModeBase(ExecutionMode::LocalSizeHint)
  {
    xSize = x_size;
    ySize = y_size;
    zSize = z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::LocalSizeHint;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeInputPoints : ExecutionModeBase
{
  ExecutionModeInputPoints() : ExecutionModeBase(ExecutionMode::InputPoints) {}
  ~ExecutionModeInputPoints() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::InputPoints;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeInputLines : ExecutionModeBase
{
  ExecutionModeInputLines() : ExecutionModeBase(ExecutionMode::InputLines) {}
  ~ExecutionModeInputLines() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::InputLines;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeInputLinesAdjacency : ExecutionModeBase
{
  ExecutionModeInputLinesAdjacency() : ExecutionModeBase(ExecutionMode::InputLinesAdjacency) {}
  ~ExecutionModeInputLinesAdjacency() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::InputLinesAdjacency;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeTriangles : ExecutionModeBase
{
  ExecutionModeTriangles() : ExecutionModeBase(ExecutionMode::Triangles) {}
  ~ExecutionModeTriangles() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Triangles;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeInputTrianglesAdjacency : ExecutionModeBase
{
  ExecutionModeInputTrianglesAdjacency() : ExecutionModeBase(ExecutionMode::InputTrianglesAdjacency) {}
  ~ExecutionModeInputTrianglesAdjacency() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::InputTrianglesAdjacency;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeQuads : ExecutionModeBase
{
  ExecutionModeQuads() : ExecutionModeBase(ExecutionMode::Quads) {}
  ~ExecutionModeQuads() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Quads;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeIsolines : ExecutionModeBase
{
  ExecutionModeIsolines() : ExecutionModeBase(ExecutionMode::Isolines) {}
  ~ExecutionModeIsolines() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Isolines;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputVertices : ExecutionModeBase
{
  LiteralInteger vertexCount;
  ExecutionModeOutputVertices() : ExecutionModeBase(ExecutionMode::OutputVertices) {}
  ~ExecutionModeOutputVertices() = default;
  ExecutionModeOutputVertices(LiteralInteger vertex_count) : ExecutionModeBase(ExecutionMode::OutputVertices)
  {
    vertexCount = vertex_count;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputVertices;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputPoints : ExecutionModeBase
{
  ExecutionModeOutputPoints() : ExecutionModeBase(ExecutionMode::OutputPoints) {}
  ~ExecutionModeOutputPoints() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputPoints;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputLineStrip : ExecutionModeBase
{
  ExecutionModeOutputLineStrip() : ExecutionModeBase(ExecutionMode::OutputLineStrip) {}
  ~ExecutionModeOutputLineStrip() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputLineStrip;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputTriangleStrip : ExecutionModeBase
{
  ExecutionModeOutputTriangleStrip() : ExecutionModeBase(ExecutionMode::OutputTriangleStrip) {}
  ~ExecutionModeOutputTriangleStrip() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputTriangleStrip;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeVecTypeHint : ExecutionModeBase
{
  LiteralInteger vectorType;
  ExecutionModeVecTypeHint() : ExecutionModeBase(ExecutionMode::VecTypeHint) {}
  ~ExecutionModeVecTypeHint() = default;
  ExecutionModeVecTypeHint(LiteralInteger vector_type) : ExecutionModeBase(ExecutionMode::VecTypeHint) { vectorType = vector_type; }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::VecTypeHint;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeContractionOff : ExecutionModeBase
{
  ExecutionModeContractionOff() : ExecutionModeBase(ExecutionMode::ContractionOff) {}
  ~ExecutionModeContractionOff() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::ContractionOff;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeInitializer : ExecutionModeBase
{
  ExecutionModeInitializer() : ExecutionModeBase(ExecutionMode::Initializer) {}
  ~ExecutionModeInitializer() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Initializer;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeFinalizer : ExecutionModeBase
{
  ExecutionModeFinalizer() : ExecutionModeBase(ExecutionMode::Finalizer) {}
  ~ExecutionModeFinalizer() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::Finalizer;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSubgroupSize : ExecutionModeBase
{
  LiteralInteger subgroupSize;
  ExecutionModeSubgroupSize() : ExecutionModeBase(ExecutionMode::SubgroupSize) {}
  ~ExecutionModeSubgroupSize() = default;
  ExecutionModeSubgroupSize(LiteralInteger subgroup_size) : ExecutionModeBase(ExecutionMode::SubgroupSize)
  {
    subgroupSize = subgroup_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SubgroupSize;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSubgroupsPerWorkgroup : ExecutionModeBase
{
  LiteralInteger subgroupsPerWorkgroup;
  ExecutionModeSubgroupsPerWorkgroup() : ExecutionModeBase(ExecutionMode::SubgroupsPerWorkgroup) {}
  ~ExecutionModeSubgroupsPerWorkgroup() = default;
  ExecutionModeSubgroupsPerWorkgroup(LiteralInteger subgroups_per_workgroup) : ExecutionModeBase(ExecutionMode::SubgroupsPerWorkgroup)
  {
    subgroupsPerWorkgroup = subgroups_per_workgroup;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SubgroupsPerWorkgroup;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSubgroupsPerWorkgroupId : ExecutionModeBase
{
  NodePointer<NodeId> subgroupsPerWorkgroup;
  ExecutionModeSubgroupsPerWorkgroupId() : ExecutionModeBase(ExecutionMode::SubgroupsPerWorkgroupId) {}
  ~ExecutionModeSubgroupsPerWorkgroupId() = default;
  ExecutionModeSubgroupsPerWorkgroupId(NodePointer<NodeId> subgroups_per_workgroup) :
    ExecutionModeBase(ExecutionMode::SubgroupsPerWorkgroupId)
  {
    subgroupsPerWorkgroup = subgroups_per_workgroup;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SubgroupsPerWorkgroupId;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(subgroupsPerWorkgroup);
  }
};
struct ExecutionModeLocalSizeId : ExecutionModeBase
{
  NodePointer<NodeId> xSize;
  NodePointer<NodeId> ySize;
  NodePointer<NodeId> zSize;
  ExecutionModeLocalSizeId() : ExecutionModeBase(ExecutionMode::LocalSizeId) {}
  ~ExecutionModeLocalSizeId() = default;
  ExecutionModeLocalSizeId(NodePointer<NodeId> x_size, NodePointer<NodeId> y_size, NodePointer<NodeId> z_size) :
    ExecutionModeBase(ExecutionMode::LocalSizeId)
  {
    xSize = x_size;
    ySize = y_size;
    zSize = z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::LocalSizeId;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(xSize);
    visitor(ySize);
    visitor(zSize);
  }
};
struct ExecutionModeLocalSizeHintId : ExecutionModeBase
{
  NodePointer<NodeId> xSizeHint;
  NodePointer<NodeId> ySizeHint;
  NodePointer<NodeId> zSizeHint;
  ExecutionModeLocalSizeHintId() : ExecutionModeBase(ExecutionMode::LocalSizeHintId) {}
  ~ExecutionModeLocalSizeHintId() = default;
  ExecutionModeLocalSizeHintId(NodePointer<NodeId> x_size_hint, NodePointer<NodeId> y_size_hint, NodePointer<NodeId> z_size_hint) :
    ExecutionModeBase(ExecutionMode::LocalSizeHintId)
  {
    xSizeHint = x_size_hint;
    ySizeHint = y_size_hint;
    zSizeHint = z_size_hint;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::LocalSizeHintId;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(xSizeHint);
    visitor(ySizeHint);
    visitor(zSizeHint);
  }
};
struct ExecutionModeNonCoherentColorAttachmentReadEXT : ExecutionModeBase
{
  ExecutionModeNonCoherentColorAttachmentReadEXT() : ExecutionModeBase(ExecutionMode::NonCoherentColorAttachmentReadEXT) {}
  ~ExecutionModeNonCoherentColorAttachmentReadEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NonCoherentColorAttachmentReadEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeNonCoherentDepthAttachmentReadEXT : ExecutionModeBase
{
  ExecutionModeNonCoherentDepthAttachmentReadEXT() : ExecutionModeBase(ExecutionMode::NonCoherentDepthAttachmentReadEXT) {}
  ~ExecutionModeNonCoherentDepthAttachmentReadEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NonCoherentDepthAttachmentReadEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeNonCoherentStencilAttachmentReadEXT : ExecutionModeBase
{
  ExecutionModeNonCoherentStencilAttachmentReadEXT() : ExecutionModeBase(ExecutionMode::NonCoherentStencilAttachmentReadEXT) {}
  ~ExecutionModeNonCoherentStencilAttachmentReadEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NonCoherentStencilAttachmentReadEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSubgroupUniformControlFlowKHR : ExecutionModeBase
{
  ExecutionModeSubgroupUniformControlFlowKHR() : ExecutionModeBase(ExecutionMode::SubgroupUniformControlFlowKHR) {}
  ~ExecutionModeSubgroupUniformControlFlowKHR() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SubgroupUniformControlFlowKHR;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModePostDepthCoverage : ExecutionModeBase
{
  ExecutionModePostDepthCoverage() : ExecutionModeBase(ExecutionMode::PostDepthCoverage) {}
  ~ExecutionModePostDepthCoverage() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::PostDepthCoverage;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDenormPreserve : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeDenormPreserve() : ExecutionModeBase(ExecutionMode::DenormPreserve) {}
  ~ExecutionModeDenormPreserve() = default;
  ExecutionModeDenormPreserve(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::DenormPreserve)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DenormPreserve;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDenormFlushToZero : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeDenormFlushToZero() : ExecutionModeBase(ExecutionMode::DenormFlushToZero) {}
  ~ExecutionModeDenormFlushToZero() = default;
  ExecutionModeDenormFlushToZero(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::DenormFlushToZero)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DenormFlushToZero;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSignedZeroInfNanPreserve : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeSignedZeroInfNanPreserve() : ExecutionModeBase(ExecutionMode::SignedZeroInfNanPreserve) {}
  ~ExecutionModeSignedZeroInfNanPreserve() = default;
  ExecutionModeSignedZeroInfNanPreserve(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::SignedZeroInfNanPreserve)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SignedZeroInfNanPreserve;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRoundingModeRTE : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeRoundingModeRTE() : ExecutionModeBase(ExecutionMode::RoundingModeRTE) {}
  ~ExecutionModeRoundingModeRTE() = default;
  ExecutionModeRoundingModeRTE(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::RoundingModeRTE)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RoundingModeRTE;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRoundingModeRTZ : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeRoundingModeRTZ() : ExecutionModeBase(ExecutionMode::RoundingModeRTZ) {}
  ~ExecutionModeRoundingModeRTZ() = default;
  ExecutionModeRoundingModeRTZ(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::RoundingModeRTZ)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RoundingModeRTZ;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeEarlyAndLateFragmentTestsAMD : ExecutionModeBase
{
  ExecutionModeEarlyAndLateFragmentTestsAMD() : ExecutionModeBase(ExecutionMode::EarlyAndLateFragmentTestsAMD) {}
  ~ExecutionModeEarlyAndLateFragmentTestsAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::EarlyAndLateFragmentTestsAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefReplacingEXT : ExecutionModeBase
{
  ExecutionModeStencilRefReplacingEXT() : ExecutionModeBase(ExecutionMode::StencilRefReplacingEXT) {}
  ~ExecutionModeStencilRefReplacingEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefReplacingEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeCoalescingAMDX : ExecutionModeBase
{
  ExecutionModeCoalescingAMDX() : ExecutionModeBase(ExecutionMode::CoalescingAMDX) {}
  ~ExecutionModeCoalescingAMDX() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::CoalescingAMDX;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaxNodeRecursionAMDX : ExecutionModeBase
{
  NodePointer<NodeId> numberOfRecursions;
  ExecutionModeMaxNodeRecursionAMDX() : ExecutionModeBase(ExecutionMode::MaxNodeRecursionAMDX) {}
  ~ExecutionModeMaxNodeRecursionAMDX() = default;
  ExecutionModeMaxNodeRecursionAMDX(NodePointer<NodeId> number_of_recursions) : ExecutionModeBase(ExecutionMode::MaxNodeRecursionAMDX)
  {
    numberOfRecursions = number_of_recursions;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaxNodeRecursionAMDX;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(numberOfRecursions);
  }
};
struct ExecutionModeStaticNumWorkgroupsAMDX : ExecutionModeBase
{
  NodePointer<NodeId> xSize;
  NodePointer<NodeId> ySize;
  NodePointer<NodeId> zSize;
  ExecutionModeStaticNumWorkgroupsAMDX() : ExecutionModeBase(ExecutionMode::StaticNumWorkgroupsAMDX) {}
  ~ExecutionModeStaticNumWorkgroupsAMDX() = default;
  ExecutionModeStaticNumWorkgroupsAMDX(NodePointer<NodeId> x_size, NodePointer<NodeId> y_size, NodePointer<NodeId> z_size) :
    ExecutionModeBase(ExecutionMode::StaticNumWorkgroupsAMDX)
  {
    xSize = x_size;
    ySize = y_size;
    zSize = z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StaticNumWorkgroupsAMDX;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(xSize);
    visitor(ySize);
    visitor(zSize);
  }
};
struct ExecutionModeShaderIndexAMDX : ExecutionModeBase
{
  NodePointer<NodeId> shaderIndex;
  ExecutionModeShaderIndexAMDX() : ExecutionModeBase(ExecutionMode::ShaderIndexAMDX) {}
  ~ExecutionModeShaderIndexAMDX() = default;
  ExecutionModeShaderIndexAMDX(NodePointer<NodeId> shader_index) : ExecutionModeBase(ExecutionMode::ShaderIndexAMDX)
  {
    shaderIndex = shader_index;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::ShaderIndexAMDX;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(shaderIndex);
  }
};
struct ExecutionModeMaxNumWorkgroupsAMDX : ExecutionModeBase
{
  NodePointer<NodeId> xSize;
  NodePointer<NodeId> ySize;
  NodePointer<NodeId> zSize;
  ExecutionModeMaxNumWorkgroupsAMDX() : ExecutionModeBase(ExecutionMode::MaxNumWorkgroupsAMDX) {}
  ~ExecutionModeMaxNumWorkgroupsAMDX() = default;
  ExecutionModeMaxNumWorkgroupsAMDX(NodePointer<NodeId> x_size, NodePointer<NodeId> y_size, NodePointer<NodeId> z_size) :
    ExecutionModeBase(ExecutionMode::MaxNumWorkgroupsAMDX)
  {
    xSize = x_size;
    ySize = y_size;
    zSize = z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaxNumWorkgroupsAMDX;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(xSize);
    visitor(ySize);
    visitor(zSize);
  }
};
struct ExecutionModeStencilRefUnchangedFrontAMD : ExecutionModeBase
{
  ExecutionModeStencilRefUnchangedFrontAMD() : ExecutionModeBase(ExecutionMode::StencilRefUnchangedFrontAMD) {}
  ~ExecutionModeStencilRefUnchangedFrontAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefUnchangedFrontAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefGreaterFrontAMD : ExecutionModeBase
{
  ExecutionModeStencilRefGreaterFrontAMD() : ExecutionModeBase(ExecutionMode::StencilRefGreaterFrontAMD) {}
  ~ExecutionModeStencilRefGreaterFrontAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefGreaterFrontAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefLessFrontAMD : ExecutionModeBase
{
  ExecutionModeStencilRefLessFrontAMD() : ExecutionModeBase(ExecutionMode::StencilRefLessFrontAMD) {}
  ~ExecutionModeStencilRefLessFrontAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefLessFrontAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefUnchangedBackAMD : ExecutionModeBase
{
  ExecutionModeStencilRefUnchangedBackAMD() : ExecutionModeBase(ExecutionMode::StencilRefUnchangedBackAMD) {}
  ~ExecutionModeStencilRefUnchangedBackAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefUnchangedBackAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefGreaterBackAMD : ExecutionModeBase
{
  ExecutionModeStencilRefGreaterBackAMD() : ExecutionModeBase(ExecutionMode::StencilRefGreaterBackAMD) {}
  ~ExecutionModeStencilRefGreaterBackAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefGreaterBackAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeStencilRefLessBackAMD : ExecutionModeBase
{
  ExecutionModeStencilRefLessBackAMD() : ExecutionModeBase(ExecutionMode::StencilRefLessBackAMD) {}
  ~ExecutionModeStencilRefLessBackAMD() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StencilRefLessBackAMD;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeQuadDerivativesKHR : ExecutionModeBase
{
  ExecutionModeQuadDerivativesKHR() : ExecutionModeBase(ExecutionMode::QuadDerivativesKHR) {}
  ~ExecutionModeQuadDerivativesKHR() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::QuadDerivativesKHR;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRequireFullQuadsKHR : ExecutionModeBase
{
  ExecutionModeRequireFullQuadsKHR() : ExecutionModeBase(ExecutionMode::RequireFullQuadsKHR) {}
  ~ExecutionModeRequireFullQuadsKHR() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RequireFullQuadsKHR;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputLinesEXT : ExecutionModeBase
{
  ExecutionModeOutputLinesEXT() : ExecutionModeBase(ExecutionMode::OutputLinesEXT) {}
  ~ExecutionModeOutputLinesEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputLinesEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputLinesNV : ExecutionModeBase
{
  ExecutionModeOutputLinesNV() : ExecutionModeBase(ExecutionMode::OutputLinesNV) {}
  ~ExecutionModeOutputLinesNV() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputLinesNV;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputPrimitivesEXT : ExecutionModeBase
{
  LiteralInteger primitiveCount;
  ExecutionModeOutputPrimitivesEXT() : ExecutionModeBase(ExecutionMode::OutputPrimitivesEXT) {}
  ~ExecutionModeOutputPrimitivesEXT() = default;
  ExecutionModeOutputPrimitivesEXT(LiteralInteger primitive_count) : ExecutionModeBase(ExecutionMode::OutputPrimitivesEXT)
  {
    primitiveCount = primitive_count;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputPrimitivesEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputPrimitivesNV : ExecutionModeBase
{
  LiteralInteger primitiveCount;
  ExecutionModeOutputPrimitivesNV() : ExecutionModeBase(ExecutionMode::OutputPrimitivesNV) {}
  ~ExecutionModeOutputPrimitivesNV() = default;
  ExecutionModeOutputPrimitivesNV(LiteralInteger primitive_count) : ExecutionModeBase(ExecutionMode::OutputPrimitivesNV)
  {
    primitiveCount = primitive_count;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputPrimitivesNV;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDerivativeGroupQuadsNV : ExecutionModeBase
{
  ExecutionModeDerivativeGroupQuadsNV() : ExecutionModeBase(ExecutionMode::DerivativeGroupQuadsNV) {}
  ~ExecutionModeDerivativeGroupQuadsNV() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DerivativeGroupQuadsNV;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeDerivativeGroupLinearNV : ExecutionModeBase
{
  ExecutionModeDerivativeGroupLinearNV() : ExecutionModeBase(ExecutionMode::DerivativeGroupLinearNV) {}
  ~ExecutionModeDerivativeGroupLinearNV() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::DerivativeGroupLinearNV;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputTrianglesEXT : ExecutionModeBase
{
  ExecutionModeOutputTrianglesEXT() : ExecutionModeBase(ExecutionMode::OutputTrianglesEXT) {}
  ~ExecutionModeOutputTrianglesEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputTrianglesEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeOutputTrianglesNV : ExecutionModeBase
{
  ExecutionModeOutputTrianglesNV() : ExecutionModeBase(ExecutionMode::OutputTrianglesNV) {}
  ~ExecutionModeOutputTrianglesNV() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::OutputTrianglesNV;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModePixelInterlockOrderedEXT : ExecutionModeBase
{
  ExecutionModePixelInterlockOrderedEXT() : ExecutionModeBase(ExecutionMode::PixelInterlockOrderedEXT) {}
  ~ExecutionModePixelInterlockOrderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::PixelInterlockOrderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModePixelInterlockUnorderedEXT : ExecutionModeBase
{
  ExecutionModePixelInterlockUnorderedEXT() : ExecutionModeBase(ExecutionMode::PixelInterlockUnorderedEXT) {}
  ~ExecutionModePixelInterlockUnorderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::PixelInterlockUnorderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSampleInterlockOrderedEXT : ExecutionModeBase
{
  ExecutionModeSampleInterlockOrderedEXT() : ExecutionModeBase(ExecutionMode::SampleInterlockOrderedEXT) {}
  ~ExecutionModeSampleInterlockOrderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SampleInterlockOrderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSampleInterlockUnorderedEXT : ExecutionModeBase
{
  ExecutionModeSampleInterlockUnorderedEXT() : ExecutionModeBase(ExecutionMode::SampleInterlockUnorderedEXT) {}
  ~ExecutionModeSampleInterlockUnorderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SampleInterlockUnorderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeShadingRateInterlockOrderedEXT : ExecutionModeBase
{
  ExecutionModeShadingRateInterlockOrderedEXT() : ExecutionModeBase(ExecutionMode::ShadingRateInterlockOrderedEXT) {}
  ~ExecutionModeShadingRateInterlockOrderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::ShadingRateInterlockOrderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeShadingRateInterlockUnorderedEXT : ExecutionModeBase
{
  ExecutionModeShadingRateInterlockUnorderedEXT() : ExecutionModeBase(ExecutionMode::ShadingRateInterlockUnorderedEXT) {}
  ~ExecutionModeShadingRateInterlockUnorderedEXT() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::ShadingRateInterlockUnorderedEXT;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSharedLocalMemorySizeINTEL : ExecutionModeBase
{
  LiteralInteger size;
  ExecutionModeSharedLocalMemorySizeINTEL() : ExecutionModeBase(ExecutionMode::SharedLocalMemorySizeINTEL) {}
  ~ExecutionModeSharedLocalMemorySizeINTEL() = default;
  ExecutionModeSharedLocalMemorySizeINTEL(LiteralInteger size) : ExecutionModeBase(ExecutionMode::SharedLocalMemorySizeINTEL)
  {
    size = size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SharedLocalMemorySizeINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRoundingModeRTPINTEL : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeRoundingModeRTPINTEL() : ExecutionModeBase(ExecutionMode::RoundingModeRTPINTEL) {}
  ~ExecutionModeRoundingModeRTPINTEL() = default;
  ExecutionModeRoundingModeRTPINTEL(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::RoundingModeRTPINTEL)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RoundingModeRTPINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRoundingModeRTNINTEL : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeRoundingModeRTNINTEL() : ExecutionModeBase(ExecutionMode::RoundingModeRTNINTEL) {}
  ~ExecutionModeRoundingModeRTNINTEL() = default;
  ExecutionModeRoundingModeRTNINTEL(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::RoundingModeRTNINTEL)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RoundingModeRTNINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeFloatingPointModeALTINTEL : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeFloatingPointModeALTINTEL() : ExecutionModeBase(ExecutionMode::FloatingPointModeALTINTEL) {}
  ~ExecutionModeFloatingPointModeALTINTEL() = default;
  ExecutionModeFloatingPointModeALTINTEL(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::FloatingPointModeALTINTEL)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::FloatingPointModeALTINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeFloatingPointModeIEEEINTEL : ExecutionModeBase
{
  LiteralInteger targetWidth;
  ExecutionModeFloatingPointModeIEEEINTEL() : ExecutionModeBase(ExecutionMode::FloatingPointModeIEEEINTEL) {}
  ~ExecutionModeFloatingPointModeIEEEINTEL() = default;
  ExecutionModeFloatingPointModeIEEEINTEL(LiteralInteger target_width) : ExecutionModeBase(ExecutionMode::FloatingPointModeIEEEINTEL)
  {
    targetWidth = target_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::FloatingPointModeIEEEINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaxWorkgroupSizeINTEL : ExecutionModeBase
{
  LiteralInteger max_x_size;
  LiteralInteger max_y_size;
  LiteralInteger max_z_size;
  ExecutionModeMaxWorkgroupSizeINTEL() : ExecutionModeBase(ExecutionMode::MaxWorkgroupSizeINTEL) {}
  ~ExecutionModeMaxWorkgroupSizeINTEL() = default;
  ExecutionModeMaxWorkgroupSizeINTEL(LiteralInteger max_x_size, LiteralInteger max_y_size, LiteralInteger max_z_size) :
    ExecutionModeBase(ExecutionMode::MaxWorkgroupSizeINTEL)
  {
    max_x_size = max_x_size;
    max_y_size = max_y_size;
    max_z_size = max_z_size;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaxWorkgroupSizeINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaxWorkDimINTEL : ExecutionModeBase
{
  LiteralInteger max_dimensions;
  ExecutionModeMaxWorkDimINTEL() : ExecutionModeBase(ExecutionMode::MaxWorkDimINTEL) {}
  ~ExecutionModeMaxWorkDimINTEL() = default;
  ExecutionModeMaxWorkDimINTEL(LiteralInteger max_dimensions) : ExecutionModeBase(ExecutionMode::MaxWorkDimINTEL)
  {
    max_dimensions = max_dimensions;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaxWorkDimINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeNoGlobalOffsetINTEL : ExecutionModeBase
{
  ExecutionModeNoGlobalOffsetINTEL() : ExecutionModeBase(ExecutionMode::NoGlobalOffsetINTEL) {}
  ~ExecutionModeNoGlobalOffsetINTEL() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NoGlobalOffsetINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeNumSIMDWorkitemsINTEL : ExecutionModeBase
{
  LiteralInteger vector_width;
  ExecutionModeNumSIMDWorkitemsINTEL() : ExecutionModeBase(ExecutionMode::NumSIMDWorkitemsINTEL) {}
  ~ExecutionModeNumSIMDWorkitemsINTEL() = default;
  ExecutionModeNumSIMDWorkitemsINTEL(LiteralInteger vector_width) : ExecutionModeBase(ExecutionMode::NumSIMDWorkitemsINTEL)
  {
    vector_width = vector_width;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NumSIMDWorkitemsINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeSchedulerTargetFmaxMhzINTEL : ExecutionModeBase
{
  LiteralInteger target_fmax;
  ExecutionModeSchedulerTargetFmaxMhzINTEL() : ExecutionModeBase(ExecutionMode::SchedulerTargetFmaxMhzINTEL) {}
  ~ExecutionModeSchedulerTargetFmaxMhzINTEL() = default;
  ExecutionModeSchedulerTargetFmaxMhzINTEL(LiteralInteger target_fmax) : ExecutionModeBase(ExecutionMode::SchedulerTargetFmaxMhzINTEL)
  {
    target_fmax = target_fmax;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::SchedulerTargetFmaxMhzINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaximallyReconvergesKHR : ExecutionModeBase
{
  ExecutionModeMaximallyReconvergesKHR() : ExecutionModeBase(ExecutionMode::MaximallyReconvergesKHR) {}
  ~ExecutionModeMaximallyReconvergesKHR() = default;
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaximallyReconvergesKHR;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeFPFastMathDefault : ExecutionModeBase
{
  NodePointer<NodeId> targetType;
  NodePointer<NodeId> fastMathMode;
  ExecutionModeFPFastMathDefault() : ExecutionModeBase(ExecutionMode::FPFastMathDefault) {}
  ~ExecutionModeFPFastMathDefault() = default;
  ExecutionModeFPFastMathDefault(NodePointer<NodeId> target_type, NodePointer<NodeId> fast_math_mode) :
    ExecutionModeBase(ExecutionMode::FPFastMathDefault)
  {
    targetType = target_type;
    fastMathMode = fast_math_mode;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::FPFastMathDefault;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(targetType);
    visitor(fastMathMode);
  }
};
struct ExecutionModeStreamingInterfaceINTEL : ExecutionModeBase
{
  LiteralInteger stallFreeReturn;
  ExecutionModeStreamingInterfaceINTEL() : ExecutionModeBase(ExecutionMode::StreamingInterfaceINTEL) {}
  ~ExecutionModeStreamingInterfaceINTEL() = default;
  ExecutionModeStreamingInterfaceINTEL(LiteralInteger stall_free_return) : ExecutionModeBase(ExecutionMode::StreamingInterfaceINTEL)
  {
    stallFreeReturn = stall_free_return;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::StreamingInterfaceINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeRegisterMapInterfaceINTEL : ExecutionModeBase
{
  LiteralInteger waitForDoneWrite;
  ExecutionModeRegisterMapInterfaceINTEL() : ExecutionModeBase(ExecutionMode::RegisterMapInterfaceINTEL) {}
  ~ExecutionModeRegisterMapInterfaceINTEL() = default;
  ExecutionModeRegisterMapInterfaceINTEL(LiteralInteger wait_for_done_write) :
    ExecutionModeBase(ExecutionMode::RegisterMapInterfaceINTEL)
  {
    waitForDoneWrite = wait_for_done_write;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::RegisterMapInterfaceINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeNamedBarrierCountINTEL : ExecutionModeBase
{
  LiteralInteger barrierCount;
  ExecutionModeNamedBarrierCountINTEL() : ExecutionModeBase(ExecutionMode::NamedBarrierCountINTEL) {}
  ~ExecutionModeNamedBarrierCountINTEL() = default;
  ExecutionModeNamedBarrierCountINTEL(LiteralInteger barrier_count) : ExecutionModeBase(ExecutionMode::NamedBarrierCountINTEL)
  {
    barrierCount = barrier_count;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NamedBarrierCountINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaximumRegistersINTEL : ExecutionModeBase
{
  LiteralInteger numberOfRegisters;
  ExecutionModeMaximumRegistersINTEL() : ExecutionModeBase(ExecutionMode::MaximumRegistersINTEL) {}
  ~ExecutionModeMaximumRegistersINTEL() = default;
  ExecutionModeMaximumRegistersINTEL(LiteralInteger number_of_registers) : ExecutionModeBase(ExecutionMode::MaximumRegistersINTEL)
  {
    numberOfRegisters = number_of_registers;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaximumRegistersINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
struct ExecutionModeMaximumRegistersIdINTEL : ExecutionModeBase
{
  NodePointer<NodeId> numberOfRegisters;
  ExecutionModeMaximumRegistersIdINTEL() : ExecutionModeBase(ExecutionMode::MaximumRegistersIdINTEL) {}
  ~ExecutionModeMaximumRegistersIdINTEL() = default;
  ExecutionModeMaximumRegistersIdINTEL(NodePointer<NodeId> number_of_registers) :
    ExecutionModeBase(ExecutionMode::MaximumRegistersIdINTEL)
  {
    numberOfRegisters = number_of_registers;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::MaximumRegistersIdINTEL;
  }
  template <typename T>
  void visitRefs(T visitor)
  {
    visitor(numberOfRegisters);
  }
};
struct ExecutionModeNamedMaximumRegistersINTEL : ExecutionModeBase
{
  NamedMaximumNumberOfRegisters namedMaximumNumberOfRegisters;
  ExecutionModeNamedMaximumRegistersINTEL() : ExecutionModeBase(ExecutionMode::NamedMaximumRegistersINTEL) {}
  ~ExecutionModeNamedMaximumRegistersINTEL() = default;
  ExecutionModeNamedMaximumRegistersINTEL(NamedMaximumNumberOfRegisters named_maximum_number_of_registers) :
    ExecutionModeBase(ExecutionMode::NamedMaximumRegistersINTEL)
  {
    namedMaximumNumberOfRegisters = named_maximum_number_of_registers;
  }
  template <typename T>
  static constexpr bool is(const T *v)
  {
    return v->mode == ExecutionMode::NamedMaximumRegistersINTEL;
  }
  template <typename T>
  void visitRefs(T)
  {}
};
template <typename T, typename U>
void executionModeVisitor(T *t, U u)
{
  switch (t->mode)
  {
    case ExecutionMode::Invocations: u(reinterpret_cast<ExecutionModeInvocations *>(t)); break;
    case ExecutionMode::SpacingEqual: u(reinterpret_cast<ExecutionModeSpacingEqual *>(t)); break;
    case ExecutionMode::SpacingFractionalEven: u(reinterpret_cast<ExecutionModeSpacingFractionalEven *>(t)); break;
    case ExecutionMode::SpacingFractionalOdd: u(reinterpret_cast<ExecutionModeSpacingFractionalOdd *>(t)); break;
    case ExecutionMode::VertexOrderCw: u(reinterpret_cast<ExecutionModeVertexOrderCw *>(t)); break;
    case ExecutionMode::VertexOrderCcw: u(reinterpret_cast<ExecutionModeVertexOrderCcw *>(t)); break;
    case ExecutionMode::PixelCenterInteger: u(reinterpret_cast<ExecutionModePixelCenterInteger *>(t)); break;
    case ExecutionMode::OriginUpperLeft: u(reinterpret_cast<ExecutionModeOriginUpperLeft *>(t)); break;
    case ExecutionMode::OriginLowerLeft: u(reinterpret_cast<ExecutionModeOriginLowerLeft *>(t)); break;
    case ExecutionMode::EarlyFragmentTests: u(reinterpret_cast<ExecutionModeEarlyFragmentTests *>(t)); break;
    case ExecutionMode::PointMode: u(reinterpret_cast<ExecutionModePointMode *>(t)); break;
    case ExecutionMode::Xfb: u(reinterpret_cast<ExecutionModeXfb *>(t)); break;
    case ExecutionMode::DepthReplacing: u(reinterpret_cast<ExecutionModeDepthReplacing *>(t)); break;
    case ExecutionMode::DepthGreater: u(reinterpret_cast<ExecutionModeDepthGreater *>(t)); break;
    case ExecutionMode::DepthLess: u(reinterpret_cast<ExecutionModeDepthLess *>(t)); break;
    case ExecutionMode::DepthUnchanged: u(reinterpret_cast<ExecutionModeDepthUnchanged *>(t)); break;
    case ExecutionMode::LocalSize: u(reinterpret_cast<ExecutionModeLocalSize *>(t)); break;
    case ExecutionMode::LocalSizeHint: u(reinterpret_cast<ExecutionModeLocalSizeHint *>(t)); break;
    case ExecutionMode::InputPoints: u(reinterpret_cast<ExecutionModeInputPoints *>(t)); break;
    case ExecutionMode::InputLines: u(reinterpret_cast<ExecutionModeInputLines *>(t)); break;
    case ExecutionMode::InputLinesAdjacency: u(reinterpret_cast<ExecutionModeInputLinesAdjacency *>(t)); break;
    case ExecutionMode::Triangles: u(reinterpret_cast<ExecutionModeTriangles *>(t)); break;
    case ExecutionMode::InputTrianglesAdjacency: u(reinterpret_cast<ExecutionModeInputTrianglesAdjacency *>(t)); break;
    case ExecutionMode::Quads: u(reinterpret_cast<ExecutionModeQuads *>(t)); break;
    case ExecutionMode::Isolines: u(reinterpret_cast<ExecutionModeIsolines *>(t)); break;
    case ExecutionMode::OutputVertices: u(reinterpret_cast<ExecutionModeOutputVertices *>(t)); break;
    case ExecutionMode::OutputPoints: u(reinterpret_cast<ExecutionModeOutputPoints *>(t)); break;
    case ExecutionMode::OutputLineStrip: u(reinterpret_cast<ExecutionModeOutputLineStrip *>(t)); break;
    case ExecutionMode::OutputTriangleStrip: u(reinterpret_cast<ExecutionModeOutputTriangleStrip *>(t)); break;
    case ExecutionMode::VecTypeHint: u(reinterpret_cast<ExecutionModeVecTypeHint *>(t)); break;
    case ExecutionMode::ContractionOff: u(reinterpret_cast<ExecutionModeContractionOff *>(t)); break;
    case ExecutionMode::Initializer: u(reinterpret_cast<ExecutionModeInitializer *>(t)); break;
    case ExecutionMode::Finalizer: u(reinterpret_cast<ExecutionModeFinalizer *>(t)); break;
    case ExecutionMode::SubgroupSize: u(reinterpret_cast<ExecutionModeSubgroupSize *>(t)); break;
    case ExecutionMode::SubgroupsPerWorkgroup: u(reinterpret_cast<ExecutionModeSubgroupsPerWorkgroup *>(t)); break;
    case ExecutionMode::SubgroupsPerWorkgroupId: u(reinterpret_cast<ExecutionModeSubgroupsPerWorkgroupId *>(t)); break;
    case ExecutionMode::LocalSizeId: u(reinterpret_cast<ExecutionModeLocalSizeId *>(t)); break;
    case ExecutionMode::LocalSizeHintId: u(reinterpret_cast<ExecutionModeLocalSizeHintId *>(t)); break;
    case ExecutionMode::NonCoherentColorAttachmentReadEXT:
      u(reinterpret_cast<ExecutionModeNonCoherentColorAttachmentReadEXT *>(t));
      break;
    case ExecutionMode::NonCoherentDepthAttachmentReadEXT:
      u(reinterpret_cast<ExecutionModeNonCoherentDepthAttachmentReadEXT *>(t));
      break;
    case ExecutionMode::NonCoherentStencilAttachmentReadEXT:
      u(reinterpret_cast<ExecutionModeNonCoherentStencilAttachmentReadEXT *>(t));
      break;
    case ExecutionMode::SubgroupUniformControlFlowKHR: u(reinterpret_cast<ExecutionModeSubgroupUniformControlFlowKHR *>(t)); break;
    case ExecutionMode::PostDepthCoverage: u(reinterpret_cast<ExecutionModePostDepthCoverage *>(t)); break;
    case ExecutionMode::DenormPreserve: u(reinterpret_cast<ExecutionModeDenormPreserve *>(t)); break;
    case ExecutionMode::DenormFlushToZero: u(reinterpret_cast<ExecutionModeDenormFlushToZero *>(t)); break;
    case ExecutionMode::SignedZeroInfNanPreserve: u(reinterpret_cast<ExecutionModeSignedZeroInfNanPreserve *>(t)); break;
    case ExecutionMode::RoundingModeRTE: u(reinterpret_cast<ExecutionModeRoundingModeRTE *>(t)); break;
    case ExecutionMode::RoundingModeRTZ: u(reinterpret_cast<ExecutionModeRoundingModeRTZ *>(t)); break;
    case ExecutionMode::EarlyAndLateFragmentTestsAMD: u(reinterpret_cast<ExecutionModeEarlyAndLateFragmentTestsAMD *>(t)); break;
    case ExecutionMode::StencilRefReplacingEXT: u(reinterpret_cast<ExecutionModeStencilRefReplacingEXT *>(t)); break;
    case ExecutionMode::CoalescingAMDX: u(reinterpret_cast<ExecutionModeCoalescingAMDX *>(t)); break;
    case ExecutionMode::MaxNodeRecursionAMDX: u(reinterpret_cast<ExecutionModeMaxNodeRecursionAMDX *>(t)); break;
    case ExecutionMode::StaticNumWorkgroupsAMDX: u(reinterpret_cast<ExecutionModeStaticNumWorkgroupsAMDX *>(t)); break;
    case ExecutionMode::ShaderIndexAMDX: u(reinterpret_cast<ExecutionModeShaderIndexAMDX *>(t)); break;
    case ExecutionMode::MaxNumWorkgroupsAMDX: u(reinterpret_cast<ExecutionModeMaxNumWorkgroupsAMDX *>(t)); break;
    case ExecutionMode::StencilRefUnchangedFrontAMD: u(reinterpret_cast<ExecutionModeStencilRefUnchangedFrontAMD *>(t)); break;
    case ExecutionMode::StencilRefGreaterFrontAMD: u(reinterpret_cast<ExecutionModeStencilRefGreaterFrontAMD *>(t)); break;
    case ExecutionMode::StencilRefLessFrontAMD: u(reinterpret_cast<ExecutionModeStencilRefLessFrontAMD *>(t)); break;
    case ExecutionMode::StencilRefUnchangedBackAMD: u(reinterpret_cast<ExecutionModeStencilRefUnchangedBackAMD *>(t)); break;
    case ExecutionMode::StencilRefGreaterBackAMD: u(reinterpret_cast<ExecutionModeStencilRefGreaterBackAMD *>(t)); break;
    case ExecutionMode::StencilRefLessBackAMD: u(reinterpret_cast<ExecutionModeStencilRefLessBackAMD *>(t)); break;
    case ExecutionMode::QuadDerivativesKHR: u(reinterpret_cast<ExecutionModeQuadDerivativesKHR *>(t)); break;
    case ExecutionMode::RequireFullQuadsKHR: u(reinterpret_cast<ExecutionModeRequireFullQuadsKHR *>(t)); break;
    case ExecutionMode::OutputLinesEXT:
      u(reinterpret_cast<ExecutionModeOutputLinesEXT *>(t));
      break;
      // duplicated OutputLinesNV = 5269
  }
};
} // namespace spirv
