include "shader_global.dshl"
include "gbuffer.dshl"
include "viewVecVS.dshl"
include "bvh.dshl"
include "blue_noise.dshl"
include "rtsm_sun_dir.dshl"
include "bvh_common_includes.dshl"

float4x4 inv_proj_tm;

texture rtao_target;

float4 rtao_hit_dist_params;
int4 rtao_resolutionI = (1,1,1,1);
int rtao_res_mul = 1;

interval rtao_res_mul: off<2, on;

int rtao_checkerboard = 0;
interval rtao_checkerboard: off<1, on;

float impostor_shadow_offset = -10;

shader rt_ao
{
  if (compatibility_mode == compatibility_mode_on || !use_hw_raytracing)
  {
    dont_render;
  }
  ENABLE_ASSERT(cs)

  RTSM_SUN_DIR()
  (cs) {
    inv_proj_tm@f44 = inv_proj_tm;
    world_view_pos@f3 = world_view_pos;
    resolution@u2 = rtao_resolutionI.xy;
    inv_aligned_resolution@f2 = (rtao_res_mul*screen_pos_to_texcoord.xy);
    hit_dist_params@f4 = rtao_hit_dist_params;
    rtao_checkerboard@i1 = rtao_checkerboard;
    output@uav = rtao_target hlsl { RWTexture2D<float> output@uav; };
    impostor_shadow_offset@f1 = impostor_shadow_offset;
  }

  hlsl(cs) {
    #define DISABLE_TOONSHADING 1

    #include <Include/NRDEncoding.hlsli>
    #include <Include/NRD.hlsli>
  }

  USE_AND_INIT_VIEW_VEC_CS()
  INIT_ZNZFAR_STAGE(cs)
  INIT_LOAD_DEPTH_GBUFFER_BASE(cs)
  USE_LOAD_DEPTH_GBUFFER_BASE(cs)
  USE_EMISSION_DECODE_COLOR_MAP_STUB(cs)
  INIT_LOAD_GBUFFER_BASE(cs)
  INIT_LOAD_BVH_FLAGS_BASE(cs)
  USE_LOAD_GBUFFER_BASE(cs, true)
  INIT_BVH(cs, 0, true)
  USE_BVH_FOR_AO(cs)

  if (rtao_res_mul == on)
  {
    INIT_HALF_RES_DEPTH_TEX(cs)
    USE_CALC_GEOMETRY_NORMAL_HALF(cs)
  }
  else
  {
    USE_CALC_GEOMETRY_NORMAL(cs)
  }

  USE_ADAPTIVE_RAY_OFFSET(cs)

  INIT_BVH_WATER_FADE_BASE(cs)
  USE_BVH_WATER_FADE_BASE(cs)

  INIT_BLUE_NOISE(cs)
  USE_BLUE_NOISE(cs)

  hlsl(cs)
  {
    float3 cosine_sample_hemisphere(float2 outputIndex, float3 n, float scale = 1)
    {
      float2 u     = GetBlueNoise(outputIndex, rtao_checkerboard, 0);
      float  r     = half(sqrt(u.x)) * scale;
      float  theta = half(2.0 * PI * u.y);
      float3 B     = normalize(cross(n, half3(0.0, 1.0, 1.0)));
      float3 T     = cross(B, n);
      return normalize(r * sin(theta) * B + sqrt(1.0 - u.x) * n + r * cos(theta) * T);
    }

    float calc_output_value(float t, float view_z, float roughness)
    {
      return REBLUR_FrontEnd_GetNormHitDist(t, view_z, hit_dist_params, roughness);
    }

    RT_GROUP_SIZE
    void rt_ao_cs(uint2 dtid : SV_DispatchThreadID)
    {
      uint2 rayIndex    = dtid;
      uint2 outputIndex = rayIndex;
##if rtao_checkerboard == on
      rayIndex.x *= 2;

      bool evenFrame = ( frame_index & 1 ) == 0;
      bool evenLine  = ( rayIndex.y & 1 ) == 0;

      if ( evenFrame == evenLine )
        ++rayIndex.x;
##endif
      if (any(rayIndex >= resolution))
        return;

      ##if rtao_res_mul == on
        UnpackedGbuffer gbuffer = unpackGbuffer(loadPackedGbuffer(rayIndex * 2));
        float rawDepth = texture2DAt(half_res_depth_tex, rayIndex).r;
      ##else
        UnpackedGbuffer gbuffer = unpackGbuffer(loadPackedGbuffer(rayIndex));
        float rawDepth = loadGbufferDepth(rayIndex);
      ##endif
      float roughness = linearSmoothnessToLinearRoughness(gbuffer.smoothness);

      BRANCH
      if (rawDepth <= 0 || !bvhMainValid)
      {
        texture2DAt(output, outputIndex) = calc_output_value(NRD_FP16_MAX, NRD_FP16_MAX, 0);
        return;
      }

      float w = linearize_z(rawDepth, zn_zfar.zw);
      float underwaterFade = calc_underwater_fade(w, rayIndex, inv_aligned_resolution, world_view_pos);

      BRANCH
      if (underwaterFade == 0)
      {
        texture2DAt(output, outputIndex) = calc_output_value(NRD_FP16_MAX, NRD_FP16_MAX, 0);
        return;
      }

      bool isImpostor = gbuffer.impostorMask > 0.5;
      bool isGrass = gbuffer.isGrass;
      bool isTwoSided = gbuffer.isTwoSided;
      bool isFoliage = gbuffer.material == SHADING_FOLIAGE;

      float3 relPos = calc_camera_relative_pos(rayIndex, w, inv_aligned_resolution);
      relPos += impostor_shadow_offset * gbuffer.impostorMask * sun_dir_for_shadows;
      float3 normal = gbuffer.normal;
      if (!isGrass)
      {
        ##if rtao_res_mul == on
          normal = calc_geometry_normal_half(rayIndex, inv_aligned_resolution, resolution);
        ##else
          normal = calc_geometry_normal(rayIndex, inv_aligned_resolution, resolution);
        ##endif
      }
      float3 sampleDir = cosine_sample_hemisphere(rayIndex, normal);

      relPos = applyAdaptiveRayOffset(relPos, normal);

      float minT = 0;
      uint groupMask = bvhGroupAO;
      if (isImpostor)
        groupMask &= ~bvhGroupImpostor;
      else if (isGrass)
        groupMask &= ~bvhGroupGrass;
      if (isFoliage)
        minT = bvh_foliage_bias;

      float aoDistance = hit_dist_params.x;

      HitInfo hitInfo;

      bool isHit = trace_ray(bvhMain, relPos, sampleDir, minT, aoDistance, w, groupMask, hitInfo);
      if (isHit)
        texture2DAt(output, outputIndex.xy) = calc_output_value(hitInfo.t, w, roughness);
      else
        texture2DAt(output, outputIndex.xy) = calc_output_value(NRD_FP16_MAX, w, roughness);
    }
  }

  compile("cs_6_5", "rt_ao_cs");
}
