include "shader_global.dshl"
include "gbuffer.dshl"
include "rendinst_inc.dshl"
include "rendinst_impostor_inc.dshl"

float4 texture_size = float4(1, 1, 0, 0);
float4 impostor_depth_scale = float4(1, 0, 0, 0);
int impostor_color_padding = 1;
int dynamic_impostor_texture_const_no = 13 always_referenced;

texture impostor_packed_albedo_alpha;
texture impostor_packed_normal_translucency;
texture impostor_packed_ao_smoothness;

macro USE_IMPOSTOR_STRUCTS()
  hlsl(ps) {
    #include <pack_impostor_texture.hlsl>

    struct PackedTexture
    {
      float4 albedo_depth: SV_Target0;
      float4 normal_translucency_roughness: SV_Target1;
    };

    struct ImpostorParameters
    {
      float3 albedo;
      float alpha;
      float3 normal;
      float depth;
      float translucency;
      float roughness;
    };

    ImpostorParameters init_impostor_parameters()
    {
      ImpostorParameters params;
      params.albedo = 0;
      params.alpha = 0;
      params.normal = 0;
      params.depth = 0;
      params.translucency = 0;
      params.roughness = 0;
      return params;
    }
  }
endmacro

macro USE_READ_IMPOSTOR_PACKED_TEXTURES()
  ENABLE_ASSERT(ps)
  USE_IMPOSTOR_STRUCTS()

  (ps)
  {
    impostor_packed_albedo_alpha@tex2d = impostor_packed_albedo_alpha;
    impostor_packed_normal_translucency@tex2d = impostor_packed_normal_translucency;
    impostor_packed_ao_smoothness@tex2d = impostor_packed_ao_smoothness;
  }

  hlsl(ps) {
    ImpostorParameters read_impostor_params_from_packed_texture(uint2 tc)
    {
      float4 albedo_depth = texelFetch(impostor_packed_albedo_alpha, tc, 0);
      float4 normal_translucency_roughness = texelFetch(impostor_packed_normal_translucency, tc, 0);

      ImpostorParameters ret;

      ret.albedo = albedo_depth.rgb * albedo_depth.rgb;
      ret.alpha = 1;
      ret.depth = 1 / max(albedo_depth.a, 1e-8) - 1;
      ret.normal = restore_normal(normal_translucency_roughness.ga);
      ret.translucency = normal_translucency_roughness.r;
      ret.roughness = normal_translucency_roughness.b;

      return ret;
    }
  }
endmacro

macro USE_PACKED_TEXTURES()
  hlsl(ps) {
    struct ImpostorCombinedState
    {
      ImpostorParameters params;
      int numSamples, depthSamples;
    };

    ImpostorCombinedState init_combined_samples()
    {
      ImpostorCombinedState ret;
      ret.params = init_impostor_parameters();
      ret.numSamples = 0;
      ret.depthSamples = 0;
      return ret;
    }

    void combine_impostor_samples(inout ImpostorCombinedState state, in ImpostorParameters params)
    {
      state.params.depth += 1 / (1 + max(params.depth, 0));
      state.depthSamples++;

      if (state.params.depth < 999)
      {
        state.params.albedo += params.albedo;
        state.params.alpha += params.alpha;
        state.params.normal += params.normal;
        state.params.translucency += params.translucency;
        state.params.roughness += params.roughness;
        state.numSamples++;
      }
    }

    ImpostorParameters combine_samples(in ImpostorCombinedState state)
    {
      ImpostorParameters params;
      params.depth = 1 / max(state.params.depth / state.depthSamples, 1e-8) - 1;

      BRANCH
      if (state.numSamples > 0)
      {
        params.albedo = state.params.albedo / state.numSamples;
        params.alpha = state.params.alpha / state.numSamples;
        params.normal = normalize(state.params.normal);
        params.translucency = state.params.translucency / state.numSamples;
        params.roughness = state.params.roughness / state.numSamples;
      }
      else
      {
        params.albedo = 0;
        params.alpha = 0;
        params.normal = float3(0, 0, 1);
        params.translucency = 0;
        params.roughness = 1;
      }
      return params;
    }

    PackedTexture pack_impostor_params(in ImpostorParameters params)
    {
      PackedTexture ret;

      ret.albedo_depth.rgb = sqrt(params.albedo);
      ret.albedo_depth.a = 1 / (1 + max(params.depth, 0));

      ret.normal_translucency_roughness.ga = (normalize(params.normal) * (params.normal.z > 0 ? 0.5 : -0.5) + 0.5).xy;
      ret.normal_translucency_roughness.r = params.translucency;
      ret.normal_translucency_roughness.b = params.roughness;

      return ret;
    }
  }
endmacro

shader grass_impostor_postprocessor
{
  supports global_frame;

  cull_mode=none;
  z_write=false;
  z_test=false;

  (ps)
  {
    texture_size@f4 = (texture_size.x, texture_size.y, 1/texture_size.x, 1/texture_size.y);
  }

  USE_READ_IMPOSTOR_PACKED_TEXTURES()
  USE_PACKED_TEXTURES()

  POSTFX_VS_TEXCOORD(0, tc)
  hlsl(ps) {
    //signed distance is positive when outside the impostor, and negative when inside
    float encode_distance_to_alpha(float signed_dist, float max_dist)
    {
      return saturate(-signed_dist / max_dist * 0.5 + 0.5);
    }
    PackedTexture pack_ps(VsOutput input)
    {
      PackedTexture ret;

      float2 texPos = input.tc;

      int2 center = int2(texPos*texture_size.xy);
      ImpostorParameters params = read_impostor_params_from_packed_texture(center);

      return pack_impostor_params(params);
    }
  }
  compile("target_ps", "pack_ps");
}

// This shader is used on each miplevel separately
// Adds a fixed amount of color padding on each mip level
shader grass_impostor_color_padding
{
  supports global_frame;

  cull_mode=none;
  z_write=false;
  z_test=false;

  (ps)
  {
    texture_size@f4 = (texture_size.x, texture_size.y, 1/texture_size.x, 1/texture_size.y);
    max_dist@i1 = (min(max(texture_size.x, texture_size.y), impostor_color_padding));
  }

  USE_READ_IMPOSTOR_PACKED_TEXTURES()
  USE_PACKED_TEXTURES()

  POSTFX_VS_TEXCOORD(0, tc)
  hlsl(ps) {
    PackedTexture pack_ps(VsOutput input)
    {
      PackedTexture ret;

      float2 texPos = input.tc;

      int2 center = int2(texPos*texture_size.xy);
      ImpostorParameters originalParams = read_impostor_params_from_packed_texture(center);

      BRANCH
      if (originalParams.depth < 999)
      {
        return pack_impostor_params(originalParams);
      }
      else
      {
        int bestDistSq = max_dist*max_dist+1;
        int2 bestTc = center;
        for (int y = -max_dist; y <= max_dist; ++y)
        {
          for (int x = -max_dist; x <= max_dist; ++x)
          {
            int distSq = x*x + y*y;
            int2 tc = center + int2(x, y);
            BRANCH
            if (distSq < bestDistSq && tc.x >= 0 && tc.y >= 0 && tc.x < texture_size.x && tc.y < texture_size.y)
            {
              if (texelFetch(impostor_packed_albedo_alpha, tc, 0).w > 0)
              {
                bestTc = tc;
                bestDistSq = distSq;
              }
            }
          }
        }
        ImpostorParameters params = read_impostor_params_from_packed_texture(bestTc);
        params.depth = originalParams.depth;
        return pack_impostor_params(params);
      }
    }
  }
  compile("target_ps", "pack_ps");
}

shader pack_grass_impostor_texture
{
  supports global_frame;

  cull_mode=none;
  z_write=false;
  z_test=false;

  POSTFX_VS_TEXCOORD(0, tc)

  ENABLE_ASSERT(ps)
  USE_IMPOSTOR_STRUCTS()
  INIT_LOAD_DEPTH_GBUFFER()
  USE_LOAD_DEPTH_GBUFFER()

  hlsl(ps) {
    Texture2D impostor_gbuf_a : register(t13);
    Texture2D impostor_gbuf_b : register(t14);
    Texture2D impostor_gbuf_c : register(t15);
  }

  USE_PACKED_TEXTURES()

  (ps)
  {
    texture_size@f4 = (texture_size.x, texture_size.y, 1/texture_size.x, 1/texture_size.y);
    depth_scale@f2 = (impostor_depth_scale.x, impostor_depth_scale.y);
  }

  hlsl(ps) {
    ImpostorParameters read_impostor_params_from_gbuf(uint2 tc)
    {
      ImpostorParameters ret;

      float4 diffuse = texelFetch(impostor_gbuf_a, tc, 0);
      float4 normal_translucency = texelFetch(impostor_gbuf_b, tc, 0);
      float4 ao_shadowing = texelFetch(impostor_gbuf_c, tc, 0);
      float translucency = normal_translucency.w;

      if (translucency >= 127.0 / 255)
      {
        translucency = saturate(translucency*2 - 1);
      }
      else
      {
        translucency = saturate(translucency / 0.49);
      }

      float depth = loadGbufferDepth(tc);
      if (depth >= 0.5) depth = (depth - 0.5) * depth_scale.x + depth_scale.y;
      else depth = 1e8;
      // depth = depth == 0 ? 1e8 : depth * depth_scale.x + depth_scale.y;

      ret.albedo = diffuse.rgb;
      ret.alpha = diffuse.a;
      ret.normal = normalize(normal_translucency.xyz*2 - 1);
      ret.depth = depth;
      ret.translucency = translucency;
      ret.roughness = ao_shadowing.y;

      return ret;
    }

    PackedTexture pack_ps(VsOutput input)
    {
      float2 tcTransformed = input.tc * texture_size.xy;
      int2 texCoord = int2(tcTransformed);
      int2 corner = texCoord*RENDER_OVERSCALE;

      ImpostorCombinedState state = init_combined_samples();

      for (uint x = 0; x < RENDER_OVERSCALE; x++)
        for (uint y = 0; y < RENDER_OVERSCALE; y++)
        {
          int2 samplePos = corner + int2(x, y);
          ImpostorParameters params = read_impostor_params_from_gbuf(samplePos);
          combine_impostor_samples(state, params);
        }

      ImpostorParameters params = combine_samples(state);
      return pack_impostor_params(params);
    }
  }
  compile("target_ps", "pack_ps");
}

shader grass_impostor_gen_mip
{
  supports global_frame;

  cull_mode=none;
  z_write=false;
  z_test=false;

  POSTFX_VS_TEXCOORD(0, tc)

  USE_READ_IMPOSTOR_PACKED_TEXTURES()
  USE_PACKED_TEXTURES()

  (ps)
  {
    texture_size@f4 = (texture_size.x, texture_size.y, 1/texture_size.x, 1/texture_size.y);
  }

  hlsl(ps) {

    PackedTexture pack_ps(VsOutput input)
    {
      int2 texCoord = int2(input.tc * texture_size.xy);

      ImpostorCombinedState state = init_combined_samples();

      const uint MIP_LEVEL_SCALE = 2;

      for (uint i = 0; i < MIP_LEVEL_SCALE; ++i)
      {
        for (uint j = 0; j < MIP_LEVEL_SCALE; ++j)
        {
          int2 samplePos = texCoord*MIP_LEVEL_SCALE + int2(i, j);

          ImpostorParameters params = read_impostor_params_from_packed_texture(samplePos);
          combine_impostor_samples(state, params);
        }
      }

      ImpostorParameters params = combine_samples(state);
      return pack_impostor_params(params);
    }
  }
  compile("target_ps", "pack_ps");
}
