include "ssr_base.dshl"

texture ssr_target_before_denoise;
int ssr_denoiser_tile;
texture blue_noise_tex;
float non_confident_inv_exposure = 0.1;
macro SSR_STOCHASTIC_RAY(code)
  (code) {
    blue_noise_tex@tex2d = blue_noise_tex;
    stochasticFrame@f1 = (ssr_frameNo.y);
    non_confident_exposure@f2 = (1 - non_confident_inv_exposure, non_confident_inv_exposure,0,0);
  }
  hlsl(code) {
    half reflection_tonemap_luminance(half3 color)
    {
      return luminance(color);
    }
    float2 SampleRandomVector2D(uint2 pixel, uint frame_index)
    {
      #define GOLDEN_RATIO  1.61803398875
      float2 E = texture2DAt(blue_noise_tex, pixel % 128).xy;
      return float2(frac(E.x + (uint(frame_index.x) & 0xFFu) * GOLDEN_RATIO),
                    frac(E.y + (uint(frame_index.x) & 0xFFu) * GOLDEN_RATIO));
    }

    float2 HammersleylRandomVector2D(uint2 pixel, uint frame_index)
    {
      uint2 random = ((pixel.xy + uint2(frame_index%4, (frame_index/4)%4)));
      #define NUM_TEMPORAL_RAYS 16
      return hammersley( ((random.x&3) + 3*(random.y&3))&(NUM_TEMPORAL_RAYS-1), NUM_TEMPORAL_RAYS, random );
    }
    float3 getReflectionRayDir(float3 pointToEyeDir, float3 N, uint2 pixelPos, half linear_roughness)
    {
      float2 E = SampleRandomVector2D(pixelPos.xy, uint(stochasticFrame)); //HammersleylRandomVector2D
      float3x3 tbnTransform = create_tbn_matrix(N);
      float3 viewDirTC = mul(pointToEyeDir, tbnTransform);
      float3 sampledNormalTC = linear_roughness < 0.004 ? float3(0,0,1) : importance_sample_GGX_VNDF(E, viewDirTC, linear_roughness);
      float3 reflectedDirTC = reflect(-viewDirTC, sampledNormalTC);
      return mul(reflectedDirTC, transpose(tbnTransform));
    }

    half LocalNeighborhoodKernelWeighted(half dist_sqr, half radius, half filterExp) {
      radius = half(radius + 1.h);
      return half(exp(-filterExp* dist_sqr / (radius * radius)));
    }
    float sampleGGXVNDFPDF(float ggx_alpha, float dotNH, float dotNV)
    {
      // Calculate NDF function
      float alpha2 = ggx_alpha*ggx_alpha;
      // GGX distribution
      float d = half(alpha2 / max(1e-8, pow2((dotNH * alpha2 - dotNH) * dotNH + 1))) * 1./PI;


      float dotNV2 = saturate(dotNV * dotNV);
      float s = alpha2 * (1.0f - dotNV2);
      float t = sqrt(s + dotNV2);
      float recipNormFactor = dotNV >= 0.0f ? t + saturate(dotNV) : s / (t + saturate(abs(dotNV)));
      return d / (2.0f * recipNormFactor);
    }
    half get_filter_exp(half linear_roughness, half confidence, float currentDepth)
    {
      half linearRoughnessW = get_is_rough_surface_param(linear_roughness);
      half filter_exp = (5.h - 1.h*linearRoughnessW)*confidence;
      filter_exp = lerp(filter_exp, filter_exp*confidence, saturate(scaled_prev_camera_translation/currentDepth));
      return filter_exp;
    }
    float atanh(float v) {
      return 0.5*log((1+v)/(1-v));
    }
    float AlphaToMacroNormalLength(float alpha)
    {
      float alpha2 = alpha * alpha;
      float a = sqrt(saturate(1.0f - alpha2));

      return a < 1e-6 ? 2.0f / 3.0f : a >= 0.9999 ? 1.0 : (a - alpha2 * atanh(a)) / (a * a * a);
    }
  }
endmacro

hlsl {
  #define MAX_REFLECTION_DIST 200
  #define SKY_DIST (MAX_REFLECTION_DIST-1)
  #define REFLECTION_DIST_ENCODE (256./SKY_DIST)
  #define REFLECTION_DIST_DECODE (1./REFLECTION_DIST_ENCODE)
}

macro SSR_READ_POINT_INFO(code)
  SSR_STOCHASTIC_RAY(code)
  hlsl(code) {
    struct PointInfo
    {
      half4 color;
      half3 normal;
      half linear_roughness;
      float3 rayDir;
      float3 cameraToPoint;
      float linearDepth;
      float PDF;
    };
    PointInfo calc_point_info(uint2 screenCoord)
    {
      if (any(screenCoord >= uint2(resolution)))
        return (PointInfo)0;
      half4 newFrame = texelFetch(ssr_target_before_denoise, screenCoord, 0);

      if (newFrame.a < 0)
        return (PointInfo)0;
      PointInfo p;
      float rawDepth = texelFetch(src_depth_tex, screenCoord, 0).x;
      p.linearDepth = linearize_z(rawDepth, zn_zfar.zw);
      p.color = newFrame;

      float2 screenCoordCenter = screenCoord + float2(0.5,0.5);
      float2 curViewTc = saturate(screenCoordCenter*ssr_target_size.zw);

      float3 viewVect = getViewVecOptimized(curViewTc);
      p.cameraToPoint = viewVect * p.linearDepth;
      half smoothness;
      unpack_material(screenCoord, p.normal, p.linear_roughness, smoothness);
      return p;
    }
    void calc_point_info_raydir(uint2 screenCoord, inout PointInfo p)
    {
      p.rayDir = getReflectionRayDir(-normalize(p.cameraToPoint), p.normal, screenCoord, p.linear_roughness);
    }
  }
endmacro

int ssr_denoiser_type = 0;
interval ssr_denoiser_type: manual<1, reblur<2, relax<3, simple;

shader ssr_temporal_denoise_cs
{
  ENABLE_ASSERT(cs)

  SETUP_SSR(cs)
  VIEW_VEC_OPTIMIZED(cs)
  INIT_TEXTURES(cs)
  SSR_BASE(cs)
  SSR_REPROJECTION(cs)
  hlsl(cs) {
    //#undef USE_PREV_DOWNSAMPLED_NORMALS
  }
  INIT_ZNZFAR_STAGE(cs)
  SSR_GET_TEMPORAL_REPROJECTION_DUO(cs)

  if (compatibility_mode == compatibility_mode_on) { dont_render; }

  (cs) {
    ssr_target_before_denoise@smp2d = ssr_target_before_denoise;
    output@uav = ssr_target hlsl { RWTexture2D<float4> output@uav; };
    resolution@f2 = get_dimensions(ssr_target, 0);
    ssr_denoiser_tile@i1 = (ssr_denoiser_tile);
  }
  SSR_READ_POINT_INFO(cs)
  SSR_USE_EXPOSURE(cs)

  hlsl(cs) {
    #define FILTER 4
    #define TILE 8
    #define SHARED_ROW_SIZE (FILTER*2 + TILE)
    #define TOTAL_SIZE (SHARED_ROW_SIZE*SHARED_ROW_SIZE)
    #define WORK_PER_THREAD ((TOTAL_SIZE + (TILE*TILE) - 1)/(TILE*TILE))


    groupshared float4 worldPos[TOTAL_SIZE];
    #define ENCODE_HALVES 0

    #if ENCODE_HALVES
    groupshared uint4 reflectDir_rayTracedResults[TOTAL_SIZE];
    uint2 encode_float4(float4 v) {uint4 vi = f32tof16(v);return vi.xy|(vi.zw<<16);}
    float4 decode_float4(uint2 v) {return float4(f16tof32(v.xy), f16tof32(v.xy>>16));}
    #else
    groupshared float4 reflectDir[TOTAL_SIZE];
    groupshared float4 rayTracedResults[TOTAL_SIZE];
    #endif
    uint get_local_index(uint2 localCoord) {return localCoord.y*SHARED_ROW_SIZE + localCoord.x;}

    void write_shared_info(uint2 localCoord, PointInfo p)
    {
      uint localIndex = get_local_index(localCoord);
      if (localIndex >= TOTAL_SIZE)
        return;
      float4 rD = float4(p.normal, p.linear_roughness);
      #if ENCODE_HALVES
      reflectDir_rayTracedResults[localIndex] = uint4(encode_float4(rD), encode_float4(p.color));
      #else
      reflectDir[localIndex] = rD;
      rayTracedResults[localIndex] = p.color;
      #endif
      worldPos[localIndex] = float4(p.cameraToPoint, p.linearDepth);
    }
    PointInfo read_shared_info(uint2 localCoord)
    {
      uint localIndex = get_local_index(localCoord);
      if (localIndex >= TOTAL_SIZE)
        return (PointInfo)0;
      PointInfo p;
      float4 v;
      #if ENCODE_HALVES
      uint4 vi = reflectDir_rayTracedResults[localIndex];
      p.normal = 0;//missing
      v = decode_float4(vi.xy);
      p.rayDir = v.xyz; p.linear_roughness = v.a;
      v = decode_float4(vi.zw);
      p.color = v;
      #else
      v = reflectDir[localIndex];
      p.normal = 0;//missing
      p.rayDir = v.xyz; p.linear_roughness = v.a;
      p.color = rayTracedResults[localIndex];
      #endif
      v = worldPos[localIndex];
      p.cameraToPoint = v.xyz; p.linearDepth = v.a;
      return p;
    }
    void write_shared_info_raydir(uint localIndex, float3 rayDir, half linear_roughness)
    {
      if (localIndex < TOTAL_SIZE)
      {
      #if ENCODE_HALVES
        reflectDir_rayTracedResults[localIndex].xy = encode_float4(float4(rayDir, linear_roughness));
      #else
        reflectDir[localIndex].xyz = rayDir;
      #endif
      }
    }
    void read_shared_normal_roughness(uint localIndex, out half3 normal, out half linear_roughness)
    {
      #if ENCODE_HALVES
      float4 v = (localIndex < TOTAL_SIZE) ? decode_float4(reflectDir_rayTracedResults[localIndex].xy) : 0;
      #else
      float4 v = (localIndex < TOTAL_SIZE) ? reflectDir[localIndex] : 0;
      #endif
      normal = v.xyz;
      linear_roughness = v.w;
    }
    void read_shared_pos_depth(uint localIndex, out float3 cameraToPoint, out float linearDepth)
    {
      float4 v = (localIndex < TOTAL_SIZE) ? worldPos[localIndex] : 0;
      cameraToPoint = v.xyz;
      linearDepth = v.a;
    }
    void update_shared_info_raydir(uint2 localCoord, uint2 screenCoord)
    {
      uint localIndex = get_local_index(localCoord);
      if (localIndex >= TOTAL_SIZE)
        return;
      half3 normal;
      half linear_roughness;
      read_shared_normal_roughness(localIndex, normal, linear_roughness);
      PointInfo p;
      write_shared_info_raydir(localIndex, getReflectionRayDir(-normalize(worldPos[localIndex].xyz), normal, screenCoord, linear_roughness), linear_roughness);
    }
    groupshared uint some_used_in_group;

    #include <BRDF.hlsl>
    [numthreads(TILE, TILE, 1)]
    void ssr_temporal_denoise_cs(uint2 screenCoord : SV_DispatchThreadID, uint2 Gid : SV_GroupID, uint2 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex)
    {
      if (GI == 0)
        some_used_in_group = 0;
      GroupMemoryBarrierWithGroupSync();

      PointInfo currentPoint = calc_point_info(screenCoord);

      #if WAVE_INTRINSICS
      if (!WaveActiveAllTrue(currentPoint.linearDepth <= 0))
      {
        if (WaveIsHelperLane())
          InterlockedOr(some_used_in_group, 1);
      }
      #else
        if (currentPoint.linearDepth > 0)
          InterlockedOr(some_used_in_group, 1);
      #endif
      GroupMemoryBarrierWithGroupSync();
      if (!some_used_in_group)
      {
        texture2DAt(output, screenCoord) = 0;
        return;
      }

      write_shared_info(GTid + FILTER, currentPoint);

      {
      UNROLL
      for (uint i = 1; i < WORK_PER_THREAD; ++i)
      {
        uint2 localCoord = (GTid + FILTER + uint2(i&1, i>>1)*TILE)%SHARED_ROW_SIZE;
        write_shared_info(localCoord, calc_point_info(Gid*TILE + localCoord - FILTER));
      }
      }

      GroupMemoryBarrierWithGroupSync();
      float ggx_alpha = max(pow2(currentPoint.linear_roughness), 1e-4);
      float4 scenePlaneScaled = float4(currentPoint.normal, dot(currentPoint.normal, currentPoint.cameraToPoint)) / currentPoint.linearDepth;

      half neighboorhoodVariance = 0;
      {
        #define CONFIDENCE_FILTER 3
        half confidence = 0;
        UNROLL
        for (uint xy = 0, xye = (CONFIDENCE_FILTER*2+1)*(CONFIDENCE_FILTER*2+1); xy < xye; ++xy)
        {
          int x = int(xy%uint(CONFIDENCE_FILTER*2+1)) - CONFIDENCE_FILTER;
          int y = int(xy/uint(CONFIDENCE_FILTER*2+1)) - CONFIDENCE_FILTER;
          if (x != 0 || y != 0)
          {
            uint localIndex = get_local_index(int2(GTid + FILTER) + int2(x,y));
            half3 neighboorNormal;
            half neighboor_linear_roughness;
            read_shared_normal_roughness(localIndex, neighboorNormal, neighboor_linear_roughness);
            float3 cameraToPoint;
            float linearDepth;
            read_shared_pos_depth(localIndex, cameraToPoint, linearDepth);

            float relativeDepthDifference = pow2(dot(float4(cameraToPoint.xyz, -1), scenePlaneScaled));
            float depthWeight = exp2(-1000 * relativeDepthDifference);
            depthWeight *= saturate(2 - 10*abs(currentPoint.linearDepth - linearDepth)/currentPoint.linearDepth);
            if (depthWeight > 1e-4 && linearDepth > 0)
            {
              half sampleVariance = 1-pow16(dot(neighboorNormal, currentPoint.normal)) + 1-pow8(1-abs(neighboor_linear_roughness - currentPoint.linear_roughness));
              confidence += 1-sampleVariance;
            }
          }
        }
        half filterW = min3((CONFIDENCE_FILTER*2+1), screenCoord.x+CONFIDENCE_FILTER+1, resolution.x - screenCoord.x+CONFIDENCE_FILTER+1);
        half filterH = min3((CONFIDENCE_FILTER*2+1), screenCoord.y+CONFIDENCE_FILTER+1, resolution.y - screenCoord.y+CONFIDENCE_FILTER+1);
        neighboorhoodVariance = saturate(1 - confidence * rcp(filterH*filterW - 1));
      }

      calc_point_info_raydir(screenCoord, currentPoint);
      write_shared_info_raydir(get_local_index(GTid + FILTER), currentPoint.rayDir, currentPoint.linear_roughness);

      {
      UNROLL
      for (uint i = 1; i < WORK_PER_THREAD; ++i)
      {
        uint2 localCoord = (GTid + FILTER + uint2(i&1, i>>1)*TILE)%SHARED_ROW_SIZE;
        update_shared_info_raydir(localCoord, Gid*TILE + localCoord - FILTER);
      }
      }

      GroupMemoryBarrierWithGroupSync();

      half4 newFrame = currentPoint.color;
      //texture2DAt(output, screenCoord) = half4(newFrame.rgb, 1);
      //return;
      half4 prevFrame = 0;
      half reprojectionWeight = 0, virtualWeight = 0;

      float3 viewDir = normalize(currentPoint.cameraToPoint);
      half linear_roughness = currentPoint.linear_roughness;
      half3 normal = currentPoint.normal;
      float w = currentPoint.linearDepth;
      float3 cameraToPoint = currentPoint.cameraToPoint;
      float3 rayDir = currentPoint.rayDir;

      half offsetedDist = max(0, abs(currentPoint.color.a));
      half alpha = frac(offsetedDist);
      half reflectionDistance = max(0, offsetedDist - alpha)*REFLECTION_DIST_DECODE;
      alpha = reflectionDistance > SKY_DIST ? 0 : 1-alpha;
      half originalNeighboorhoodVariance = neighboorhoodVariance;
      half originalConfidence = saturate(1.01h-originalNeighboorhoodVariance);
      half relativePixelTranslation = 0;
      if (currentPoint.linearDepth > 0)
      {
        float2 screenCoordCenter = screenCoord + float2(0.5,0.5);
        float2 curViewTc = saturate(screenCoordCenter*ssr_target_size.zw);

        half disocclusionWeightAtten = get_ssr_reprojection_with_weight(relativePixelTranslation, neighboorhoodVariance, cameraToPoint, curViewTc, normal, linear_roughness, reflectionDistance, w, prevFrame, virtualWeight);
        //rougher surfaces should be more relaxed, to fight noise
        //todo: add pixel age, so we can more correctly fight noise
        const half roughnessWeightFactor = lerp(0.97h, 0.8h, exp2(-60*linear_roughness));
        reprojectionWeight = disocclusionWeightAtten * roughnessWeightFactor;
      } else
      {
        texture2DAt(output, screenCoord) = 0;
        return;
      }

      half confidence = saturate(1.01h - neighboorhoodVariance);
      half filterExp = get_filter_exp(linear_roughness, confidence, w);
      //half exposure = max(1e-6h, PREV_FRAME_PACK(half3(1,1,1)).x);
      half exposure = max(1e-6h, PREV_FRAME_PACK(half3(1,1,1)).x*rcp(confidence*half(non_confident_exposure.x) + half(non_confident_exposure.y)));//to reduce fire-flies more
      half invExposure = rcp(exposure);

      half4 sampleColor = half4(newFrame.rgb, alpha);
      half4 avgSq = sampleColor*sampleColor, avg = sampleColor;
      half baseLuma = reflection_tonemap_luminance(sampleColor.rgb);
      sampleColor.rgb *= rcp(invExposure + baseLuma);
      half4 averagedColor = sampleColor; half totalW = 1;
      #define SFILTER FILTER
      {
        LOOP
        for (uint xy = 0, xye = (SFILTER*2+1)*(SFILTER*2+1); xy < xye; ++xy)
        {
          int x = int(xy%uint(SFILTER*2+1)) - SFILTER;
          int y = int(xy/uint(SFILTER*2+1)) - SFILTER;
          if (x != 0 || y != 0)
          {
            PointInfo neighboor = read_shared_info(int2(GTid + FILTER) + int2(x,y));

            float3 neighboorViewDir = normalize(neighboor.cameraToPoint);
            float relativeDepthDifference = pow2(dot(float4(neighboor.cameraToPoint, -1), scenePlaneScaled));
            float depthWeight = exp2(-1000 * relativeDepthDifference);
            depthWeight *= saturate(2 - 10*abs(currentPoint.linearDepth - neighboor.linearDepth)/currentPoint.linearDepth);
            half sampleWeight = neighboor.linearDepth > 0 ? depthWeight : 0;

            float3 CurrentReflection = neighboor.rayDir;
            float3 HalfVec = normalize(CurrentReflection.xyz - viewDir);
            float NoH = saturate(dot(currentPoint.normal, HalfVec));
            float NoL = saturate(dot(currentPoint.normal, CurrentReflection.xyz));
            float D_GGX = NoL*BRDF_distribution( ggx_alpha, NoH );

            sampleWeight *= D_GGX;

            half4 neighboorColor = neighboor.color;
            half neighboorOffsetedDist = abs(neighboorColor.a);
            neighboorColor.a = frac(offsetedDist);
            half neighboorReflectionDist = (neighboorOffsetedDist - neighboorColor.a)*REFLECTION_DIST_DECODE;
            neighboorColor.a = neighboorReflectionDist > SKY_DIST ? 0 : 1-neighboorColor.a;

            half4 sampleColor = neighboorColor;

            sampleWeight *= LocalNeighborhoodKernelWeighted(x*x + y*y, 3, filterExp);

            avgSq += (sampleWeight*sampleColor)*sampleColor;
            avg += (sampleWeight*sampleColor);

            ///sampleColor -
            half luma = reflection_tonemap_luminance(sampleColor.rgb);
            sampleColor.rgb *= rcp(invExposure + luma);
            averagedColor += sampleColor*sampleWeight;
            totalW += sampleWeight;
          }
        }
      }
      half invW = rcp(totalW);
      averagedColor *= invW;
      avgSq *= invW;
      avg *= invW;
      half4 dev = sqrt(max(avgSq - avg*avg, 0));
      averagedColor.rgb *= invExposure/(1 - reflection_tonemap_luminance(averagedColor.rgb));
      newFrame = averagedColor;
      // if alternate reflections
      ##if (ssr_alternate_reflections == yes)
      newFrame.a = 1;
      ##endif
      newFrame.rgb *= newFrame.a;

      half4 prevFrameClamped = clamp(prevFrame, max(newFrame - dev, 0), newFrame + dev);
      //clampedHistory = lerp(prevFrame, clampedHistory, saturate(scaled_prev_camera_translation/w));
      half lumaA = reflection_tonemap_luminance(prevFrame.rgb), lumaB = reflection_tonemap_luminance(prevFrameClamped.rgb);
      half temporal_blend = pow2(clamp(max(lumaA - lumaB - min(lumaA, lumaB), 0.0f) / max(max(lumaA, lumaB), 1e-4f), 0.0f, 1.f));

      prevFrame = lerp(prevFrame, prevFrameClamped, lerp(temporal_blend, 1, originalConfidence)*relativePixelTranslation*(1-0.95*get_is_rough_surface_param(currentPoint.linear_roughness)));
      newFrame = force_ignore_history == 0 ? lerp(newFrame, prevFrame, reprojectionWeight) : newFrame;

      FLATTEN
      if (any(!isfinite(newFrame)))
        newFrame = float4(0,0,0,0);

      texture2DAt(output, screenCoord) = newFrame;
    }
  }

  compile("cs_5_0", "ssr_temporal_denoise_cs");
}

float4 ssr_tile_jitter = (0, 0, 0, 0);

int denoiser_frame_index;

texture packed_mv;
texture denoised_ssr;

macro RESOLVE_BY_NEIGHBOURS(code)
  hlsl(code) {
    #include <BRDF.hlsl>

    groupshared float3 ReflectVecTarg[groupthreads];
    half GetNeighborhoodVariance(uint2 GTid, uint filterSize, float3 normal, float3 cameraToPoint, float linear_roughness, float currentDepth, inout half averageRoughness)
    {
      averageRoughness = linear_roughness;
      half initial = AlphaToMacroNormalLength(pow2(linear_roughness));
      half3 avgNormal = normal*initial;
      half avgNormalW = 1;
      half confidence = 0;
      float4 scenePlaneScaled = float4(normal, dot(normal, cameraToPoint)) / currentDepth;
      for (uint y = GTid.y - min(filterSize, GTid.y), maxY = min(GTid.y + filterSize, TILE_SIZE - 1); y <= maxY; y++)
      {
        for (uint x = GTid.x - min(filterSize, GTid.x), maxX = min(GTid.x + filterSize, TILE_SIZE - 1); x <= maxX; x++)
        {
          if (x != GTid.x || y != GTid.y)
          {
            uint groupIndex = y*TILE_SIZE + x;

            ##assert(groupIndex < groupthreads, "[%s:%.f] Out of bounds: groupthreads size is %d, but access to %d (%d:%d max %d:%d)", _FILE_, __LINE__, groupthreads, groupIndex, x, y, maxX, maxY);

            float4 neighboordNormalRoughness = ColorTarg[groupIndex];
            float4 neighboorWpos = wposDepthTarg[groupIndex];
            float relativeDepthDifference = pow2(dot(float4(wposDepthTarg[groupIndex].xyz, -1), scenePlaneScaled));
            float depthWeight = exp2(-1000 * relativeDepthDifference);
            depthWeight *= saturate(2 - 10*abs(currentDepth - wposDepthTarg[groupIndex].w)/currentDepth);
            half weight = neighboordNormalRoughness.w >= 0 ? depthWeight : 0;

            avgNormal += weight*neighboordNormalRoughness.xyz * AlphaToMacroNormalLength(pow2(neighboordNormalRoughness.w));
            avgNormalW += weight;
            if (weight > 1e-4)
            {
              half sampleVariance = 1-pow16(dot(neighboordNormalRoughness.xyz, normal)) + 1-pow8(1-abs(neighboordNormalRoughness.w - linear_roughness));
              //variance += sampleVariance;
              //samples += 1;
              confidence += 1-sampleVariance;
            }
          }
        }
      }
      avgNormal /= avgNormalW;
      half avgNormalLen = length(avgNormal);
      float aLR = (1 - linear_roughness)/(2./3. - initial);
      float bLR = linear_roughness - initial*aLR;
      averageRoughness = saturate(aLR*(avgNormalLen - initial) + linear_roughness);

      averageRoughness = avgNormalLen > initial ? linear_roughness : avgNormalLen <= 2.0/3.0f ? 1 : averageRoughness;
      averageRoughness = linear_roughness;
      half maxSamples = (min(GTid.y + filterSize, TILE_SIZE-1)+1 - (GTid.y - min(filterSize, GTid.y))) * (min(GTid.x + filterSize, TILE_SIZE-1) + 1 - (GTid.x - min(filterSize, GTid.x))) - 1;
      //return samples > 0 ? min(saturate(samples / (2*filterSize*filterSize)), saturate(variance / samples)) : 1;
      return saturate(1 - confidence / maxSamples);
    }

    /////////////////////////////////////
    // Resolve function
    // GTid - groupthread ID
    // ray - camera-to-pixel vector
    // normal - view space normal
    // PerfectReflection
    // pixel - view space coords of pixel
    // alpha2, NdV - BRDF supporting values
    // uints2 x_samp, y_samp - size of mini-tile
    /////////////////////////////////////
    float4 ResolvePixels(float4 val, uint2 GTid, float3 pointToEyeDir, float3 normal, float3 cameraToPoint, float linear_roughness, uint filterSize, float currentDepth, out float4 maxDeviation, float neighboorhoodVariance)
    {
      half confidence = saturate(1.01h - neighboorhoodVariance);
      half filterExp = get_filter_exp(linear_roughness, confidence, currentDepth);
      //half exposure = max(1e-6h, PREV_FRAME_PACK(half3(1,1,1)).x);
      half curExposure = PREV_FRAME_PACK(half3(1,1,1)).x;
      half exposure = max(1e-6h, curExposure*rcp(confidence*half(non_confident_exposure.x) + half(non_confident_exposure.y)));//to reduce fire-flies more
      half invExposure = rcp(exposure);
      //half invMaxBrightness = curExposure/10;
      half totalWeight = 0;
      half4 averagedColor = 0;
      maxDeviation = 0;
      float ggx_alpha = max(pow2(linear_roughness), 1e-4);
      float4 scenePlaneScaled = float4(normal, dot(normal, cameraToPoint)) / currentDepth;
      float NoV = saturate(dot(pointToEyeDir, normal));
      half4 avgSq = 0, avg = 0;

      for (uint y = GTid.y - min(filterSize, GTid.y), maxY = min(GTid.y + filterSize, TILE_SIZE - 1); y <= maxY; y++)
      {
        for (uint x = GTid.x - min(filterSize, GTid.x), maxX = min(GTid.x + filterSize, TILE_SIZE - 1); x <= maxX; x++)
        {
          uint groupIndex = y*TILE_SIZE + x;

          ##assert(groupIndex < groupthreads, "[%s:%.f] Out of bounds: groupthreads size is %d, but access to %d (%d:%d max %d:%d)", _FILE_, __LINE__, groupthreads, groupIndex, x, y, maxX, maxY);

          // calculate reflection with compensation for neighboring pixels
          float3 CurrentReflection = ReflectVecTarg[groupIndex];

          // supporting values
          float3 HalfVec = normalize(CurrentReflection.xyz + pointToEyeDir);
          float NoH = saturate(dot(normal, HalfVec));
          float NoL = saturate(dot(normal, CurrentReflection.xyz));
          float D_GGX = NoL*BRDF_distribution( ggx_alpha, NoH );

          float4 sampleColor = ColorTarg[groupIndex];

          // We assume that the hit point of the neighbor's ray is also visible for our ray, and we blindly pretend
          // that the current pixel shot that ray. To do that, we treat the hit point as a tiny light source. To calculate
          // a lighting contribution from it, we evaluate the BRDF. Finally, we need to account for the probability of getting
          // this specific position of the "light source", and that is approximately 1/PDF, where PDF comes from the neighbor.
          // Finally, the weight is BRDF/PDF. BRDF uses the local pixel's normal and roughness, but PDF comes from the neighbor.

          // Even though from a mathematical point of view we should divide by PDF.
          // This adds a significant amount of noise and fireflyies. So ignore that part.
          float hitPDF = 1.0;
          float sampleWeight = D_GGX / max(1e-5, hitPDF);
          //sampleWeight = sampleGGXVNDFPDF(ggx_alpha, NoH, NoV);
          //float4 neighboorWpos = wposDepthTarg[groupIndex];
          float relativeDepthDifference = pow2(dot(float4(wposDepthTarg[groupIndex].xyz, -1), scenePlaneScaled));
          float depthWeight = exp2(-1000 * relativeDepthDifference);
          depthWeight *= saturate(2 - 10*abs(currentDepth - wposDepthTarg[groupIndex].w)/currentDepth);
          sampleWeight *= depthWeight;
          //maxDeviation = max(maxDeviation, sampleWeight*abs(sampleColor - val));
          //maxDeviation += sampleWeight*abs(sampleColor - val);

          float2 toCenterVect = float2(float(x) - float(GTid.x), float(y) - float(GTid.y));
          sampleWeight *= LocalNeighborhoodKernelWeighted(dot(toCenterVect, toCenterVect), 3, filterExp);
          //reflectionDistanceW += CurrentReflection.w * sampleWeight;

          totalWeight += sampleWeight; // Integration of microfacet distribution (PDF)

          //sampleColor.rgb /= max(reflection_tonemap_luminance(sampleColor.rgb)*invMaxBrightness,1);
          avgSq += (sampleWeight*sampleColor)*sampleColor;
          avg += (sampleWeight*sampleColor);
          //fireflies
          sampleColor.rgb *= rcp(invExposure + reflection_tonemap_luminance(sampleColor.rgb));

          averagedColor += sampleWeight*sampleColor; // Integration of BRDF weighted color
        }
      }
      //reflectionDistanceW /= TotalWeight;
      // divide by sum NDF
      half invW = rcp(totalWeight);
      averagedColor *= invW;
      avgSq *= invW;
      avg *= invW;
      //maxDeviation *= invW;
      maxDeviation = sqrt(max(avgSq - avg*avg, 0));

      //fireflies
      averagedColor.rgb *= invExposure/(1 - reflection_tonemap_luminance(averagedColor.rgb));

      return averagedColor;
    }
  }
endmacro

float4 ssr_hit_dist_params;
shader tile_ssr_compute
{
  if (compatibility_mode == compatibility_mode_on) { dont_render; }

  SSR_COMMON(cs)
  SSR_CALCULATE(cs)
  INIT_ZNZFAR_STAGE(cs)
  SSR_STOCHASTIC_RAY(cs)

  if (ssr_alternate_reflections == yes) {
    INIT_ENVI_SPECULAR_BASE(cs)
    GET_ALTERNATE_REFLECTIONS(cs)
    GET_TRANSLUCENT_ALTERNATE_REFLECTIONS(cs)
    INIT_BRUNETON_FOG(cs)
    BASE_USE_BRUNETON_FOG(cs)
  }
  SSR_GET_TEMPORAL_REPROJECTION_DUO(cs)
  bool manual_denoising = ssr_denoiser_type == manual || ssr_denoiser_type == simple;
  if (!manual_denoising && !hardware.dx12) { dont_render; }
  if (!manual_denoising && ssr_quality == low) { dont_render; }
  if (!manual_denoising && ssr_alternate_reflections == no) { dont_render; }
  if (!manual_denoising && in_editor_assume == yes) { dont_render; }

  (cs) {
    ssr_tile_jitter@f2 = (ssr_tile_jitter);
    hit_dist_params@f4 = ssr_hit_dist_params;
    denoiser_frame_index@i1 = denoiser_frame_index;
  }

  hlsl(cs) {
    #define TILE_SIZE 8
    #define groupthreads (TILE_SIZE*TILE_SIZE)

    groupshared float4 ColorTarg[groupthreads];
    groupshared float4 wposDepthTarg[groupthreads];
  }

  if (manual_denoising)
  {
    RESOLVE_BY_NEIGHBOURS(cs)
  }
  if (ssr_alternate_reflections != yes) {
    if (ssr_denoiser_type != manual) { SSR_ENV_RESOLVE(cs) }
  }

  hlsl(cs) {
    ##if (!manual_denoising)
      #include <Include/NRDEncoding.hlsli>
      #include <Include/NRD.hlsli>
    ##endif
    RWTexture2D<float4> Result:register(u0);

    ##if (ssr_alternate_reflections == yes)
    void applyFogToReflection(float3 view, float dist, inout float3 color)
    {
      half3 add,loss;
      get_bruneton_fog(view, dist, loss, add);
      color = color*loss + add;
    }
    ##endif

    #define BLOCK_SIZE_W 8
    #define BLOCK_SIZE_H 8

    #define SSR_FP16_MAX 65504.0 // fp16 friendly max
    [numthreads(BLOCK_SIZE_W,BLOCK_SIZE_H,1)]
    void tile_ssr_cs( uint2 Groupid : SV_GroupID, uint2 DTid : SV_DispatchThreadID, uint2 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex )
    {
      ##if manual_denoising
        #define INITIAL_REFLEC_DIST 0
      ##else
        #define INITIAL_REFLEC_DIST NRD_FP16_MAX
      ##endif

      uint2 screenCoord = DTid;
      uint2 outputCoord = DTid;
      ##if (!manual_denoising)
        screenCoord.x *= 2;

        bool evenFrame = ( denoiser_frame_index & 1 ) == 0;
        bool evenLine  = ( screenCoord.y & 1 ) == 0;

        if ( evenFrame == evenLine )
          screenCoord.x++;
      ##else
        int2 scr = int2(screenCoord) - select(bool2(ssr_tile_jitter), int2(BLOCK_SIZE_W/2, BLOCK_SIZE_H/2), int2(0,0));
        uint2 screenCoordOfs = clamp(scr, 0, ssr_target_size.xy-1);
        //uint2 screenCoordOfs = uint2(scr)%uint2(ssr_target_size.xy);
        bool invalidPixel = any(scr != int2(screenCoordOfs));
        screenCoord = screenCoordOfs;
        outputCoord = uint2(scr);
        ##if ssr_denoiser_type != simple
          #define TEMPORAL_IN_ONE_PASS 1
        ##endif
      ##endif

      float2 screenCoordCenter = screenCoord + float2(0.5,0.5);

      float2 curViewTc = saturate(screenCoordCenter*ssr_target_size.zw);
      float3 viewVect = getViewVecOptimized(curViewTc);
      float3 viewDir = normalize(viewVect);

      half3 normal;
      half linear_roughness;
      half smoothness;
      unpack_material(screenCoord, normal, linear_roughness, smoothness);

      float rawDepth = tex2Dlod(src_depth_tex, float4(curViewTc, 0, 0)).x;

      float w = linearize_z(rawDepth, zn_zfar.zw);
      float3 cameraToPoint = viewVect * w;
      bool NEEDSSR = (linear_roughness < CALC_SSR_ROUGHNESS_THRESHOLD) && (w < 0.5*zn_zfar.y);

      half averageRoughness = linear_roughness;
      ##if (manual_denoising)
        wposDepthTarg[GI] = float4(cameraToPoint, w);
        ColorTarg[GI] = float4(normal, linear_roughness);
        GroupMemoryBarrierWithGroupSync();
        half neighboorhoodVariance = 0;
        BRANCH
        if (NEEDSSR)
          neighboorhoodVariance = GetNeighborhoodVariance(GTid, 3, normal, cameraToPoint, linear_roughness, w, averageRoughness);
      ##endif

      float3 worldPos = world_view_pos.xyz + cameraToPoint;
      float3 realWorldPos = ssr_world_view_pos.xyz + cameraToPoint;
      uint2 pixelPos = screenCoord;
      float3 N = normal;
      float linearDepth = w;

      float4 newFrame = 0;
      float3 capturePoint = 0;
      float4 result = 0;
      float2 oldUv = 0;
      float reflectionDistance = INITIAL_REFLEC_DIST;

      #if SSR_TRACEWATER == 1
        if (underwater_params.w * (realWorldPos.y - water_level) < 0)
          NEEDSSR = false;
      #endif

      float3 R = float3(0, 0, 0);

      BRANCH
      if (NEEDSSR)
      {
        float stepOfs = interleavedGradientNoiseFramed(pixelPos.xy, uint(SSRParams.z)&7) - 0.25 + 1+ averageRoughness;

        R = getReflectionRayDir(-viewDir, N, pixelPos.xy, averageRoughness);

        #if SSR_TRACEWATER == 1
          float4 hit_uv_z_fade = hierarchRayMarch(curViewTc, R, averageRoughness, w, cameraToPoint, stepOfs, globtm_no_ofs_psf, water_level-realWorldPos.y+worldPos.y);
        #else
          float4 hit_uv_z_fade = hierarchRayMarch(curViewTc, R, averageRoughness, w, cameraToPoint, stepOfs, globtm_no_ofs_psf, 0);
        #endif

        // if there was a hit
        BRANCH if( hit_uv_z_fade.z > 0 )
        {
          const float linearZHit = ssr_linearize_z(hit_uv_z_fade.z);
          reflectionDistance = length(cameraToPoint - getViewVecOptimized(hit_uv_z_fade.xy) * linearZHit);
          newFrame = sample_vignetted_color( float3(hit_uv_z_fade.xy, linearZHit), averageRoughness, linearZHit, cameraToPoint, N, realWorldPos);
        }
        // alternate reflections for puddles, if presented
        half ssrResultPrecision = newFrame.a;
        get_planar_reflections(newFrame, ssrResultPrecision, worldPos, normal, curViewTc);

        bool hitSky = hit_uv_z_fade.z == 0 && hit_uv_z_fade.w != 0;
        hitSky = hitSky && all(hit_uv_z_fade.xy>0);
        hitSky = hitSky && all(hit_uv_z_fade.xy<1);
        ##if (ssr_alternate_reflections != yes)
          if (hitSky || newFrame.a < 0.001)
            reflectionDistance = SSR_FP16_MAX;
        ##endif
        ##if (ssr_alternate_reflections == yes)
          if (newFrame.a < 1)
          {
            half4 alternateRefl = 0;
            if (!hitSky)
            {
              get_alternate_reflections(alternateRefl, reflectionDistance, pixelPos, R, cameraToPoint, normal, false, false);
              if (alternateRefl.a > 0)
              {
                float len = length(reflectionDistance*R + cameraToPoint);
                applyFogToReflection((reflectionDistance*R + cameraToPoint)*rcp(max(1e-6,len)), len, alternateRefl.rgb);
              }
            }
            if (alternateRefl.a < 1)
            {
              alternateRefl.rgb = texCUBElod(envi_probe_specular, float4(R, 0)).rgb;
              reflectionDistance = SSR_FP16_MAX;
            }
            newFrame = half4(lerp(alternateRefl.rgb, newFrame.rgb, newFrame.a), 1);
            //newFrame.a = reflectionDistance < 1000;
            #if !TEMPORAL_IN_ONE_PASS
            newFrame.a = alternateRefl.a;
            #endif
            //newFrame = alternateRefl.a > 0 ? half4(lerp(alternateRefl.rgb, newFrame.rgb, newFrame.a), alternateRefl.a) : newFrame;
          }
          half4 light_transmittance = get_translucent_alternate_reflections(cameraToPoint, R, reflectionDistance);
          newFrame.rgb = newFrame.rgb*light_transmittance.a + light_transmittance.rgb;

        //##elif (ssr_denoiser_type != manual)
        //  half3 enviLight = GetEnvLight(worldPos, w, R, normal, averageRoughness);
        //  newFrame.rgb = lerp(enviLight, newFrame.rgb, newFrame.a);
        ##endif
      }

      if (any(!isfinite(newFrame)))
      {
        newFrame = float4(0,0,0,0);
      }

      /////////////////////////////////////////////////
      // Temporal reprojection
      /////////////////////////////////////////////////
      half reprojectionWeight = 0, virtualWeight = 0;
      #if TEMPORAL_IN_ONE_PASS
        half confidence = saturate(1.01h - neighboorhoodVariance);
        half4 prevFrame = 0;
        half relativePixelTranslation = 0;
        BRANCH
        if(NEEDSSR)
        {
          half disocclusionWeightAtten = get_ssr_reprojection_with_weight(relativePixelTranslation, neighboorhoodVariance, cameraToPoint, curViewTc, normal, averageRoughness, reflectionDistance, w, prevFrame, virtualWeight);
          //rougher surfaces should be more relaxed, to fight noise
          //todo: add pixel age, so we can more correctly fight noise
          const half roughnessWeightFactor = lerp(0.97h, 0.8h, exp2(-60*averageRoughness));
          reprojectionWeight = disocclusionWeightAtten * roughnessWeightFactor;
        }
      #endif

      ##if (manual_denoising)

        ColorTarg[GI] = newFrame;
        ReflectVecTarg[GI] = R;
        GroupMemoryBarrierWithGroupSync();
        half4 maxDev = 0;
        BRANCH
        if (NEEDSSR)
        {
          uint res_Params = 3;
          newFrame = ResolvePixels(newFrame, GTid, -viewDir, normal, cameraToPoint, averageRoughness, res_Params, w, maxDev, neighboorhoodVariance);
        }
      ##endif

      #if TEMPORAL_IN_ONE_PASS
        half4 minNeighboorhood = max(newFrame-maxDev, 0), maxNeighboorhood = newFrame+maxDev;
        minNeighboorhood.rgb *= minNeighboorhood.a; maxNeighboorhood.rgb *= min(1, maxNeighboorhood.a);
        newFrame.rgb *= newFrame.a;
        half4 prevFrameClamped = clamp(prevFrame, minNeighboorhood, maxNeighboorhood);
        half lumaA = reflection_tonemap_luminance(prevFrame.rgb), lumaB = reflection_tonemap_luminance(prevFrameClamped.rgb);
        half temporal_blend = pow2(clamp(max(lumaA - lumaB - min(lumaA, lumaB), 0.0f) / max(max(lumaA, lumaB), 1e-4f), 0.0f, 1.f));
        prevFrame = lerp(prevFrame, prevFrameClamped, lerp(temporal_blend, 1, confidence)*relativePixelTranslation*(1-0.95*get_is_rough_surface_param(averageRoughness)));

        newFrame = force_ignore_history == 0 ? lerp(newFrame, prevFrame, reprojectionWeight) : newFrame;
      #endif

      result = newFrame;

      if (any(!isfinite(result)))
        result = float4(0,0,0,0);

      ##if ssr_denoiser_type == reblur
        float hitDist = REBLUR_FrontEnd_GetNormHitDist(reflectionDistance, w, hit_dist_params, linear_roughness);
        float4 packedReflection = REBLUR_FrontEnd_PackRadianceAndNormHitDist(result.rgb, hitDist, false);
      ##elif ssr_denoiser_type == relax
        float4 packedReflection = RELAX_FrontEnd_PackRadianceAndHitDist(result.rgb, reflectionDistance, false);
      ##elif ssr_denoiser_type == simple
        float4 packedReflection = result;
        reflectionDistance = min(reflectionDistance, MAX_REFLECTION_DIST);
        //packedReflection.a = result.a < 1 ? -reflectionDistance : reflectionDistance;
        packedReflection.a = floor(reflectionDistance*REFLECTION_DIST_ENCODE+0.5) + saturate(1-result.a);
        packedReflection = NEEDSSR ? packedReflection : half4(0,0,0,-1);
      ##else
        float4 packedReflection = result;
      ##endif
      if (all(outputCoord < uint2(ssr_target_size.xy)))
        texture2DAt(Result, outputCoord) = packedReflection;
    }
  }
  compile("cs_5_0", "tile_ssr_cs");
}

shader ssr_unpack_denoised
{
  ENABLE_ASSERT(cs)

  if (ssr_denoiser_type == manual || ssr_denoiser_type == simple) { dont_render; }
  if (compatibility_mode == compatibility_mode_on) { dont_render; }

  (cs) {
    input@smp2d = denoised_ssr;
    output@uav = ssr_target hlsl { RWTexture2D<float4> output@uav; };
    resolution@f2 = get_dimensions(ssr_target, 0);
  }

  hlsl(cs) {
    ##if ssr_denoiser_type != manual
      #include <Include/NRDEncoding.hlsli>
      #include <Include/NRD.hlsli>
    ##endif

    [numthreads(8, 8, 1)]
    void unpack_ssr_cs(uint2 DTid : SV_DispatchThreadID)
    {
      [branch]
      if (any(DTid >= resolution))
        return;

      float4 result;
      ##if ssr_denoiser_type == reblur
        result = REBLUR_BackEnd_UnpackRadianceAndNormHitDist(texture2DAt(input, DTid));
      ##elif ssr_denoiser_type == relax
        result = RELAX_BackEnd_UnpackRadiance(texture2DAt(input, DTid));
      ##else
        #error invalid
      ##endif

      result.a = 1.0;
      texture2DAt(output, DTid) = result;
    }
  }

  compile("cs_5_0", "unpack_ssr_cs");
}

