texture depth_around;
texture depth_around_transparent;
texture blurred_depth;
texture blurred_depth_transparent;

float4 world_to_depth_ao;
float4 depth_ao_heights;
float depth_ao_height_scale = 1;

int depth_ao_extra_enabled = 0;
float4 world_to_depth_ao_extra;
float4 depth_ao_heights_extra;

float depth_ao_texture_size;
float depth_ao_texture_size_inv;

macro INIT_BLURRED_DEPTH_ABOVE_CONSTS(code)
  (code) {
    world_to_depth_ao@f4 = world_to_depth_ao;
    depth_ao_heights@f4 = depth_ao_heights;
    depth_ao_texture_size@f1 = depth_ao_texture_size;
    depth_ao_texture_size_inv@f1 = depth_ao_texture_size_inv;
    depth_ao_extra_enabled@i1 = depth_ao_extra_enabled;
    world_to_depth_ao_extra@f4 = world_to_depth_ao_extra;
    depth_ao_heights_extra@f4 = depth_ao_heights_extra;
  }
endmacro

macro INIT_DEPTH_ABOVE(code, tex)
  (code) {tex@smpArray = tex;}
  INIT_BLURRED_DEPTH_ABOVE_CONSTS(code)
endmacro

macro INIT_BLURRED_DEPTH_ABOVE(code)
  INIT_DEPTH_ABOVE(code, blurred_depth)
endmacro

macro INIT_DEPTH_ABOVE_WITHOUT_SAMPLER(code, tex_name, tex_samplerstate, samplerstate)
  (code) { tex_name@texArray = tex_name; }
  hlsl(code) {
    #define tex_samplerstate samplerstate
  }
  INIT_BLURRED_DEPTH_ABOVE_CONSTS(code)
endmacro

macro INIT_BLURRED_DEPTH_ABOVE_WITHOUT_SAMPLER(code, samplerstate)
  INIT_DEPTH_ABOVE_WITHOUT_SAMPLER(code, blurred_depth, blurred_depth_samplerstate, samplerstate)
endmacro

macro USE_DEPTH_ABOVE_TC(code)
  hlsl(code) {
    #define USE_DEPTH_ABOVE_SAMPLING 0
    #include "depth_above.hlsl"
  }
endmacro

macro USE_DEPTH_ABOVE(code, tex)
  hlsl(code){
    #define USE_DEPTH_ABOVE_SAMPLING 1
    #include "depth_above.hlsl"

    // This trickery with defines is needed for NBS, to be able to explicitly call a function with its texture and sampler.
    #ifndef use_depth_above_impl
      #define depth_above_tex_size \
      get_depth_above_tex_size_impl(tex)

      #define get_depth_above_fast(worldPos, vignette_effect)\
      get_depth_above_fast_impl(worldPos, tex, tex##_samplerstate, vignette_effect)

      #define gather_depth_above(worldPos, vignette_effect, lerp_factor)\
      gather_depth_above_impl(worldPos, tex, tex##_samplerstate, vignette_effect, lerp_factor)\

      #define get_depth_above_precise(worldPos, vignette_effect)\
      get_depth_above_precise_impl(worldPos, tex, tex##_samplerstate, vignette_effect)

      #define get_depth_above(worldPos, prec, vignette_effect)\
      get_depth_above_impl(worldPos, prec, tex, tex##_samplerstate, vignette_effect)

      #define use_depth_above_impl
    #else
      #error ERROR: implementation for depth above has been already included, duplicate macro: USE_DEPTH_ABOVE(...)
    #endif
  }
endmacro

macro USE_BLURRED_DEPTH_ABOVE(shader_code)
  USE_DEPTH_ABOVE(shader_code, blurred_depth)
endmacro

macro INIT_DEPTH_AO_STAGE(code)
  INIT_WORLD_HEIGHTMAP_BASE(code)
  INIT_BLURRED_DEPTH_ABOVE(code)
endmacro

macro INIT_DEPTH_AO()
  INIT_DEPTH_AO_STAGE(ps)
endmacro

macro USE_DEPTH_AO_STAGE(code)
  USE_BLURRED_DEPTH_ABOVE(code)
  USE_HEIGHTMAP_COMMON_BASE(code)
  (code) {
        depth_ao_height_scale@f1 = (depth_ao_height_scale);
  }
  hlsl(code) {
    float get_depth_above_ao(float3 worldPos)
    {
      float vignetteEffect;
      float depthHt = get_depth_above_fast(worldPos, vignetteEffect);
      const float height_bias = 0.05;
##if tex_hmap_low != NULL
      const float height_scale = 1.0f;
##else
      const float height_scale = 0.5f;
##endif
      float occlusion = rcp((max(0.01, (depthHt - height_bias - worldPos.y)*(height_scale * depth_ao_height_scale)+1)));
      float ao = saturate(occlusion)*0.9 + 0.1;
##if tex_hmap_low != NULL
      float worldD = getWorldHeight(worldPos.xz) + 0.01;
      const float max_height_above_heightmap = 10.f;
      ao = lerp(1, ao, pow2(1 - saturate((1. / max_height_above_heightmap)*(worldPos.y - worldD))));
##endif
      return lerp(ao, 1, vignetteEffect);
    }
  }
endmacro

macro USE_DEPTH_AO()
  USE_DEPTH_AO_STAGE(ps)
endmacro
