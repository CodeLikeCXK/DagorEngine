include "shader_global.dshl"
include "gbuffer.dshl"
include "viewVecVS.dshl"
include "bvh.dshl"
include "ThreadGroupTilingX.dshl"
include "rt/rt_lighting.dshl"
include "use_prefiltered_gf.dshl"
include "wetness_inc.dshl"
include "bvh_common_includes.dshl"

float4x4 inv_proj_tm;

texture rtr_target;
texture rtr_denoised;

texture translucent_gbuffer;
texture translucent_gbuffer_depth;
texture rt_nr;

texture rtr_validation_texture;

int rtr_frame_index;

float4 rtr_hit_dist_params;

int4 rtr_resolutionI = (1,1,1,1);

texture denoiser_view_z;

float rtr_rough_ray_length;
float rtr_ray_limit_coeff = 0;
float rtr_ray_limit_power = 1;

int rtr_output_type = 0;
interval rtr_output_type: reblur < 1, relax < 2, rr;

int rtr_res_mul = 1;
interval rtr_res_mul: full_res < 2, half_res;
int rtr_checkerboard = 1;

float rtr_probe_treshold = 0.75;

hlsl {
  #pragma hlsl2021
}

shader rt_reflection
{
  if (compatibility_mode == compatibility_mode_on || !use_hw_raytracing || rtr_output_type == rr && rtr_res_mul == half_res) { dont_render; }
  supports global_const_block;

  ENABLE_ASSERT(cs)
  USE_EMISSION_DECODE_COLOR_MAP_STUB(cs)

  (cs) {
    inv_proj_tm@f44 = inv_proj_tm;
    world_view_pos@f3 = world_view_pos;
    resolution@u2 = rtr_resolutionI;
    inv_aligned_resolution@f2 = (rtr_res_mul*screen_pos_to_texcoord.xy);
    hit_dist_params@f4 = rtr_hit_dist_params;
    rough_ray_length@f1 = rtr_rough_ray_length;
    frame_index@i1 = rtr_frame_index;
    rtr_res_mul@i1 = rtr_res_mul;
    rtr_checkerboard@i1 = rtr_checkerboard;
    ray_limit_coeff@f1 = rtr_ray_limit_coeff;
    ray_limit_power@f1 = rtr_ray_limit_power;
    probe_treshold@f1 = rtr_probe_treshold;
    output@uav = rtr_target hlsl { RWTexture2D<float4> output@uav; };
    denoised@uav = rtr_denoised hlsl { RWTexture2D<float4> denoised@uav; };
    viewZTexture@uav = denoiser_view_z hlsl { RWTexture2D<float> viewZTexture@uav; };
  }

  if (rtr_output_type != rr)
  {
    (cs) {
      nr_texture@tex2d = rt_nr;
    }
  }
  else
  {
    INIT_LOAD_GBUFFER_BASE(cs)
    USE_LOAD_GBUFFER_BASE(cs, true)
  }

  hlsl(cs) {
    #include <Include/NRDEncoding.hlsli>
    #include <Include/NRD.hlsli>

    // We collide with SH1 otherwise
    namespace ml
    {
      #include <ml.hlsli>
    }
  }

  USE_AND_INIT_VIEW_VEC_CS()
  INIT_ZNZFAR_STAGE(cs)
  INIT_LOAD_DEPTH_GBUFFER_BASE(cs)
  INIT_LOAD_BVH_FLAGS_BASE(cs)

  USE_LOAD_DEPTH_GBUFFER_BASE(cs)
  USE_LOAD_BVH_FLAGS_BASE(cs)
  INIT_BVH(cs, 0, false)
  USE_BVH_FOR_REFLECTION(cs)
  USE_BVH_FX_RENDER(cs)

  USE_ADAPTIVE_RAY_OFFSET(cs)

  INIT_RT_LIGHTING(cs, false, true, true, rtr_shadow == on, rtr_use_csm == yes, true)
  USE_RT_LIGHTING(cs, 0, false)
  INIT_BVH_ATMOSPHERE(cs)
  USE_BVH_ATMOPHERE(cs)

  if (rtr_res_mul == full_res)
  {
    USE_CALC_GEOMETRY_NORMAL(cs)
  }
  else
  {
    USE_CALC_GEOMETRY_NORMAL_HALF(cs)
  }
  INIT_BVH_WATER_FADE_RTR(cs)
  USE_BVH_WATER_FADE_RTR(cs)

  GET_SCATTERED_REFLECTION_VECTOR(cs)

  hlsl(cs)
  {
    #define MAX_ACCUM_DENOISE_FRAMES 30

    #define PT_SPEC_LOBE_ENERGY 0.95

    [numthreads(8, 8, 1)]
    void rt_reflection_cs(uint2 dtid : SV_DispatchThreadID)
    {
      #ifndef BVH_TWO_SIDED
        #define BVH_TWO_SIDED 0
      #endif
      #ifndef BVH_UNSTABLE
        #define BVH_UNSTABLE 0
      #endif
      #ifndef BVH_GRASS
        #define BVH_GRASS 0
      #endif
      #ifndef BVH_FOLIAGE
        #define BVH_FOLIAGE 0
      #endif

      uint2 rayIndex = dtid;
      uint2 outputIndex = rayIndex;

      ##if rtr_output_type != rr
        BRANCH
        if (rtr_checkerboard)
        {
          rayIndex.x *= 2;

          bool evenFrame = ( frame_index & 1 ) == 0;
          bool evenLine  = ( rayIndex.y & 1 ) == 0;

          if ( evenFrame == evenLine && rayIndex.x + 1 != resolution.x) // on odd resolution.x, don't checkerboard on the edge.
            rayIndex.x += 1;
        }
      ##endif

      [branch]
      if (any(rayIndex >= resolution))
        return;

      float rawDepth;
      ##if rtr_res_mul == half_res
        rawDepth = texture2DAt(half_res_depth_tex, rayIndex).r;
      ##else
        rawDepth = loadGbufferDepth(rayIndex);
      ##endif

      [branch]
      if (rawDepth <= 0 || !bvhMainValid)
        return;

      float w = linearize_z(rawDepth, zn_zfar.zw);

      ##if rtr_res_mul == full_res
        uint bvhFlags  = loadBvhFlags(rayIndex * rtr_res_mul);
        bool isGrass   = bvhFlags & BVH_GRASS;
        bool isFoliage = bvhFlags & BVH_FOLIAGE;
      ##else
        uint bvhFlags00  = loadBvhFlags(rayIndex * rtr_res_mul + uint2(0, 0));
        uint bvhFlags10  = loadBvhFlags(rayIndex * rtr_res_mul + uint2(1, 0));
        uint bvhFlags01  = loadBvhFlags(rayIndex * rtr_res_mul + uint2(0, 1));
        uint bvhFlags11  = loadBvhFlags(rayIndex * rtr_res_mul + uint2(1, 1));
        bool isGrass00   = bvhFlags00 & BVH_GRASS;
        bool isGrass10   = bvhFlags10 & BVH_GRASS;
        bool isGrass01   = bvhFlags01 & BVH_GRASS;
        bool isGrass11   = bvhFlags11 & BVH_GRASS;
        bool isFoliage00 = bvhFlags00 & BVH_FOLIAGE;
        bool isFoliage10 = bvhFlags10 & BVH_FOLIAGE;
        bool isFoliage01 = bvhFlags01 & BVH_FOLIAGE;
        bool isFoliage11 = bvhFlags11 & BVH_FOLIAGE;
        bool isGrass     = isGrass00 || isGrass10 || isGrass01 || isGrass11;
        bool isFoliage   = isFoliage00 || isFoliage10 || isFoliage01 || isFoliage11;
      ##endif

      float3 relPos = calc_camera_relative_pos(rayIndex, w, inv_aligned_resolution);
      half3 toPoint = (half3)normalize(relPos);

      ##if rtr_output_type != rr
        float4 surfaceNormal_roughness = NRD_FrontEnd_UnpackNormalAndRoughness(texture2DAt(nr_texture, rayIndex));
        half3 normal = (half3)normalize(surfaceNormal_roughness.xyz);
        half roughness = surfaceNormal_roughness.w;
      ##else
        ProcessedGbuffer gbuffer = processGbuffer(unpackGbuffer(loadPackedGbuffer(rayIndex)));
        half3 normal = gbuffer.normal;
        half roughness = gbuffer.linearRoughness;
      ##endif

      ml::Rng::Hash::Initialize(rayIndex, frame_index);

      float3 toCamera = -toPoint;
      float3x3 localBasis = ml::Geometry::GetBasis(normal);
      float3 localVector = ml::Geometry::RotateVector(localBasis, toCamera);

      float2 rnd = ml::Rng::Hash::GetFloat2();
      float3 localRay = ml::ImportanceSampling::VNDF::GetRay(rnd, roughness, localVector, PT_SPEC_LOBE_ENERGY);
      localRay = reflect(-localVector, localRay);

      float3 sampleDir = ml::Geometry::RotateVectorInverse(localBasis, localRay);

      if (!isGrass)
      {
        ##if rtr_res_mul == full_res
          normal = calc_geometry_normal(rayIndex, inv_aligned_resolution, resolution);
        ##else
          normal = calc_geometry_normal_half(rayIndex, inv_aligned_resolution, resolution);
        ##endif
        half SoN = dot(normal, sampleDir);
        // The ray points into the surface, lets mirror it to the surface
        if (SoN < 0)
          sampleDir = reflect(sampleDir, normal);
      }

      relPos = applyAdaptiveRayOffset(relPos, normal);

      const float invThresholdRoughness = 1/0.01;
      float maxReflectionDistance = ray_limit_coeff > 0 ?
          min(hit_dist_params.x, ray_limit_coeff * pow(roughness * invThresholdRoughness, ray_limit_power)) :
          lerp(hit_dist_params.x, rough_ray_length, roughness);

      float underwaterFade = calc_underwater_fade(w, rayIndex, inv_aligned_resolution, world_view_pos);

      // The surface area of grass and foliage surfaces is small on the screen, so a reflection image will
      // not form on it. There is no need to shoot rays from them, calc_direct_surface_reflection should be
      // used directly instead.
      bool shootReflectionRay = !isGrass && !isFoliage && underwaterFade > 0;
      ##if hardware.scarlett || hardware.ps5
        shootReflectionRay &= roughness < probe_treshold;
      ##endif

      HitInfo hitInfo;
      bool isHit = false;
      [branch]
      if (shootReflectionRay)
      {
        isHit = trace_ray(bvhMain, relPos, sampleDir, 0, maxReflectionDistance, w, bvhGroupRender, hitInfo);

        [branch]
        if (!isHit && bvhTerrainValid)
          isHit = trace_ray(bvhTerrain, relPos, sampleDir, maxReflectionDistance, 100000, w, bvhGroupRender, hitInfo);
      }

      half3 reflectionColor;
      float reflectionDistance;
      if (isHit)
      {
        SurfaceParams hitSurface = calc_surface_params(hitInfo, -sampleDir, w);
        reflectionColor = light_hit_surface(hitSurface, -sampleDir, w + hitInfo.t, hit_dist_params.x);
        calc_atmosphere(reflectionColor, hitInfo.position, hitInfo.t);
        reflectionDistance = hitInfo.t;
      }
      else
      {
        reflectionDistance = NRD_FP16_MAX;
        reflectionColor = calc_direct_surface_reflection(bvh_origin + relPos, normal, roughness, toCamera, w, length(relPos), sampleDir, maxReflectionDistance, rayIndex, reflectionDistance);
      }

      float fxt = -1;
      trace_ray_fx_translucent(relPos, sampleDir, 0, isHit ? hitInfo.t : maxReflectionDistance, w, reflectionColor, fxt, 1.0 - roughness, 1);

      if (!isHit && fxt > 0)
        reflectionDistance = fxt;

      #if !RTR__SSR_FALLBACK
        BRANCH
        if (underwaterFade < 1)
        {
          half3 reflectionVector = reflect(toPoint, normal);
          float mip = ComputeReflectionCaptureMipFromRoughness(roughness);
          half3 reflectionColorUnderwater = (half3)texCUBElod(envi_probe_specular, float4(reflectionVector, mip)).rgb;
          reflectionColor = lerp(reflectionColorUnderwater, reflectionColor, underwaterFade);
        }
      #endif

      ##if rtr_output_type == rr
        texture2DAt(output, outputIndex) = float4(reflectionDistance, reflectionColor);
      ##else
        ##if rtr_output_type == reblur
          float hitDist = REBLUR_FrontEnd_GetNormHitDist(reflectionDistance, w, hit_dist_params, roughness);
          float4 packedReflection = REBLUR_FrontEnd_PackRadianceAndNormHitDist(reflectionColor, hitDist, false);
        ##elif rtr_output_type == relax
          float4 packedReflection = RELAX_FrontEnd_PackRadianceAndHitDist(reflectionColor, reflectionDistance, false);
        ##endif

        texture2DAt(output, outputIndex) = packedReflection;

        if (underwaterFade == 0)
        {
          uint2 zIndex = dtid;
          BRANCH
          if (rtr_checkerboard)
          {
            zIndex.x *= 2;
            texture2DAt(viewZTexture, zIndex) = INF;
            texture2DAt(denoised, zIndex) = packedReflection;
            zIndex.x = min(zIndex.x + 1, resolution.x - 1);
            texture2DAt(viewZTexture, zIndex) = INF;
            texture2DAt(denoised, zIndex) = packedReflection;
          }
          else
          {
            texture2DAt(viewZTexture, zIndex) = INF;
            texture2DAt(denoised, zIndex) = packedReflection;
          }
        }
      ##endif
    }
  }

  compile("cs_6_5", "rt_reflection_cs");
}

shader rt_glass_reflection
{
  if (compatibility_mode == compatibility_mode_on || !use_hw_raytracing) { dont_render; }
  supports global_const_block;

  ENABLE_ASSERT(cs)

  (cs) {
    inv_proj_tm@f44 = inv_proj_tm;
    resolution@u2 = rtr_resolutionI.xy;
    inv_resolution@f2 = (1.0 / get_dimensions(translucent_gbuffer, 0).xy);
    hit_dist_params@f4 = rtr_hit_dist_params;
    rt_glass_gbuffer@uav = translucent_gbuffer hlsl { RWTexture2D<float4> rt_glass_gbuffer@uav; };
    rt_glass_gbuffer_depth@tex2d = translucent_gbuffer_depth;
    world_view_pos@f3 = world_view_pos;
  }

  hlsl(cs) {
    #define toonshading 0

    #include <Include/NRDEncoding.hlsli>
    #include <Include/NRD.hlsli>
  }

  USE_AND_INIT_VIEW_VEC_CS()
  INIT_ZNZFAR_STAGE(cs)

  INIT_BVH(cs, 0, true)
  USE_BVH_FOR_REFLECTION(cs)
  USE_BVH_FX_RENDER(cs)

  USE_EMISSION_DECODE_COLOR_MAP_STUB(cs)
  PACK_UNPACK_GBUFFER_BASE(cs)

  USE_ADAPTIVE_RAY_OFFSET(cs)

  INIT_RT_LIGHTING(cs, true, true, true, rtr_shadow == on, rtr_use_csm == yes, false)
  USE_RT_LIGHTING(cs, 1, false)
  INIT_BVH_ATMOSPHERE(cs)
  USE_BVH_ATMOPHERE(cs)

  USE_CALC_CAMERA_RELATIVE_POS(cs)

  hlsl (cs)
  {
    RT_GROUP_SIZE
    void rt_glass_reflection_cs(uint2 dtid : SV_DispatchThreadID)
    {
      BRANCH
      if (any(dtid >= resolution))
        return;

      float rawDepth = texture2DAt(rt_glass_gbuffer_depth, dtid).x;

      BRANCH
      if (rawDepth <= 0 || !bvhMainValid)
      {
        texture2DAt(rt_glass_gbuffer, dtid) = 0;
        return;
      }

      float4 gbuffer = texture2DAt(rt_glass_gbuffer, dtid);

      float w = linearize_z(rawDepth, zn_zfar.zw);
      float3 relPos = calc_camera_relative_pos(dtid, w, inv_resolution);

      float3 worldNormal = gbuffer.xyz * 2 - 1;
      float3 reflectionVector = reflect(normalize(relPos), worldNormal);
      float3 sampleDir = reflectionVector;

      float maxReflectionDistance = hit_dist_params.x;

      HitInfo hitInfo;
      bool isHit = trace_ray(bvhMain, relPos, sampleDir, 0, maxReflectionDistance, w, bvhGroupRender, hitInfo);

      [branch]
      if (!isHit && bvhTerrainValid)
        isHit = trace_ray(bvhTerrain, relPos, sampleDir, maxReflectionDistance, 100000, w, bvhGroupRender, hitInfo);

      float3 reflectionColor;

      if (isHit)
      {
        SurfaceParams hitSurface = calc_surface_params(hitInfo, -sampleDir, w);
        reflectionColor = light_hit_surface(hitSurface, -sampleDir, w + hitInfo.t, hit_dist_params.x);
        calc_atmosphere(reflectionColor, hitInfo.position, hitInfo.t);
      }
      else
        reflectionColor = texCUBElod(envi_probe_specular, float4(sampleDir, 0)).rgb;

      float fxt = -1;
      trace_ray_fx_translucent(relPos, sampleDir, 0, isHit ? hitInfo.t : maxReflectionDistance, w, reflectionColor, fxt, 1.0);
      texture2DAt(rt_glass_gbuffer, dtid) = float4(reflectionColor, 1);
    }
  }

  compile("cs_6_5", "rt_glass_reflection_cs");
}

texture rtr_reflection_decode_src;
texture rtr_reflection_decode_dst;

shader rt_reflection_decode
{
  ENABLE_ASSERT(cs)

  if (compatibility_mode == compatibility_mode_on || !use_hw_raytracing || rtr_output_type == rr) { dont_render; }
  (cs) {
    input@tex2d = rtr_reflection_decode_src;
    output@uav = rtr_reflection_decode_dst hlsl { RWTexture2D<float4> output@uav; };
    resolution@f2 = get_dimensions(rtr_reflection_decode_dst, 0).xy;
  }

  hlsl(cs) {
    #include <Include/NRDEncoding.hlsli>
    #include <Include/NRD.hlsli>

    [numthreads(8, 8, 1)]
    void rt_reflection_cs(uint2 dtid : SV_DispatchThreadID)
    {
      BRANCH
      if (any(dtid >= resolution))
        return;

      ##if rtr_output_type == reblur
        #define Unpack(x) REBLUR_BackEnd_UnpackRadianceAndNormHitDist(x).rgb
      ##elif rtr_output_type == relax
        #define Unpack(x) RELAX_BackEnd_UnpackRadiance(x).rgb
      ##endif

      float3 c1 = Unpack(texture2DAt(input, dtid * 2 + uint2(0, 0)));
      float3 c2 = Unpack(texture2DAt(input, dtid * 2 + uint2(0, 1)));
      float3 c3 = Unpack(texture2DAt(input, dtid * 2 + uint2(1, 0)));
      float3 c4 = Unpack(texture2DAt(input, dtid * 2 + uint2(1, 1)));

      texture2DAt(output, dtid) = float4((c1 + c2 + c3 + c4) / 4, 1);
    }
  }

  compile("cs_6_5", "rt_reflection_cs");
}

shader rtr_validation_renderer
{
  cull_mode  = none;
  z_test = false;
  z_write = false;

  blend_src = sa; blend_dst = isa;

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float2 uv : TEXCOORD0;
    };
  }

  (ps) {
    rtr_validation_texture@smp2d = rtr_validation_texture;
  }

  USE_POSTFX_VERTEX_POSITIONS()

  hlsl(vs) {
    VsOutput rtr_validation_renderer_vs(uint vertexId : SV_VertexID)
    {
      VsOutput o;
      o.pos = float4(getPostfxVertexPositionById(vertexId), 0, 1);
      o.uv = screen_to_texcoords(o.pos.xy);
      return o;
    }
  }

  hlsl(ps) {
    float4 rtr_validation_renderer_ps(VsOutput i) : SV_Target
    {
      return tex2D(rtr_validation_texture, i.uv);
    }
  }

  compile("target_vs", "rtr_validation_renderer_vs");
  compile("target_ps", "rtr_validation_renderer_ps");
}
