int rtr_bindless_slot = -1;
int rtr_bindless_sampler_slot = -1;
int rtr_output_type = 0;
int rtr_res_mul = 1;
int4 rtr_resolutionI = (1,1,1,1);

int rtr_use_rr;

macro CHECKING_RTR(stage)
  if (use_hw_raytracing)
  {
    (stage) {
      rtr_bindless_slot@i1 = rtr_bindless_slot;
      rtr_bindless_sampler_slot@u1 = rtr_bindless_sampler_slot;
    }

    hlsl (stage) {
      bool isRTREnabled()
      {
        return rtr_bindless_slot >= 0;
      }
    }
  }
  else
  {
    hlsl (stage) {
      bool isRTREnabled()
      {
        return false;
      }
    }
  }
endmacro

macro USING_RTR(stage)
  CHECKING_RTR(stage)

  if (use_hw_raytracing)
  {
    (stage) {
      rtr_output_type@i1 = rtr_output_type;
      inv_output_resolution_rt@f2 = (1.0 / (rtr_resolutionI.x * rtr_res_mul), 1.0 / (rtr_resolutionI.y * rtr_res_mul));
      resolutionF_rt@f2 = rtr_resolutionI.xy;
      resolutionI_rt@u2 = rtr_resolutionI.xy;
      use_rr@u1 = rtr_use_rr;
    }

    hlsl (stage) {
      #include <Include/NRDEncoding.hlsli>
      #include <Include/NRD.hlsli>

      #define HAS_RTR 1

      #define RTR_REBLUR 0
      #define RTR_RELAX  1

      #include <rt_texture_outputs.inc.hlsli>

      float3 getRTR(uint2 tci)
      {
        BRANCH
        if (use_rr)
        {
          return texture2DAt(rt_texture_outputs[rtr_bindless_slot], tci).gba;
        }
        else
        {
          float2 uv = (tci.xy + 0.5) * inv_output_resolution_rt;
          float4 color = rt_texture_outputs[rtr_bindless_slot].SampleLevel(global_samplers_array[rtr_bindless_sampler_slot], uv, 0);

          return rtr_output_type == RTR_REBLUR
               ? REBLUR_BackEnd_UnpackRadianceAndNormHitDist(color).rgb
               : RELAX_BackEnd_UnpackRadiance(color).rgb;
        }
      }
      float3 getRTRFiltered(uint2 tci)
      {
        BRANCH
        if (use_rr)
        {
          return getRTR(tci);
        }
        else
        {
          float2 uv = (tci.xy + 0.5) * inv_output_resolution_rt;
          float4 red = rt_texture_outputs[rtr_bindless_slot].GatherRed(global_samplers_array[rtr_bindless_sampler_slot], uv);

          bool4 isColorFinite = isfinite(red);
          if (all(isColorFinite))
            return getRTR(tci);
          if (!any(isColorFinite))
            return 0;

          float4 green = rt_texture_outputs[rtr_bindless_slot].GatherGreen(global_samplers_array[rtr_bindless_sampler_slot], uv);
          float4 blue = rt_texture_outputs[rtr_bindless_slot].GatherBlue(global_samplers_array[rtr_bindless_sampler_slot], uv);

          float4 weight = float4(isColorFinite);
          float weightTotal = dot(weight, weight);

          float4 color = 0;
          UNROLL
          for(int i = 0; i < 4; i++)
          {
            if (isColorFinite[i])
            {
              float4 colorSample = float4(red[i], green[i], blue[i], 0);
              float4 colorDecoded = rtr_output_type == RTR_REBLUR
                ? REBLUR_BackEnd_UnpackRadianceAndNormHitDist(colorSample)
                : RELAX_BackEnd_UnpackRadiance(colorSample);
              color += colorDecoded;
            }
          }
          color /= weightTotal;

          return color.rgb;
        }
      }
    }
  }
  else
  {
    hlsl (stage) {
      float3 getRTR(uint2 tci)
      {
        return 0;
      }
      float3 getRTRFiltered(uint2 tci)
      {
        return 0;
      }
    }
  }
endmacro