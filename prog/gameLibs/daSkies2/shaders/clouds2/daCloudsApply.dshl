include "sky_shader_global.dshl"
include "viewVecVS.dshl"
include "clouds_tiled_dist.dshl"
include "clouds_close_layer_outside.dshl"
include "skies_special_vision.dshl"
include "distanceToClouds2.dshl"
include "vr_reprojection.dshl"
include "use_custom_fog_sky.dshl"
include "flexible_scale_rasterization.dshl"
include "cloud_volume_mask.dshl"

float min_ground_offset;
texture clouds_color;
texture clouds_color_close;

texture clouds_target_depth_gbuf;
float4 clouds_target_depth_gbuf_transform = (1, 1, 0, 0);
texture clouds_depth_gbuf;
int4 clouds2_resolution;
int clouds_has_close_sequence = 1;
int clouds_apply_simple_ztest = 1;

texture dynamic_bit_texture;

int clouds_use_blur_apply = 0;
interval clouds_use_blur_apply: no < 1, yes;

int clouds_bilateral_size = 1;
interval clouds_bilateral_size: small < 1, big;

float zFarSphere_radius = 1000000.;
float zFarSphere_error = 0.;
float4 zFarSphere_center_offset_dist = 0.;

texture clouds_close_depth_tex;

float cloud_apply_upscale_filter_depth_threshold = 0.001;


shader clouds2_apply, clouds2_apply_has_empty, clouds2_apply_no_empty
{
  blend_src = 1; blend_dst = isa;
  cull_mode=none;
  z_write=false;
  if (dynamic_bit_texture == NULL)
  {
    z_test=true;
  }
  else
  {
    z_test=false;
  }

  bool is_simple_array = clouds_depth_gbuf == NULL;

  USE_CLOUDS_DISTANCE(ps)
  USE_CLOUDS_DISTANCE_STUB(ps)
  USE_SPECIAL_VISION()
  INIT_HDR(ps)
  USE_HDR(ps)

  INIT_BOUNDING_VIEW_REPROJECTION_PS()
  USE_BOUNDING_VIEW_REPROJECTION_PS()

  CLOUD_VOLUME_MASK()

  USE_CUSTOM_FOG_SKY(ps)

  VIEW_VEC_OPTIMIZED(ps)
  ENABLE_ASSERT(ps)

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float3 viewVect : TEXCOORD0;
      float2 tc : TEXCOORD1;
    };
  }

  USE_POSTFX_VERTEX_POSITIONS()
  USE_AND_INIT_VIEW_VEC_VS()
  INIT_CLOUD_APPLY_DIST(vs)
  INIT_CLOUD_APPLY_DIST(ps)
  (vs) {
    encode_depth@f2 = (zn_zfar.x / (zn_zfar.y - zn_zfar.x), zn_zfar.y*zn_zfar.x / (zn_zfar.y - zn_zfar.x));
    clouds_apply_simple_ztest@f1 = (clouds_apply_simple_ztest, 0, 0, 0);
  }

  hlsl(vs) {
    VsOutput apply_clouds_vs(uint vertexId : SV_VertexID)
    {
      VsOutput output;
      float minCloudDist = clouds_min_apply_dist;
      float z = minCloudDist*encode_depth.x+encode_depth.y;
      ##if is_simple_array
      if (clouds_apply_simple_ztest > 0)
        { minCloudDist = 1; z = 0; }
      ##endif
      float2 pos = getPostfxVertexPositionById(vertexId);
      output.pos = float4(pos.xy*minCloudDist, z, minCloudDist);
      output.tc = screen_to_texcoords(pos);
      output.viewVect = get_view_vec_by_vertex_id(vertexId);
      return output;
    }
  }

  (ps) {
    fullres_depth_gbuf@smp2d = clouds_target_depth_gbuf;
    fullres_depth_gbuf_transform@f4 = clouds_target_depth_gbuf_transform;
    clouds_depth_gbuf@smp2d = clouds_depth_gbuf;
    clouds_close_depth_tex@smp2d = clouds_close_depth_tex;

    clouds_color@smp2d = clouds_color;
    clouds_color_close@smp2d = clouds_color_close;
    clouds2_far_res@f4 = (clouds2_resolution.xy, 1/clouds2_resolution.xy);
    clouds2_far_resI@u2 = (clouds2_resolution.xy);
    clouds2_close_res@f2 = (clouds2_resolution.zw,0,0);
    clouds_has_close_sequence@f1 = clouds_has_close_sequence;

    world_view_pos@f3 = world_view_pos;
    clouds_start_alt@f1 = clouds_start_altitude2 * 1000.0;
    zFarSphereThreshold@f1 = zFarSphere_radius - zFarSphere_error - zFarSphere_center_offset_dist.w - zn_zfar.y*0.001;
    cloud_apply_upscale_filter_depth_threshold@f1 = cloud_apply_upscale_filter_depth_threshold;

    dynamic_bit_texture@smp2d = dynamic_bit_texture;
  }
  hlsl(ps){
    #define clouds_close_depth_tex_samplerstate clouds_depth_gbuf_samplerstate
  }
  INIT_ZNZFAR()
  DISTANCE_TO_CLOUDS2(ps)
  CLOSE_LAYER_EARLY_EXIT(ps)
  USE_FSR(ps)

  bool use_gather4 = is_gather4_supported == supported || shader != clouds2_apply;

  if (shader == clouds2_apply_no_empty)
  {
    hlsl {
      #define HAS_EMPTY_TILES 0
    }
  } else if (shader == clouds2_apply_has_empty || shader == clouds2_apply)
  {
    hlsl {
      #define HAS_EMPTY_TILES 1
    }
  }

  hlsl(ps) {
    #include "daCloudsTonemap.hlsl"
    #include "cloud_settings.hlsli"
    float4 getZWeights(float4 lowResLinearZ, float hiResLinearZ)
    {
      return rcp( 0.00001 + abs( lowResLinearZ - hiResLinearZ ) );
    }

    uint getDynamic(float2 uv)
    {
      ##if dynamic_bit_texture == NULL
        return 0;
      ##else
        uv = uv * fullres_depth_gbuf_transform.xy + fullres_depth_gbuf_transform.zw;
        uint shadowPacked = uint(tex2Dlod(dynamic_bit_texture, float4(uv,0,0)).w * 255.0 + 0.1);
        uint impostorLandscapeMotionMask = shadowPacked >> 5;
        return (impostorLandscapeMotionMask & 1) == 1;
      ##endif
    }

    bool check_full_ray_below_clouds(float3 view_vec, float linear_depth)
    {
      float3 worldPos = view_vec*linear_depth + world_view_pos;
      return worldPos.y < clouds_start_alt && world_view_pos.y < clouds_start_alt;
    }

    float get_alpha_mask(float3 view_vec, float2 texcoord, float2 depth_texcoord, float linear_depth)
    {
      BRANCH
      if (linear_depth < clouds_min_apply_dist)
        return 1;

      bool varyingDepth = false;
      float maskScale = 1;
      ##if clouds_close_depth_tex != NULL // DNG-specific // TODO: use it everywhere, without dynamic bit
        BRANCH
        if (check_full_ray_below_clouds(view_vec, linear_depth))
        {
          varyingDepth = true;
        }
        else
        {
          float farDepth = linearize_z(tex2Dlod(clouds_depth_gbuf, float4(depth_texcoord, 0, 0)).x, zn_zfar.zw); // clouds_depth_gbuf is assumed to be far depth
          float closeDepth = linearize_z(tex2Dlod(clouds_close_depth_tex, float4(depth_texcoord, 0, 0)).x, zn_zfar.zw);
          float diff = farDepth - closeDepth;
          varyingDepth = diff > cloud_apply_upscale_filter_depth_threshold;
        }
        FLATTEN
        if (varyingDepth)
          maskScale = 1 - pow2(saturate(linear_depth * cloud_volume_remap)); // fade out mask far away
      ##endif

      BRANCH
      if (varyingDepth || getDynamic(depth_texcoord))
        return maskScale*get_screen_cloud_volume_mask(texcoord, linear_depth);

      return 0;
    }

    #include <tex2d_bicubic.hlsl>
    half4 getBicubicClose( float2 p )
    {
##if clouds_use_fullres == yes
      return tex2Dlod(clouds_color_close, float4(p,0,0));
##else
      return tex2D_bicubic_lod(clouds_color_close, clouds_color_close_samplerstate, p, clouds2_close_res, 0);
##endif
    }

    half4 bilateral_get(float3 viewVec, float2 texcoord, float2 depth_texcoord, float linearDepth, bool sky_is_visible)
    {
      if (check_full_ray_below_clouds(viewVec, linearDepth) && !sky_is_visible)
        return half4(0,0,0,0);

##if clouds_use_fullres == yes || clouds_use_blur_apply == yes || use_bounding_vr_reprojection == on
      return tex2Dlod(clouds_color, float4(texcoord,0,0));
##else
  ##if clouds_bilateral_size == small
    #define GET_LOWRES_COORD(ofs, tc)\
      float2 lowResCoords = tc*clouds2_far_res.xy - ofs;\
      int4 lowResCoordsI;\
      lowResCoordsI.xy = int2(lowResCoords);\
      lowResCoordsI.zw = min(lowResCoordsI.xy+int2(1,1), int2(clouds2_far_resI) - 1);

    ##if use_gather4
      float4 lowResRawDepth = clouds_depth_gbuf.GatherRed(clouds_depth_gbuf_samplerstate, depth_texcoord).wzxy;
    ##else
      GET_LOWRES_COORD(0.5, depth_texcoord)
      float4 lowResRawDepth;
      lowResRawDepth.x = clouds_depth_gbuf[lowResCoordsI.xy].x;
      lowResRawDepth.y = clouds_depth_gbuf[lowResCoordsI.zy].x;
      lowResRawDepth.z = clouds_depth_gbuf[lowResCoordsI.xw].x;
      lowResRawDepth.w = clouds_depth_gbuf[lowResCoordsI.zw].x;
    ##endif
    float4 linearLowResDepth = linearize_z4(lowResRawDepth, zn_zfar.zw);
    float4 maxDiff4 = abs(linearLowResDepth-linearDepth);
    float maxDiff = max(max(maxDiff4.x, maxDiff4.y), max(maxDiff4.z, maxDiff4.w));
    float minDiff = min(min(maxDiff4.x, maxDiff4.y), min(maxDiff4.z, maxDiff4.w));
    BRANCH
    if (maxDiff<linearDepth*0.05 || minDiff>linearDepth*0.5)//if difference is within 5%  - just use bilinear
      return tex2Dlod(clouds_color, float4(texcoord,0,0));

    ##if use_gather4
      GET_LOWRES_COORD(0.499, texcoord)
    ##endif
    float4 bilateralWeights = getZWeights(linearLowResDepth, linearDepth);
    bilateralWeights*=bilateralWeights;
    bilateralWeights /= dot(bilateralWeights, 1);

    return clouds_color[lowResCoordsI.xy]*bilateralWeights.x+
            clouds_color[lowResCoordsI.zy]*bilateralWeights.y+
            clouds_color[lowResCoordsI.xw]*bilateralWeights.z+
            clouds_color[lowResCoordsI.zw]*bilateralWeights.w;
  ##else // clouds_bilateral_size == big
    // Sample the 3x3 lowres depth around the texcoord, bilaterally filter them
    // Store values for the 9 pixels in 3 float4s (w comp is not used)
    float2 lowResCoordsOrigin = depth_texcoord * clouds2_far_res.xy;
    float2 lowResCoordsOriginI = (int2)lowResCoordsOrigin;

    int i;
    float4 packedSamples[3];
    float minDiff = 99999999;
    float maxDiff = 0;

    ##if use_gather4
      float2 gatherTc = floor(lowResCoordsOrigin) * clouds2_far_res.zw;
      // top left
      float4 samples = clouds_depth_gbuf.GatherRed(clouds_depth_gbuf_samplerstate, gatherTc + float2(-0.5, -0.5) * clouds2_far_res.zw).wzxy;
      packedSamples[0].xy = samples.xy;
      packedSamples[1].xy = samples.zw;

      // top right
      samples = clouds_depth_gbuf.GatherRed(clouds_depth_gbuf_samplerstate, gatherTc + float2(+0.5, -0.5) * clouds2_far_res.zw).wzxy;
      packedSamples[0].zw = samples.yy;
      packedSamples[1].zw = samples.ww;

      // bottom left
      samples = clouds_depth_gbuf.GatherRed(clouds_depth_gbuf_samplerstate, gatherTc + float2(-0.5, +0.5) * clouds2_far_res.zw).wzxy;
      packedSamples[2].xy = samples.zw;

      // bottom right
      samples = clouds_depth_gbuf.GatherRed(clouds_depth_gbuf_samplerstate, gatherTc + float2(+0.5, +0.5) * clouds2_far_res.zw).wzxy;
      packedSamples[2].zw = samples.ww;
    ##else
      UNROLL
      for(i = 0; i < 9; i++)
        packedSamples[i / 3][i % 3] = clouds_depth_gbuf[lowResCoordsOriginI + int2(i % 3 - 1, i / 3 - 1)].r;
    ##endif

    // calculate depth diff between lowres samples and shaded pixel's depth, store it in packedSamples
    float4 diff = abs(linearize_z4(packedSamples[0], zn_zfar.zw) - linearDepth);
    packedSamples[0] = diff;
    minDiff = min(minDiff, min(diff.x, min(diff.y, diff.z)));
    maxDiff = max(maxDiff, max(diff.x, max(diff.y, diff.z)));
    diff = abs(linearize_z4(packedSamples[1], zn_zfar.zw) - linearDepth);
    packedSamples[1] = diff;
    minDiff = min(minDiff, min(diff.x, min(diff.y, diff.z)));
    maxDiff = max(maxDiff, max(diff.x, max(diff.y, diff.z)));
    diff = abs(linearize_z4(packedSamples[2], zn_zfar.zw) - linearDepth);
    packedSamples[2] = diff;
    minDiff = min(minDiff, min(diff.x, min(diff.y, diff.z)));
    maxDiff = max(maxDiff, max(diff.x, max(diff.y, diff.z)));


    //if difference is within 5%  - just use bilinear
    const float depthDiffMinThreshold = 0.05;
    //if difference is more than 50% - just use bilinear, bilateral samples would result in very low weights
    const float depthDiffMaxThreshold = 0.5;
    BRANCH
    if (maxDiff<linearDepth*depthDiffMinThreshold || minDiff>linearDepth*depthDiffMaxThreshold)
      return tex2Dlod(clouds_color, float4(texcoord,0,0));

    float weightSum = 0;
    float4 result = 0;
    float4 bilateralWeights[3]; // holds values for the 9 samples

    lowResCoordsOrigin = texcoord * clouds2_far_res.xy;
    lowResCoordsOriginI = (int2)lowResCoordsOrigin;

    UNROLL
    for(i = 0; i < 3; i++)
    {
      float4 lowResCoordsIntX = (float4)(lowResCoordsOriginI.x + int4(-1, 0, 1, 0));
      float4 lowResCoordsIntY = (float4)(lowResCoordsOriginI.y + (int4)(i - 1));
      float4 texCoordDiffX = abs(lowResCoordsOrigin.xxxx - lowResCoordsIntX - 0.5);
      float4 texCoordDiffY = abs(lowResCoordsOrigin.yyyy - lowResCoordsIntY - 0.5);
      const float4 texCoordDiffLimit = 1.5;
      float4 bilinearWeight = max(0, texCoordDiffLimit - texCoordDiffX) * max(0, texCoordDiffLimit - texCoordDiffY);
      bilateralWeights[i] = rcp(0.00001 + packedSamples[i]);
      bilateralWeights[i] *= bilateralWeights[i] * bilinearWeight;
      weightSum += dot(bilateralWeights[i].xyz, 1);
    }

    float weightSumRcp = rcp(weightSum);
    UNROLL
    for(i = 0;  i < 3; i++)
      bilateralWeights[i] *= weightSumRcp;

    UNROLL
    for(i = 0; i < 9; i++)
    {
      int2 lowResCoordsInt = lowResCoordsOriginI + int2(i % 3 - 1, i / 3 - 1);
      float colorWeight = bilateralWeights[i / 3][i % 3];
      float4 cloudColorSample = clouds_color[lowResCoordsInt];
      result += cloudColorSample * colorWeight;
    }
    return result;
  ##endif // clouds_bilateral_size
##endif
    }

    half4 blend_result(half4 close_plane, half4 dist_plane, half alpha_mask = 0)
    {
      // The goal is to set the opacity of clouds to at most (1 - alpha_mask)
      // applyClouds blend mode always adds clouds.rgb, so we need to premultiply by alpha to lower the actual opacity
      // But clouds.rgb is already premultiplied by some transmittance value (not quite clouds.a, but close).
      // So multiplying by desired alpha again would overdarken the clouds. (eg current alpha is already the desired, we would like no color change)
      // We lerp between original and premultiplied based on the difference between clouds.a and desiredAlpha

      half4 clouds = half4(TAA_BRIGHTNESS_SCALE*(dist_plane.rgb*(1-close_plane.a) + close_plane.rgb), 1-(1-close_plane.a)*(1-dist_plane.a));
      float desiredCloudAlpha = 1 - alpha_mask;
      float cloudCorrection = pow(saturate((clouds.a - desiredCloudAlpha) / max(0.0001, clouds.a)), 2);
      float4 maskedClouds = lerp(clouds, clouds * desiredCloudAlpha, cloudCorrection);
      return maskedClouds;
    }

    half4 apply_clouds_ps_main(VsOutput input, float4 screenpos, out bool sky_is_visible)
    {
      float2 distortedTc = getDistortedTc(screenpos.xy, input.tc);
      float2 linearTc = input.tc;
      float raw_depth = tex2Dlod(fullres_depth_gbuf, float4(distortedTc * fullres_depth_gbuf_transform.xy + fullres_depth_gbuf_transform.zw, 0, 0)).x;

      // On DX10 we cannot use depth as a target and as a shader resource at the same time. Do the depth test in the shader
      ##if !hardware.fsh_5_0
        if (screenpos.z < raw_depth)
        {
          sky_is_visible = false;
          return 0.0f;
        }
      ##endif

      float2 texcoord = linearTc;

      float linearDepth = linearize_z(raw_depth, zn_zfar.zw);
      float linearDist = linearDepth*length(input.viewVect);

      sky_is_visible = raw_depth == 0;

      ##if use_bounding_vr_reprojection == on
        texcoord = vr_bounding_view_reproject_tc(texcoord, raw_depth);

        // On VR we use apply skies using sphere with zFar radius with Z-writes.
        sky_is_visible = sky_is_visible || linearDist > zFarSphereThreshold;
      ##endif

      ##if is_simple_array
        half4 distPlane = 0;
        if (HAS_EMPTY_TILES==0 || !tile_is_empty(uint2(texcoord.xy*clouds2_far_res.xy)))
          distPlane = tex2Dlod(clouds_color, float4(texcoord,0,0));
        return half4(TAA_BRIGHTNESS_SCALE*distPlane.rgb, distPlane.a);
      ##else
        //we can exit early doing bilteral sample apply, if (for bilinear):
        // +tile is empty (only apply to 'far plane' (of if there is no 'close plane')
        // *all 4 texels of high res depth are zfar. which is the same, as sampling close_depth_tex from required mip and check if it's z-far.
        // *closest possible distance to cloud is still bigger than hires sample depth (happens often on a ground)
        // *all 4 lowres texels of lowres clouds are 0 (no clouds there)

        //todo: check tile and exit immediately if close_layer_should_early_exit(), otherwise just apply close layer.

        float3 view = normalize(input.viewVect);

        #ifndef CHECK_DIST_TO_CLOUDS
          #define CHECK_DIST_TO_CLOUDS 0
        #endif

        #if CHECK_DIST_TO_CLOUDS
          //can happen only when we are above/below clouds layer
          // tht is so rare, that doesn't make sense to optimize
          float distToClouds = 0;
          float dist1; distance_to_clouds(-view, distToClouds, dist1);
          distToClouds *= 1000;
        #endif

        half4 distPlane = 0;
        half4 closePlane = 0;
        BRANCH
        if (!close_layer_should_early_exit())
        {
          #if SIMPLER_CLOSE_CLOUDS_APPLY
          closePlane = tex2Dlod(clouds_color_close, float4(texcoord,0,0));
          #else
          closePlane = getBicubicClose(texcoord);
          #endif
        }
        float closeSequenceEndDist = clouds_has_close_sequence ? closeSequenceStepSize*(closeSequenceSteps-4) : 0;
        #if CHECK_DIST_TO_CLOUDS
        //can happen only when we are above/below clouds layer
        // tht is so rare, that doesn't make sense to optimize
        if (distToClouds > linearDist && !sky_is_visible)
        {
        } else
        #endif
        {
          if (linearDist > closeSequenceEndDist && (HAS_EMPTY_TILES==0 || !tile_is_empty(uint2(texcoord.xy*clouds2_far_res.xy))))
            distPlane = bilateral_get(input.viewVect, texcoord, distortedTc, linearDepth, sky_is_visible);
        }

        float mask = get_alpha_mask(input.viewVect, texcoord, distortedTc, linearDepth);

        return blend_result(closePlane, distPlane, mask);
      ##endif
    }

    float4 apply_clouds_ps(VsOutput input HW_USE_SCREEN_POS) : SV_Target
    {
      float4 screenpos = GET_SCREEN_POS(input.pos);
      bool skyIsVisisble;
      half4 result = apply_clouds_ps_main(input, screenpos, skyIsVisisble);

      applySpecialVision(result);

      // fog is applied here, in clouds apply instead of sky rendering, as clouds are drawn later, but we don't want +1 pass for fog apply
      // we assume volfog is always in front of clouds (we already assume that for every surface in the depth buffer anyway)
      // otherwise we would apply fog multiple times in a certain range (from encode_depth.z)
      if (skyIsVisisble)
      {
        result.a = 1 - result.a; // transmittance is the inverse of blending alpha
        float2 jitteredVolfogTc = get_volfog_dithered_screen_tc(screenpos.xy, input.tc.xy);
        apply_sky_custom_fog(result, input.tc.xy, jitteredVolfogTc);
        result.a = 1 - result.a;
      }
      result.rgb = pack_hdr(result.rgb);
      return float4(result);
    }
  }

  compile("target_vs", "apply_clouds_vs");
  if (!hardware.fsh_5_0 && use_gather4)
  {
    compile("ps_4_1", "apply_clouds_ps");
  }
  else
  {
    compile("target_ps", "apply_clouds_ps");
  }
}
float4 clouds2_dispatch_groups;
shader clouds_create_indirect
{
  CLOSE_LAYER_EARLY_EXIT(cs)

  (cs) {
    tiles_threshold@f1 = (clouds_tiled_res.x*clouds_tiled_res.y*0.9, clouds2_dispatch_groups.x,clouds2_dispatch_groups.y,0);//90% of tiles should be non empty so we ignore non-empty tiles completely
    clouds2_dispatch_groups@f4 = clouds2_dispatch_groups;
  }

  hlsl(cs) {
    RWByteAddressBuffer indirect_buffer:register(u0);
    #include <clouds2/cloud_settings.hlsli>

    [numthreads(CLOUDS_APPLY_COUNT, 1, 1)]
    void cs_main(uint flatIdx : SV_GroupIndex)
    {
      uint2 groups = uint2(asuint(clouds2_dispatch_groups.x), asuint(clouds2_dispatch_groups.y));
      bool noEmpty = clouds_non_empty_tile_count_ge(tiles_threshold.x);
      uint targetId = noEmpty ? CLOUDS_NO_EMPTY : CLOUDS_HAS_EMPTY;
      FLATTEN
      if (flatIdx%CLOUDS_APPLY_COUNT_PS == CLOUDS_HAS_CLOSE_LAYER)
      {
        groups = uint2(asuint(clouds2_dispatch_groups.z), asuint(clouds2_dispatch_groups.w));
        targetId = close_layer_should_early_exit() ? 10000 : flatIdx%CLOUDS_APPLY_COUNT_PS;
      }
      uint3 write_first = flatIdx>=CLOUDS_APPLY_COUNT_PS ? uint3(groups, 1) : uint3(3,1,0);
      // feeding vertexCount = 0 to draw indirect crashes Adreno GPUs, avoid this
      uint3 write_second = flatIdx>=CLOUDS_APPLY_COUNT_PS ? uint3(0,0,0) : uint3(3,0,0);
      bool shouldWrite = (flatIdx%CLOUDS_APPLY_COUNT_PS) == targetId;
      uint3 writeValue = shouldWrite ? write_first : write_second;
      storeBuffer(indirect_buffer, (flatIdx * 4 + 0) * 4, writeValue.x);
      storeBuffer(indirect_buffer, (flatIdx * 4 + 1) * 4, writeValue.y);
      storeBuffer(indirect_buffer, (flatIdx * 4 + 2) * 4, writeValue.z);
      storeBuffer(indirect_buffer, (flatIdx * 4 + 3) * 4, 0);
    }
  }
  compile("cs_5_0", "cs_main");
}

macro CLOUD_BLUR(stage)
  (stage){
    clouds_color@smp2d = clouds_color;
    clouds2_far_res@f4 = (clouds2_resolution.xy, 1/clouds2_resolution.xy);
  }

  hlsl(stage) {
    float4 get_simple_blur(float2 texcoord)
    {
      float2 scaledOffsets = clouds2_far_res.zw;
      float2 offsets[8] = {
        -scaledOffsets, // top-left
        float2( 0.0, -scaledOffsets.y), // top-center
        float2( scaledOffsets.x, -scaledOffsets.y), // top-right
        float2(-scaledOffsets.x,  0.0), // mid-left
        float2( scaledOffsets.x,  0.0), // mid-right
        float2(-scaledOffsets.x,  scaledOffsets.y), // bottom-left
        float2( 0.0,  scaledOffsets.y), // bottom-center
        scaledOffsets  // bottom-right
      };

      float offsetsWeights[8]= {
        0.3678, // exp(-1)
        0.6065, // exp(-0.5)
        0.3678,
        0.6065,
        0.6065,
        0.3678,
        0.6065,
        0.3678
      };

      float4 outputColor = float4(0.0, 0.0, 0.0, 0.0);
      UNROLL
      for (int i = 0; i < 8; i++) {
        outputColor += tex2Dlod(clouds_color, float4(texcoord + offsets[i], 0, 0)) * offsetsWeights[i];
      }

      outputColor /= 3.8972; // sum of weights
      return outputColor;
    }
  }
endmacro

shader clouds2_apply_blur_cs
{
  ENABLE_ASSERT(cs)
  CLOUD_BLUR(cs)

  hlsl(cs) {
    #include "cloud_settings.hlsli"
    RWTexture2D<float4> target0: register(u0);

    [numthreads(CLOUD_TRACE_WARP_X, CLOUD_TRACE_WARP_Y, 1)]
    void cs_main(uint2 dtid : SV_DispatchThreadID)
    {
      if (any(dtid >= clouds2_far_res.xy))
        return;
      float2 texcoord = dtid*clouds2_far_res.zw + 0.5*clouds2_far_res.zw;
      texture2DAt(target0, dtid) = get_simple_blur(texcoord);
    }
  }
  compile("cs_5_0", "cs_main");
}

shader clouds2_apply_blur_ps
{
  cull_mode=none;
  z_write=false;
  z_test=false;

  USE_POSTFX_VERTEX_POSITIONS()
  CLOUD_BLUR(ps)

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float2 tc : TEXCOORD0;
    };
  }

  hlsl(vs) {
    VsOutput blur_vs(uint vertexId : SV_VertexID)
    {
      VsOutput output;
      float2 pos = getPostfxVertexPositionById(vertexId);
      output.pos = float4(pos.xy, 0, 1);
      output.tc = screen_to_texcoords(pos);

      return output;
    }
  }

  hlsl(ps) {
    float4 blur_ps(VsOutput IN) : SV_Target
    {
      return get_simple_blur(IN.tc);
    }
  }

  compile("target_vs", "blur_vs");
  compile("target_ps", "blur_ps");
}
