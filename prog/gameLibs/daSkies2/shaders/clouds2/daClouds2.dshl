include "sky_shader_global.dshl"
include "viewVecVS.dshl"
include "distanceToClouds2.dshl"
include "cloudsShadowVolume.dshl"
include "clouds_density_height_lut.dshl"
include "clouds_tiled_dist.dshl"
include "clouds_close_layer_outside.dshl"
include "cloudsDensity.dshl"
include "cloudsLighting.dshl"
include "clouds_sun_light.dshl"
include "panorama.dshl"
include "skies_special_vision.dshl"
include "renderSkiesInc.dshl"
include "tonemapHelpers/use_full_tonemap_lut_inc.dshl"
include "camera_in_camera.dshl"

texture clouds_field_volume_low;
float4 clouds_field_res;//.xy - xz&y of res, .zw - xz&y of target res
int clouds_field_downsample_ratio = 8;

float clouds_offset = 0;
int clouds_has_close_sequence = 1;
texture clouds_depth_gbuf;
int clouds_infinite_skies;
interval clouds_infinite_skies:no < 1, yes;
int clouds_panorama_frame;

float4 nuke_light_color;
float4 nuke_light_pos;


int clouds_use_legacy_tracing = 0; // for testing, will be removed
interval clouds_use_legacy_tracing: no < 1, yes;


//the higher the better quality is. but after 4 it doesn't really changes.
//If you fly in clouds, use pow-of-2 (i.e 1,2,4), otherwise you will get some blinking due to fp precision and rounding errors
float clouds_steps_per_sequence = 2;//2 is default, 4 is excellent
float4 clouds_trace_steps = (256, 64, 0, 0);    // x - at horizon, y - at zenith

float clouds_blend_fadeout_start = 0.95;

float4 lightning_point_light_pos = (0, 0, 0, 0);
float4 lightning_point_light_color = (0.8, 0.8, 0.8, 0);
int lightning_render_additional_point_light = 0;
int lightning_additional_point_light_natural_fade = 0;
float lightning_additional_point_light_radius = 100000;
float lightning_additional_point_light_strength = 1.0;
float lightning_additional_point_light_extinction_threshold = 0.1;

int lightning_in_clouds = 0;
interval lightning_in_clouds: off<1, on;

int clouds_panorama_depth_out = 0;
interval clouds_panorama_depth_out: off < 1, on;

int clouds_panorama_split = 0;
interval clouds_panorama_split: off < 1, trace < 2, blend;

int clouds_ignore_close_objects = 0;
interval clouds_ignore_close_objects: off < 1, on;

hlsl {
  #define MAX_CLOUDS_SHADOW_DIST (100*1000)
}

int clouds2_current_frame = 0;

macro RAYCAST_CLOUDS(code)
  hlsl {
    ##if shader == clouds_panorama || shader == clouds_alpha_panorama
      #define DUAL_PANORAMA 1
      #include <panorama_samples.hlsli>
    ##endif
    ##if shader == clouds2_direct
      #define HAS_DEPTH_TARGET 0
      #define TEMPORAL_REPROJECTION 0
      #define INFINITE_SKIES 1
    ##endif
    ##if shader == clouds2_temporal_ps || shader == clouds2_temporal_cs
      #define HAS_DEPTH_TARGET 1
      #define TEMPORAL_REPROJECTION 1
    ##endif
    ##if shader == clouds2_close_temporal_ps || shader == clouds2_close_temporal_cs
      #define HAS_DEPTH_TARGET 0
      #define TEMPORAL_REPROJECTION 0
      #define JUST_CLOSE_SEQUENCE 1
    ##endif
    ##if clouds_use_fullres == yes
      #define CLOUDS_FULLRES 1
    ##endif
  }

  hlsl {
    #define WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE 2//For planes better use WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE.
    #define WEIGHTED_ATMOSPHERE_SCATTERING_ONCE 1//produces some artefacts when clouds visible through clouds. For planes better use WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE, for panorama/view from ground is good enough

    // CLOUDS_JUST_ONE_SEQUENCE: if we are not flying through clouds, stability isn't a concern. But that's way faster. For panorama and 'shooter' mode (tank/ship) (CAN_BE_IN_CLOUDS  = 1) after defined

   //panorama
   #if DUAL_PANORAMA
     #define CLOUDS_FIXED_LOD 1
     #define CAN_BE_IN_CLOUDS 0
     #define CLOUDS_LIGHT_SAMPLES 6
     #define INFINITE_SKIES 1//don't sample depth
     #define DUAL_PANORAMA 1
     #define WEIGHTED_ATMOSPHERE_SCATTERING WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
     #define CLOUDS_JUST_ONE_SEQUENCE 1
   #else
     //flying through clouds - temporal + close
     #define CLOUDS_LIGHT_SAMPLES 6
     #define CAN_BE_IN_CLOUDS 1

     #ifndef INFINITE_SKIES
      ##if clouds_infinite_skies == yes
        #define INFINITE_SKIES 1
      ##else
        #define INFINITE_SKIES 0
      ##endif
     #endif

     #if !JUST_CLOSE_SEQUENCE
       #define WEIGHTED_ATMOSPHERE_SCATTERING WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
       #define CLOUDS_FIXED_LOD 0
       #define CLOUDS_CHECK_ALT_FRACTION_IS_OUT (!_HARDWARE_XBOX && !_HARDWARE_PS4 && !_HARDWARE_PS5)//on nvidia it seems to help a bit, for unknown reason
       #define RENDER_TO_TAA_SPACE TEMPORAL_REPROJECTION
       //for shooter dynamic clouds in camera:
       //#define STEPS_PER_SEQUENCE 16
       //#define WEIGHTED_ATMOSPHERE_SCATTERING WEIGHTED_ATMOSPHERE_SCATTERING_ONCE
       //no close clouds
       //and for inifinite clouds
       //no discontinuities in taa
       //#define INFINITE_SKIES 1//don't sample depth
       //simple apply (no bilateral)
     #else
       #define WEIGHTED_ATMOSPHERE_SCATTERING WEIGHTED_ATMOSPHERE_SCATTERING_ONCE
       #define CLOUDS_FIXED_LOD 1
       #define SIMPLIFIED_ALT_FRACTION 1//difference is small. we can assume it is not changing
     #endif
    #endif
  }
  if (shader == clouds2_close_temporal_ps || shader == clouds2_close_temporal_cs)
  {
    CLOSE_LAYER_EARLY_EXIT(code)
  } else if (shader == clouds2_temporal_ps || shader == clouds2_temporal_cs)
  {
    USE_CLOUDS_DISTANCE(code)
    (code) {clouds_has_close_sequence@f1 = clouds_has_close_sequence;}
  } else if (shader == clouds2_direct)
  {
    hlsl(code){static const bool clouds_has_close_sequence = false;}
  }


  DISTANCE_TO_CLOUDS2(code)
  local float4 offseted_view_pos = (skies_world_view_pos.x+clouds_origin_offset.x, max(skies_world_view_pos.y, 10.-min_ground_offset), skies_world_view_pos.z+clouds_origin_offset.y,0);
  if ((shader == clouds_panorama || shader == clouds_alpha_panorama) && clouds_field_volume==NULL)
  {
    SAMPLE_CLOUDS_DENSITY_MATH_ONLY(code, offseted_view_pos)
  } else
  {
    SAMPLE_CLOUDS_DENSITY_TEXTURE(code, offseted_view_pos)
  }

  INIT_ZNZFAR_STAGE(code)
  (code) {
    skies_world_view_pos@f3 = (skies_world_view_pos.x, max(skies_world_view_pos.y, 10.-min_ground_offset), skies_world_view_pos.z, 0);
    clouds_start_trace_base@f3 = (offseted_view_pos);
    clouds_min_apply_dist@f1 = clouds_min_apply_dist;
  }
  if (shader != clouds_panorama && shader != clouds_alpha_panorama)
  {
    (code) {
      clouds_offset@f1 = (clouds_offset);
      steps_per_sequence@f1 = (16*max(1, clouds_steps_per_sequence),0,0,0);//can be independent parameter. but better be pow2
    }
  } else
  {
    hlsl(code) { static const float clouds_offset = 0; }
  }
  INIT_CLOUDS_SHADOWS_VOLUME(code)
  USE_CLOUDS_SHADOWS_VOLUME(code)
  CLOUDS_LIGHTING_COMMON(code)
  USE_CLOUDS_DISTANCE_STUB(code)
  CLOSE_LAYER_EARLY_EXIT_STUB(code)

  INIT_BRUNETON_FOG(code)
  BASE_USE_BRUNETON_FOG(code)
  CLOUDS_SUN_SKY_LIGHT_COLOR(code)
  (code) {
    clouds_altitudes@f2 = (clouds_start_altitude2+skies_planet_radius, clouds_start_altitude2+skies_planet_radius+clouds_thickness2,0,0);
    skies_primary_sun_light_dir@f3 = skies_primary_sun_light_dir;
    clouds_blend_fadeout_start@f1 = clouds_blend_fadeout_start;
  }
  hlsl(code) {
    struct SunLightingPixelHelper {half_octaves phase;};
    SunLightingPixelHelper getSunHelper(float3 view)
    {
      float cos0 = dot(skies_primary_sun_light_dir.xyz, view.xzy);
      half_octaves phase = henyey_greenstein_optimized_multiple_scattering(cos0);
      SunLightingPixelHelper ret;
      ret.phase = phase;
      return ret;
    }

    half2 sunAmbientLuminance(float3 worldPos, float heightFraction, float base_mip, float erosion_level, SunLightingPixelHelper sunHelper)
    {
      //todo: for high quality add additional toroidally updated volume shadows around camera. We can singificanly increase quality
      float ambientV = 1;
      #if CLOUDS_PREBAKED_FIELD
        float3 volTc = getCloudsShadows3dTC(worldPos, heightFraction);
        float2 shadow_ambient = getCloudsShadows3d(volTc);
        ambientV = shadow_ambient.y;
        //that is not entirely correct on earlier octaves due to filtering. because (0.5(a+b))^c != 0.5(a^c+b^c). But this is way faster and less memory...
        //we can probably consider storing also FIRST octave separately (i.e 11,11,10 32 bit format), and incorrectly filter only less important octaves (i.e. 2th or 2th/3rd).
        #if CLOUDS_VOLUME_SHADOWS_AND_STEPS// || 1
          float directShadowStep = 64;
          float3 sampleShadowPos = worldPos + skies_primary_sun_light_dir.xzy*(directShadowStep*(1+1.5+2.25));
          volTc = getCloudsShadows3dTC(sampleShadowPos, alt_fraction_in_clouds(sampleShadowPos));
          float2 shadow_ambient = getCloudsShadows3d(volTc);
          //ambientV = shadow_ambient.y;//fixme: ambient should be from original, not offseted volTC. Although would be faster.
          //todo: use 2-3 explicit steps, not common function, avoid branching
          baseLightExtinction(shadow_ambient.x, worldPos, heightFraction, directShadowStep, base_mip, 2./CLOUDS_LIGHT_SAMPLES, erosion_level, 0.1, skies_primary_sun_light_dir.xzy, 3, 0.5);
        #endif
        float last_octave_extinction = shadow_ambient.x;
      #else
        float last_octave_extinction = 1.0;
        baseLightExtinction(last_octave_extinction, worldPos, heightFraction,
          128.0,//shadowStepSize
          base_mip, 2./CLOUDS_LIGHT_SAMPLES, erosion_level,
          0.1,//threshold
          skies_primary_sun_light_dir.xzy,
          CLOUDS_LIGHT_SAMPLES,
          0.125*(12./CLOUDS_LIGHT_SAMPLES));
      #endif
      //we integrate ambient separately from sun, to save multiplication per step *cloud_sun_light.
      //this saves few instruction and reduces register pressure
      return float2(dot(sunHelper.phase, getMSExtinction(last_octave_extinction)), ambientV);
    }
  }
  if (shader != clouds_panorama && shader != clouds_alpha_panorama)
  {
    (code) {
      clouds_depth_gbuf@smp2d = clouds_depth_gbuf;
      current_frame_info@f1 = (clouds2_current_frame, 0,0,0);
    }
  } else
  {
    (code) {
      clouds_field_volume_low@smp3d = clouds_field_volume_low;
      lowres_texel_size@f1 = (min(clouds_weather_size/(clouds_field_res.x/clouds_field_downsample_ratio), clouds_thickness2*1000/(clouds_field_res.y/clouds_field_downsample_ratio)));
      current_frame_info@f2 = (clouds_panorama_frame, 1.0 / (clouds_panorama_frame + 1.0),0,0);
    }
    hlsl(code) {
      #if MOBILE_DEVICE
        //less divergence & register space usage is more profitable on mobile devices (less cores/smaller warps)
        //and there is also problems with complex flow control causing some devices to render garbadge
        //
        //disabling this optimization keeps performance same as with this optimization
        //while fixing problems with flow control
        #define CLOUDS_OPTIMIZE_OUTER_LOOP 0
      #else
        #define CLOUDS_OPTIMIZE_OUTER_LOOP CLOUDS_PREBAKED_FIELD
      #endif
    }
  }
  local float infMul = (((1 - 0.5/skies_froxels_resolution.z) - skies_frustum_scattering_last_tz) / max(1, 245000-skies_froxels_dist));
  (code) {
    //returns skies_frustum_scattering_last_tz at skies_froxels_resolution.w, and 1 - 0.5/skies_froxels_resolution.z at 280km/
    infinite_skies_madd@f3 = (infMul, skies_frustum_scattering_last_tz - skies_froxels_dist*infMul, 1 - 0.5/skies_froxels_resolution.z,0);
    nuke_light_color@f4 = nuke_light_color;
    nuke_light_pos@f3 = (nuke_light_pos.x + clouds_origin_offset.x, nuke_light_pos.y, nuke_light_pos.z+clouds_origin_offset.y, 0);
    shadow_steps_for_nuke@f2 = (1 + clouds_steps_per_sequence, 1.0 / (1 + clouds_steps_per_sequence));
    trace_steps@f2 = (clouds_trace_steps.x, clouds_trace_steps.y);
  }

  if (lightning_in_clouds == on && shader != clouds_panorama && shader != clouds_alpha_panorama) {
    (code) {
      lightning_point_light_pos@f3 = (lightning_point_light_pos.x + clouds_origin_offset.x, lightning_point_light_pos.y, lightning_point_light_pos.z + clouds_origin_offset.y, 0);
      lightning_point_light_color@f3 = lightning_point_light_color;
      lightning_render_additional_point_light@i1 = (lightning_render_additional_point_light);
      lightning_additional_point_light_natural_fade@i1 = (lightning_additional_point_light_natural_fade);
      lightning_additional_point_params@f3 = (lightning_additional_point_light_radius, lightning_additional_point_light_strength, lightning_additional_point_light_extinction_threshold, 0)
    }
  }
  SAMPLE_CLOUDS_NUKE_INVERSION(code)

  hlsl(code) {
    struct AdditionalLightingConstParams
    {
      float3 pos;
      float cloud_density;
      float3 clouds_hole_offset;
      float height_fraction;
      float mip;
      float erosion_level;
      float beers_term;
      float3 integrated_scattering_transmittance;
    };

    void calculate_additional_lighting(AdditionalLightingConstParams cp, inout float3 additional_lighting, float randomOfs)
    {
##if nuke_in_atmosphere == on && shader != clouds_panorama && shader != clouds_alpha_panorama
      if (nuke_light_color.w > 0)
      {
        float lightDist = length(cp.pos - nuke_light_pos.xyz);
        float radFade = pow2(saturate((nuke_light_color.w-lightDist)/nuke_light_color.w));

        if (radFade > 0)
        {
          float3 lightDir = (nuke_light_pos.xyz - cp.pos)*rcp(lightDist);
          float shadowStep = shadow_steps_for_nuke.y*lightDist;
          float shadow = 1;
          baseLightExtinction(shadow, cp.pos + cp.clouds_hole_offset - randomOfs*shadowStep*lightDir, cp.height_fraction, shadowStep, cp.mip,
                              2./CLOUDS_LIGHT_SAMPLES, cp.erosion_level, 0.1, lightDir.xyz, shadow_steps_for_nuke.x, 1);
          additional_lighting += pow2((1 - cp.beers_term)) * cp.integrated_scattering_transmittance.z * shadow *
                              radFade * nuke_light_color.rgb * nuke_light_color.w / pow2(lightDist);
        }
      }
      // TODO: enable lightning flash with nuke lights
##elif lightning_in_clouds == on && shader != clouds_panorama && shader != clouds_alpha_panorama
      float lightRadius = lightning_additional_point_params.x;
      if (lightning_render_additional_point_light == 1 && lightRadius > 0)
      {
        float lightDist = length(cp.pos - lightning_point_light_pos);
        BRANCH
        if (lightDist > lightRadius)
          return;
        float lightStrength = lightning_additional_point_params.y;
        float distanceFade = - (lightStrength / lightRadius) * lightDist + lightStrength;
        float naturalFade = 1.0;
        BRANCH
        if (lightning_additional_point_light_natural_fade == 1)
          naturalFade = lightRadius / pow2(lightDist);
        BRANCH
        if (distanceFade > 0)
        {
          float3 lightDir = (lightning_point_light_pos - cp.pos)*rcp(lightDist);
          float shadow = 1;
          baseLightExtinction(shadow, cp.pos + cp.clouds_hole_offset, cp.height_fraction, shadow_steps_for_nuke.y*lightDist, cp.mip,
                              2./CLOUDS_LIGHT_SAMPLES, cp.erosion_level, lightning_additional_point_params.z, lightDir.xyz, shadow_steps_for_nuke.x, 1);
          additional_lighting += pow2((1 - cp.beers_term)) * cp.integrated_scattering_transmittance.z * shadow *
                              distanceFade * lightning_point_light_color.rgb * naturalFade;
        }
      }
##endif
    }
  }

  hlsl(code) {
    static const float EPS = 1e-9;

    float get_scattering_tc_long_z(float dist)
    {
      float tcZ = sqrt(dist*skies_panoramic_scattering__inv_distance.y);
      FLATTEN if (tcZ > skies_panoramic_scattering__inv_distance.w)
        tcZ = saturate(dist*infinite_skies_madd.x + infinite_skies_madd.y);
      return tcZ;
    }

    #if CLOUDS_OPTIMIZE_OUTER_LOOP
    bool check_cloud_hit(float3 sample_pos, float3 clouds_hole_offset)
    {
      return tex3Dlod(clouds_field_volume_low, float4(getFieldTC(sample_pos, clouds_hole_offset), 0)).x > 0;
    }

    void optimize_sequence_loop_num_steps(inout int num_steps, inout float dist,
      float stepSize, float3 view, float3 clouds_start_trace, float3 clouds_hole_offset)
    {
      const int skipIterations = lowres_texel_size / stepSize;

      BRANCH
      if (skipIterations <= 2)
        return;

      float skipStepSize = stepSize * skipIterations;
      int forwardIndex = 0;

      // Forward loop to skip unnecessary iterations
      LOOP
      for (; forwardIndex < num_steps; forwardIndex += skipIterations)
      {
        float3 currentSamplePosition = view * dist + clouds_start_trace;
        if (check_cloud_hit(currentSamplePosition, clouds_hole_offset))
        {
          FLATTEN if (forwardIndex != 0)
          {
            dist -= skipStepSize;
            forwardIndex -= skipIterations;
          }
          break;
        }

        dist += skipStepSize;
      }

      num_steps -= forwardIndex;

      float3 refinedEndPosition = view * (dist + (num_steps - 1.0) * stepSize) + clouds_start_trace;
      int backwardIndex = 0;

      // Backward loop to refine the end position
      LOOP
      for (; backwardIndex < num_steps; backwardIndex += skipIterations, refinedEndPosition -= view * skipStepSize)
      {
        if (check_cloud_hit(refinedEndPosition, clouds_hole_offset))
        {
          FLATTEN if (backwardIndex != 0)
            backwardIndex -= skipIterations;
          break;
        }
      }

      num_steps -= backwardIndex;
    }
    #endif

    #if !defined(CLOUDS_USE_APPROXIMATE_ALT_FRACTION)
      #if !CLOUDS_JUST_ONE_SEQUENCE && !JUST_CLOSE_SEQUENCE
        #define CLOUDS_USE_APPROXIMATE_ALT_FRACTION 1
      #else
        #define CLOUDS_USE_APPROXIMATE_ALT_FRACTION 0
      #endif
    #endif

    #if !defined(CLOUDS_PRESELECTED_SEQUENCE)
      #define CLOUDS_PRESELECTED_SEQUENCE 0 // legacy
    #endif

    #if !defined(CLOUDS_PRESELECTED_SEQUENCE_NO)
      #define CLOUDS_PRESELECTED_SEQUENCE_NO 666 // doesn't matter, it is checked by CLOUDS_USE_PRESELECTED_SEQUENCE first
      #define CLOUDS_USE_PRESELECTED_SEQUENCE 0
    #else
      #define CLOUDS_USE_PRESELECTED_SEQUENCE 1
    #endif

    #define CLOUDS_IS_PRESELECTED_FURTHEST_SEQUENCE (CLOUDS_PRESELECTED_SEQUENCE_NO == 2)

    struct CloudDensitySampleParams
    {
      float erosion_level;
      float mip;
      float3 clouds_hole_offset;
    #if CLOUDS_USE_APPROXIMATE_ALT_FRACTION
      float heightFractionStep;
      float heightFractionStart;
    #endif
    };

    CloudDensitySampleParams prepare_clouds_density_sample_params(
      float erosion_level, float mip, float3 clouds_hole_offset,
      int num_steps, float3 view, float dist, float stepSize, float3 clouds_start_trace)
    {
      CloudDensitySampleParams params;
      params.erosion_level = erosion_level;
      params.mip = mip;
      params.clouds_hole_offset = clouds_hole_offset;
      #if CLOUDS_USE_APPROXIMATE_ALT_FRACTION
        float3 st = view*dist + clouds_start_trace;
        params.heightFractionStart = precise_alt_fraction_in_clouds(st);
        float totalDist = num_steps*stepSize;
        float heightFractionEnd = precise_alt_fraction_in_clouds(st + view*totalDist);
        params.heightFractionStep = (heightFractionEnd - params.heightFractionStart)/totalDist;
        params.heightFractionStart -= params.heightFractionStep*dist;
      #endif
      return params;
    }

    float sample_clouds_density(CloudDensitySampleParams params, float3 sample_pos, float dist, out float height_fraction)
    {
    #if CLOUDS_USE_APPROXIMATE_ALT_FRACTION
      height_fraction = params.heightFractionStart + dist*params.heightFractionStep;//instead of accurate alt fraction we use partial linear
    #else
      height_fraction = alt_fraction_in_clouds_with_hole(sample_pos, params.clouds_hole_offset);
    #endif
      float cloudDensity = sampleCloudDensity(sample_pos, params.erosion_level, params.mip, height_fraction);
    ##if nuke_in_atmosphere == on
      cloudDensity = sampleNukeCloudsInversion(sample_pos - params.clouds_hole_offset, cloudDensity, height_fraction);
    ##endif
      return cloudDensity;
    }

    void reduce_steps(inout int num_steps, inout float dist, float stepSize, float distStart, float end)
    {
      num_steps = min(num_steps, int(floor((end - dist) / stepSize)));
      const float offsetStepCnt = clamp(ceil((distStart - dist) / stepSize), 0, num_steps);
      num_steps -= int(offsetStepCnt);
      dist += offsetStepCnt*stepSize;
    }

    void performSequence(float distStart, int num_steps, float3 view, float stepSize, float end,
                           SunLightingPixelHelper sunPixelHelper,
                           float randomOfs,
                           float threshold,
                           inout float weightedSequenceDist,
                           inout float totalSequenceWeight,
                           inout float3 integratedScatteringTransmittance, inout float dist,
                           inout float3 additionalLighting,
                           float2 distMulAdd, float erosion_level, bool first_slice_disappear)
    {
      float mip = distMulAdd.x != 0 ? clamp(dist/30000-1, 0, 2) : 0;//switch off mip selection on first sequence

      // Early exit might introduce a bit of banding for really close clouds (but saves performance)
      // for mobile devices it is better to keep it on
      #ifndef FORCE_CLOSE_SEQUENCE_TRANSMITTANCE_CHECK
        #define FORCE_CLOSE_SEQUENCE_TRANSMITTANCE_CHECK 0
      #endif

      float3 clouds_hole_offset = get_clouds_hole_pos_vec();
      float3 clouds_start_trace = clouds_start_trace_base + clouds_hole_offset;

      reduce_steps(num_steps, dist, stepSize, distStart, end);

      #if CLOUDS_OPTIMIZE_OUTER_LOOP
      optimize_sequence_loop_num_steps(num_steps, dist, stepSize, view, clouds_start_trace, clouds_hole_offset);
      #endif

      CloudDensitySampleParams cloudSampleParams = prepare_clouds_density_sample_params(
        erosion_level, mip, clouds_hole_offset, num_steps, view, dist, stepSize, clouds_start_trace);

      float sigmaDs = CLOUDS_SIGMA*stepSize;//0.04..0.012 are valid clouds extinction coef

      #ifndef EARLY_LOOP_EXIT_CHECK
        #define EARLY_LOOP_EXIT_CHECK 0
      #endif

      LOOP
      for (int i = 0; i < num_steps; ++i, dist += stepSize)
      {
        #if EARLY_LOOP_EXIT_CHECK
          #if !JUST_CLOSE_SEQUENCE || FORCE_CLOSE_SEQUENCE_TRANSMITTANCE_CHECK
          if (integratedScatteringTransmittance.z<threshold)//early exit if we already get all light
          {
            break;
          }
          #endif
        #endif

        float3 sample_pos = view*dist + clouds_start_trace;

        float heightFraction;
        float cloudDensity = sample_clouds_density(cloudSampleParams, sample_pos, dist, heightFraction);

        //this is for near plane transition. Only needed for first sequence. Cost up to 0.1ms
        if (cloudDensity <= 0.0000001)
          continue;

        if (first_slice_disappear)//that is useful only for first slice
          cloudDensity *= saturate(dist*1./32);

        float beers_term = exp2(cloudDensity * sigmaDs);
        beers_term = lerp(1, beers_term, saturate(dist*distMulAdd.x + distMulAdd.y));
        float transmittance  = beers_term;
        float weight = 1-transmittance;
        weightedSequenceDist += dist*weight;
        totalSequenceWeight += weight;

        AdditionalLightingConstParams cp;
        cp.pos = sample_pos - clouds_hole_offset;
        cp.cloud_density = cloudDensity;
        cp.clouds_hole_offset = clouds_hole_offset;
        cp.height_fraction = heightFraction;
        cp.mip = mip;
        cp.erosion_level = erosion_level;
        cp.beers_term = beers_term;
        cp.integrated_scattering_transmittance = integratedScatteringTransmittance;

        calculate_additional_lighting(cp, additionalLighting, randomOfs);

        // Get sun luminance according to volumetric shadow and phase function
        float2 luminance = sunAmbientLuminance(sample_pos, heightFraction, mip, erosion_level, sunPixelHelper);

        //improved analytical scattering: frostbite clouds
        float2 integScatt = ( luminance - luminance * beers_term );//analytical integral for beers law. Scattering term is always (cloudDensity*sigma), and integral is divided by (cloudDensity*sigma), so it is just not needed

        integratedScatteringTransmittance.xy = integratedScatteringTransmittance.z * integScatt + integratedScatteringTransmittance.xy;
        integratedScatteringTransmittance.z *= transmittance;

        #if !EARLY_LOOP_EXIT_CHECK
          #if !JUST_CLOSE_SEQUENCE || FORCE_CLOSE_SEQUENCE_TRANSMITTANCE_CHECK
          if (integratedScatteringTransmittance.z<threshold)//early exit if we already get all light
          {
            //re-apply last sample - hides banding
            //but costs 0.05ms on XB1
            #if !_HARDWARE_XBOX && !_HARDWARE_PS4
            integratedScatteringTransmittance.xy = integratedScatteringTransmittance.z * integScatt + integratedScatteringTransmittance.xy;
            integratedScatteringTransmittance.z *= transmittance;
            #endif
            break;
          }
          #endif
        #endif
      }
    }

    half3 decodeScatteringColor(float2 integratedScattering, float3 worldPos)
    {
      half3 sun_light, amb_color;
      get_sun_sky_light(worldPos, sun_light, amb_color);
      return integratedScattering.x*sun_light + amb_color*integratedScattering.y;
    }

    struct CLOUDS_RET
    {
      half4 target0;
      float dist;
    };
    #include "daCloudsTonemap.hlsl"
    #include <pixelPacking/yCoCgSpace.hlsl>
    CLOUDS_RET get_clouds_ret(float4 integratedScatteringTransmittance, float dist, float3 additional_lighting)
    {
      integratedScatteringTransmittance.rgb += additional_lighting;
      #if ALREADY_TONEMAPPED_SCENE && RENDER_TO_TAA_SPACE
        integratedScatteringTransmittance.rgb = PackToYCoCg(integratedScatteringTransmittance.rgb);
        #if TAA_IN_HDR_SPACE
          integratedScatteringTransmittance.rgb *= simple_luma_tonemap(integratedScatteringTransmittance.x, TONEMAPPED_SCENE_EXPOSURE);
        #endif
        #if ALREADY_TONEMAPPED_SCENE == CLOUDS_TONEMAPPED_TO_SRGB
          integratedScatteringTransmittance.x *= 0.5;//todo: should be 1/exposure
          integratedScatteringTransmittance.gb = integratedScatteringTransmittance.gb*0.5+0.5;
        #endif
      #endif
      CLOUDS_RET result;
      result.target0.rgb = integratedScatteringTransmittance.rgb;
      result.target0.a = 1-integratedScatteringTransmittance.a;
      FLATTEN
      if (result.target0.a >= 1-CLOUDS_TRANSMITTANCE_THRESHOLD)
      {
        result.target0.rgb /= result.target0.a;
        result.target0.a = 1;
      }
      result.dist = dist/TRACE_DIST;
      return result;
    }

    float get_rounded_dist(float start, float stepSize)
    {
      const float stepSizeInv = 1.0 / stepSize;
      float ofs = frac(-frac(clouds_offset * stepSizeInv));
      return (floor(start * stepSizeInv) + ofs) * stepSize;
    }

    void get_offseted_dist(out float dist, inout float next_sequence_start, float randomOfs, float stepSize, float maxRandom, int stepsPerSequence)
    {
      const float sequenceLength = stepsPerSequence*stepSize;
      dist = get_rounded_dist(next_sequence_start,  stepSize);
      next_sequence_start = dist + sequenceLength;
      dist -= randomOfs*stepSize;
    }

    int get_steps(inout float next_sequence_start, float cStep, float nextStepSize, int stepsPerSequence)
    {
      int num_steps = stepsPerSequence;
      float stepMult = nextStepSize/cStep;
      float dif = (get_rounded_dist(next_sequence_start, nextStepSize) - next_sequence_start)/cStep;
      FLATTEN
      if (dif>=0.0 && dif <= stepMult-1.0);
      {
        num_steps += int(dif)+1;
        next_sequence_start += nextStepSize;
      }
      return num_steps;
    }

    void get_fog_impl(float2 scattering_tc, float3 v, float d, out float3 ext, out float3 insc, bool use_inf_fog)
    {
      #if !DUAL_PANORAMA
        if (skies_panoramic_scattering__inv_distance.x)
          scattering_tc = get_panoramic_scattering_tc(v);
      #endif

      float tcZ;
      if (use_inf_fog)
        tcZ = get_scattering_tc_long_z(d);
      else
        tcZ = get_scattering_tc_z(d);
      float4 combined = tex3Dlod(skies_frustum_scattering, float4(scattering_tc, tcZ, 0));
      insc.rgb = combined.rgb;
      float3 colored_transmittance = get_fog_prepared_tc(long_get_prepared_scattering_tc(v .y, d, preparedScatteringDistToTc));
      ext = color_scatter_loss(combined, colored_transmittance);
    }

##if clouds_use_legacy_tracing == yes
    void get_close_fog(float2 scattering_tc, float3 v, float d, out float3 ext, out float3 insc)
    {
      get_fog_impl(scattering_tc, v, d, ext, insc, false);
    }
    void get_inf_fog(float2 scattering_tc, float3 v, float d, out float3 ext, out float3 insc)
    {
      get_fog_impl(scattering_tc, v, d, ext, insc, true);
    }
##endif

  #if DUAL_PANORAMA
    static const float blue_noise_jitter[4*4] =//better make it texture
    {
      0.000000,0.500000,0.125000,0.625000,
      0.750000,0.250000,0.875000,0.375000,
      0.187500,0.687500,0.062500,0.562500,
      0.937500,0.437500,0.812500,0.312500
    };
  #endif

    float get_random_offset(uint2 screenpos)
    {
      #if TEMPORAL_REPROJECTION
        uint frameOver = TAA_CLOUDS_FRAMES;//with 16 results are slightly better, but we need to store "newFrame weight" in taa, to sample it from history, so we adjust weight accordingly (increase new frame weight, where pixel was offscreen in previous frame, not current one)
        return ((uint(current_frame_info.x) + uint(screenpos.x)*2789 + uint(screenpos.y)*2791)&(frameOver-1))/float(frameOver);
      #elif DUAL_PANORAMA
        uint frameOver = PANORAMA_TEMPORAL_SAMPLES;//todo: make this setting
        return ((current_frame_info.x%frameOver) + blue_noise_jitter[(uint(screenpos.x)&3) + 4*(uint(screenpos.y)&3)].x)/frameOver;
      #else
        return 0;
      #endif
    }

    #ifndef STEPS_PER_SEQUENCE
      #if TEMPORAL_REPROJECTION
        #if CLOUDS_FULLRES
          #define STEPS_PER_SEQUENCE 64 // fullres clouds can utilize more steps, since it's not blurred as much
        #else
          #define STEPS_PER_SEQUENCE 32
        #endif
      #elif JUST_CLOSE_SEQUENCE
        #define STEPS_PER_SEQUENCE closeSequenceSteps
      #else
        #define STEPS_PER_SEQUENCE 64
      #endif
    #endif

    #ifndef REDUCED_SEQUENCE_COUNT
      #define REDUCED_SEQUENCE_COUNT 0
    #endif

    #ifndef REDUCED_IN_CLOUDS_STEPS
      #define REDUCED_IN_CLOUDS_STEPS 0
    #endif

    #ifndef DETAILED_CLOUDS_REFLECTIONS
      #define DETAILED_CLOUDS_REFLECTIONS 0
    #endif

    #if CAN_BE_IN_CLOUDS && JUST_CLOSE_SEQUENCE
      #define IGNORE_CLOSE_OBJECTS 1
      #define CHECK_START_ON_IGNORE 1
    #elif CAN_BE_IN_CLOUDS && TEMPORAL_REPROJECTION
      ##if clouds_ignore_close_objects == on
        #define IGNORE_CLOSE_OBJECTS 1
      ##endif
    #endif

    float calc_dist_to_ground(float2 texcoord, float start, float viewLen)
    {
      #if INFINITE_SKIES
        return INFINITE_TRACE_DIST;
      #else
        float rawDepth = tex2Dlod(clouds_depth_gbuf, float4(texcoord,0,0)).x;
        float depth = linearize_z(rawDepth, zn_zfar.zw);
        #if IGNORE_CLOSE_OBJECTS
          bool ignoreClose = depth < clouds_min_apply_dist - 0.5;
          #if CHECK_START_ON_IGNORE
            ignoreClose = ignoreClose && start == 0;
          #endif
          FLATTEN if (ignoreClose)
            rawDepth = 0;
        #endif
        return rawDepth == 0 ? INFINITE_TRACE_DIST : depth*viewLen;
      #endif
    }

    float calc_erosion_level(int seqNo, float dist)
    {
      #if CLOUDS_JUST_ONE_SEQUENCE
        return 1.0;
      #else
        return seqNo < 3 ? 1 : 0.5*saturate(3 + (-1./60000)*dist);
      #endif
    }

    struct TraceConstParams
    {
      float3 view;
      float end;
      SunLightingPixelHelper sunPixelHelper;
      float2 scatteringTc;
      int stepsPerSequence;
      float randomOfs;
      float distStart;
      float2 distMulAdd;
      bool first_slice_disappear;
    };

    struct TraceAccumulationParams
    {
      float dist;
      float weightedDist;
      float totalWeight;
      float integratedTransmittance;
      float3 additionalLighting;
    #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
      float3 integratedScatteringColor; // TODO: we can combine it with integratedTransmittance
    #else
      float3 integratedScatteringTransmittanceEncoded;
    #endif
    };

    TraceAccumulationParams get_initial_accumulation_params()
    {
      TraceAccumulationParams ap;
      ap.dist = 0;
      ap.weightedDist = 0;
      ap.totalWeight = 0;
      ap.integratedTransmittance = 1;
      ap.additionalLighting = float3(0,0,0);
    #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
      ap.integratedScatteringColor = float3(0,0,0);
    #else
      ap.integratedScatteringTransmittanceEncoded = float3(0,0,1);
    #endif
      return ap;
    }

    float get_close_sequence_end()
    {
      return closeSequenceStepSize * closeSequenceSteps;
    }

    void get_and_apply_trace_init_modifiers(inout float start, float end, inout float stepSize, out float distStart, out float2 distMulAdd, out float first_slice_disappear)
    {
      distStart = 0;
      first_slice_disappear = false;
      distMulAdd = float2(0,1);

      #if CAN_BE_IN_CLOUDS && TEMPORAL_REPROJECTION
        float opacityDist = 3*closeSequenceStepSize;
        distStart = clouds_has_close_sequence ? get_close_sequence_end() - closeSequenceStepSize - opacityDist : 0;
        distStart = max(distStart, start);
        start = 0; // TODO: investigate if/why this is needed (probably stability)
        distMulAdd = float2(1./opacityDist, -distStart/opacityDist);
      #elif CAN_BE_IN_CLOUDS && JUST_CLOSE_SEQUENCE
        float opacityDist = 2.*closeSequenceStepSize;
        distMulAdd = float2(-1./opacityDist, (end-closeSequenceStepSize)/opacityDist);
        first_slice_disappear = true;
      #elif DUAL_PANORAMA
        stepSize = max(8., (end-start)/1024);
      #endif
    }

    // returns false if there is nothing to trace
    bool calc_trace_init_distances(float max_trace_dist, float2 texcoord, uint2 screenpos, float3 view, float viewLen, float startStepSize,
      out float start, out float end, out float infinite_end)
    {
      float distanceToClouds0, distanceToClouds1;
      distance_to_clouds(-view, distanceToClouds0, distanceToClouds1);

      distanceToClouds1 *= 1000;
      distanceToClouds0 *= 1000;

      start = distanceToClouds0;
      end = min(max_trace_dist, distanceToClouds1);

      BRANCH
      if (view.y < 0)
        end = min(distance_to_planet(view, INFINITE_TRACE_DIST), end);

      infinite_end = end;//probably better use distanceToClouds1, to avoid gbuffer interference

      BRANCH
      if (close_layer_should_early_exit())
        return false;

      float distToGround = calc_dist_to_ground(texcoord, start, viewLen);

      end = min(end, distToGround);
      #if CAN_BE_IN_CLOUDS && JUST_CLOSE_SEQUENCE
        end = min(get_close_sequence_end(), end);
      #endif

      const float unclampedStart = start;
      //todo: use tile info or previous frame info to get min distance to cloud in tile
      closest_tiled_dist_clamp(start, screenpos.xy);

      const float maxRandomOffset = startStepSize;
      start = max(start - maxRandomOffset, unclampedStart); // need to adjust for random offset (tile optimization does not account for it)

      return start >= 0 && start < end;
    }

    bool use_inf_fog_at_trace_end()
    {
      #if !CLOUDS_JUST_ONE_SEQUENCE && (CLOUDS_IS_PRESELECTED_FURTHEST_SEQUENCE || SEQUENCE_COUNT >=3)
        return true;
      #else
        return false;
      #endif
    }

    CLOUDS_RET process_cloud_trace_result(const float next_sequence_start, const float startStepSize, const int SEQUENCE_COUNT, const float infiniteEnd,
      const TraceConstParams cp, const TraceAccumulationParams ap)
    {
      float averageDist = ap.totalWeight>EPS ? ap.weightedDist/ap.totalWeight : infiniteEnd;
      #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_ONCE
        float3 integratedScatteringColor = decodeScatteringColor(ap.integratedScatteringTransmittanceEncoded.xy, skies_world_view_pos + cp.view*averageDist);
        BRANCH
        if (ap.integratedTransmittance<1)
        {
          float3 extinction, inscatter;
          const float emptySkyFogSamplingDist = 0.5*(next_sequence_start + cp.end); // TODO: looks arbitrary
          const float fogSamplingDist = ap.totalWeight>EPS ? averageDist : emptySkyFogSamplingDist;
          get_fog_impl(cp.scatteringTc, cp.view, fogSamplingDist, extinction, inscatter, use_inf_fog_at_trace_end());
          integratedScatteringColor = extinction*integratedScatteringColor + inscatter*(1-ap.integratedTransmittance);
        }
      #else
        float3 integratedScatteringColor = ap.integratedScatteringColor;
      #endif

      float integratedTransmittance = ap.integratedTransmittance;
      const bool useBlendFadout = clouds_blend_fadeout_start > 0 && (!CLOUDS_USE_PRESELECTED_SEQUENCE || CLOUDS_IS_PRESELECTED_FURTHEST_SEQUENCE);
      if (useBlendFadout)
      {
        // TODO: this fading is not correct, we need to use the actual step size (which can vary per sequence)
        #if CLOUDS_USE_PRESELECTED_SEQUENCE
          // the "next sequence start" is the distance to the end of the sequence, we can use that as the blending end distance
          const float blendDistEnd = next_sequence_start; // TODO: use this elsewhere
        #else
          // TODO: startStepSize and SEQUENCE_COUNT don't make sense here in all cases, the blending end dist can differ based on other values, fix it!
          const float blendDistEnd = CALC_PREV_LAYER_CLOUD_TRACE_DIST(SEQUENCE_COUNT, cp.stepsPerSequence, startStepSize);
        #endif
        const float blendDistStart = blendDistEnd*clouds_blend_fadeout_start;
        float blendOut = saturate(1-(averageDist-blendDistStart)/(blendDistEnd-blendDistStart));
        integratedScatteringColor *= blendOut;
        integratedTransmittance = 1-blendOut*(1-integratedTransmittance);
      }
      return get_clouds_ret(float4(integratedScatteringColor, integratedTransmittance), averageDist, ap.additionalLighting);
    }

    void perform_cloud_trace_sequence_impl(const int num_steps, const float stepSize,
      const float erosionLevel, const bool use_inf_fog,
      const TraceConstParams cp, inout TraceAccumulationParams ap)
    {
      float3 additionalLighting2 = 0;

      #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
        float weightedSequenceDist = 0, totalSequenceWeight = 0;
        float3 integratedScatteringTransmittance2 = float3(0,0,1);
        performSequence(cp.distStart, num_steps, cp.view, stepSize,cp.end,cp.sunPixelHelper, cp.randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD/max(ap.integratedTransmittance, EPS),
                        weightedSequenceDist, totalSequenceWeight, integratedScatteringTransmittance2, ap.dist, additionalLighting2, cp.distMulAdd, erosionLevel, false);
        float seqAvgDist = weightedSequenceDist/max(EPS, totalSequenceWeight);
        float3 decodedScatteringColor = decodeScatteringColor(integratedScatteringTransmittance2.xy, skies_world_view_pos + cp.view*seqAvgDist);
        if (totalSequenceWeight > EPS && integratedScatteringTransmittance2.z<1)
        {
          half3 extinction, inscatter;
          get_fog_impl(cp.scatteringTc, cp.view, seqAvgDist, extinction, inscatter, use_inf_fog);
          decodedScatteringColor.rgb = extinction*decodedScatteringColor.rgb + inscatter*(1-integratedScatteringTransmittance2.z);
          ap.additionalLighting.rgb += extinction * ap.integratedTransmittance*additionalLighting2;
        }
        ap.integratedScatteringColor.rgb += ap.integratedTransmittance*decodedScatteringColor.rgb;
        ap.integratedTransmittance *= integratedScatteringTransmittance2.z;
        ap.weightedDist += weightedSequenceDist; ap.totalWeight += totalSequenceWeight;
      #else
        performSequence(cp.distStart, num_steps, cp.view, stepSize,cp.end,cp.sunPixelHelper, cp.randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD,
                        ap.weightedDist, ap.totalWeight, ap.integratedScatteringTransmittanceEncoded, ap.dist, additionalLighting2, cp.distMulAdd, erosionLevel, cp.first_slice_disappear);
        ap.additionalLighting.rgb += ap.integratedTransmittance*additionalLighting2;
        ap.integratedTransmittance = ap.integratedScatteringTransmittanceEncoded.z;
      #endif
    }

  #if CLOUDS_JUST_ONE_SEQUENCE
    #if WEIGHTED_ATMOSPHERE_SCATTERING != WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
      error "CLOUDS_JUST_ONE_SEQUENCE requires WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE"
    #endif

    void perform_full_trace_single_sequence(const float start, const float3 viewVect,
      const TraceConstParams cp, inout TraceAccumulationParams ap)
    {
      const float erosionLevel = 1.0f;
      const bool use_inf_fog = false;

      const int count = lerp(trace_steps.x, trace_steps.y, sqrt(saturate(viewVect.y)));
      const float stepSize = max(64., (cp.end - start)/count);
      ap.dist = start - stepSize*cp.randomOfs;

      int num_steps = ceil((cp.end-ap.dist)/stepSize);
      num_steps = ceil((cp.end-ap.dist)*0.5/stepSize);//half dist
      perform_cloud_trace_sequence_impl(num_steps, stepSize, erosionLevel, use_inf_fog, cp, ap);
      num_steps = ceil((cp.end-ap.dist)/stepSize);
      perform_cloud_trace_sequence_impl(num_steps, stepSize, erosionLevel, use_inf_fog, cp, ap);
    }

  #else

    float get_step_size_mul(const int seqNo, const int SEQUENCE_COUNT)
    {
      #if CLOUDS_USE_PRESELECTED_SEQUENCE
        #if REDUCED_SEQUENCE_COUNT
          if (seqNo == 1)
            return 4.0;
        #else
          if (seqNo == 2)
            return 4.0;
        #endif
      #else
        if (seqNo > 0 && SEQUENCE_COUNT == 3)
          return 4.0;
      #endif
      return 2.0;
    }

    bool check_use_inf_fog(const int seqNo)
    {
      return seqNo >= 2;
    }

    static const float OFFSETTED_DIST_MAX_RANDOM = 64*4; // TODO: potentially incorrect

    void perform_cloud_trace_sequence(const int seqNo,
      inout float next_sequence_start, inout float stepSize, const int SEQUENCE_COUNT,
      const TraceConstParams cp, inout TraceAccumulationParams ap)
    {
      const bool use_inf_fog = check_use_inf_fog(seqNo);
      const float stepSizeMul = get_step_size_mul(seqNo, SEQUENCE_COUNT);
      get_offseted_dist(ap.dist, next_sequence_start, cp.randomOfs, stepSize, OFFSETTED_DIST_MAX_RANDOM, cp.stepsPerSequence);
      int num_steps = get_steps(next_sequence_start, stepSize, stepSize*stepSizeMul, cp.stepsPerSequence);
      const float erosionLevel = calc_erosion_level(seqNo, ap.dist);
      perform_cloud_trace_sequence_impl(num_steps, stepSize, erosionLevel, use_inf_fog, cp, ap);
      stepSize *= stepSizeMul;
    }

    void perform_full_trace_preselected_sequences(inout float next_sequence_start, const float startStepSize, const int SEQUENCE_COUNT,
      TraceConstParams cp, inout TraceAccumulationParams ap)
    {
      float stepSize = startStepSize;

      #if CLOUDS_PRESELECTED_SEQUENCE_NO >= 1
        cp.distMulAdd = float2(0,1);
        cp.first_slice_disappear = false;
      #endif

      // we do one sequence at a time for a shader execution, so we need to process the distance from the prev sequences
      UNROLL
      for (int i = 0; i < CLOUDS_PRESELECTED_SEQUENCE_NO; ++i)
      {
        float stepSizeMul = get_step_size_mul(i, SEQUENCE_COUNT);
        get_offseted_dist(ap.dist, next_sequence_start, cp.randomOfs, stepSize, OFFSETTED_DIST_MAX_RANDOM, cp.stepsPerSequence);
        int num_steps = get_steps(next_sequence_start, stepSize, stepSize*stepSizeMul, cp.stepsPerSequence);
        stepSize *= stepSizeMul;
      }

      perform_cloud_trace_sequence(CLOUDS_PRESELECTED_SEQUENCE_NO, next_sequence_start, stepSize, SEQUENCE_COUNT, cp, ap);
    }

    void perform_full_trace_regular_sequences(inout float next_sequence_start, const float startStepSize, const int SEQUENCE_COUNT,
      TraceConstParams cp, inout TraceAccumulationParams ap)
    {
      float stepSize = startStepSize;

      perform_cloud_trace_sequence(0, next_sequence_start, stepSize, SEQUENCE_COUNT, cp, ap);
      cp.distMulAdd = float2(0,1);
      cp.first_slice_disappear = false;
      BRANCH
      if (SEQUENCE_COUNT >= 2 && ap.integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && ap.dist<=cp.end)
      {
        perform_cloud_trace_sequence(1, next_sequence_start, stepSize, SEQUENCE_COUNT, cp, ap);

        UNROLL
        for (int i = 2; i <= 5; ++i)
        {
          BRANCH
          if (SEQUENCE_COUNT > i && ap.integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && ap.dist <= cp.end)
            perform_cloud_trace_sequence(i, next_sequence_start, stepSize, SEQUENCE_COUNT, cp, ap);
        }
      }
    }
  #endif

    CLOUDS_RET trace_clouds_impl(const float start, const float startStepSize, const int SEQUENCE_COUNT,
      const float3 viewVect, const float infiniteEnd, TraceConstParams cp)
    {
      TraceAccumulationParams ap = get_initial_accumulation_params();
      float nextSequenceStart = start;

      #if CLOUDS_JUST_ONE_SEQUENCE
        perform_full_trace_single_sequence(start, viewVect, cp, ap);
        nextSequenceStart = 0; // TODO: this isn't consistent with the other case!
      #else
        float stepSize = startStepSize;
        get_and_apply_trace_init_modifiers(nextSequenceStart, cp.end, stepSize, cp.distStart, cp.distMulAdd, cp.first_slice_disappear);
        #if CLOUDS_USE_PRESELECTED_SEQUENCE
          perform_full_trace_preselected_sequences(nextSequenceStart, stepSize, SEQUENCE_COUNT, cp, ap);
        #else
          perform_full_trace_regular_sequences(nextSequenceStart, stepSize, SEQUENCE_COUNT, cp, ap);
        #endif
      #endif

      return process_cloud_trace_result(nextSequenceStart, startStepSize, SEQUENCE_COUNT, infiniteEnd, cp, ap);
    }

    CLOUDS_RET trace_clouds(float3 viewVect, float2 texcoord, uint2 screenpos, float2 scatteringTc)
    {
      int stepsPerSequence = STEPS_PER_SEQUENCE;

      // TODO: refactor this mess
      #if CLOUDS_USE_PRESELECTED_SEQUENCE
        const int SEQUENCE_COUNT = 3;
        const float startStepSize = DETAILED_CLOUDS_REFLECTIONS ? 128 : 512; // cube or reflection
      #elif CAN_BE_IN_CLOUDS && JUST_CLOSE_SEQUENCE
        const int SEQUENCE_COUNT = 1;
        stepsPerSequence = REDUCED_IN_CLOUDS_STEPS ? steps_per_sequence / 2 : steps_per_sequence;
        const float startStepSize = closeSequenceStepSize*(32./stepsPerSequence);
      #elif DUAL_PANORAMA
        const int SEQUENCE_COUNT = 4;
        const float startStepSize = 256;
      #elif CAN_BE_IN_CLOUDS && !TEMPORAL_REPROJECTION
        const int SEQUENCE_COUNT = REDUCED_SEQUENCE_COUNT ? 3 : 4;
        const float startStepSize = DETAILED_CLOUDS_REFLECTIONS ? 128 : 512; // cube or reflection
      #elif CAN_BE_IN_CLOUDS && TEMPORAL_REPROJECTION
        const int SEQUENCE_COUNT = REDUCED_SEQUENCE_COUNT ? 3 : 5;
        stepsPerSequence = REDUCED_IN_CLOUDS_STEPS ? steps_per_sequence / 2 : steps_per_sequence;
        const float startStepSize = 256*(32./stepsPerSequence);
      #elif !CAN_BE_IN_CLOUDS && TEMPORAL_REPROJECTION
        const int SEQUENCE_COUNT = REDUCED_SEQUENCE_COUNT ? 2 : 3;
        const float startStepSize = 256;
      #else
        const int SEQUENCE_COUNT = REDUCED_SEQUENCE_COUNT ? 3 : 4;
        const float startStepSize = 128;
      #endif

      #if CLOUDS_USE_PRESELECTED_SEQUENCE
      // TODO: special case only to keep legacy behavior, and same perf
      const float actualTraceDist = CALC_CLOUD_TRACE_DIST(REDUCED_SEQUENCE_COUNT ? 3 : 4, stepsPerSequence, startStepSize);

      #else
      // TODO: this is not correct, we need to use the actual step size (which can vary per sequence)
      const float actualTraceDist = CALC_CLOUD_TRACE_DIST(SEQUENCE_COUNT, stepsPerSequence, startStepSize);
      #endif

      float stepSize = startStepSize;

      float viewLenSq = dot(viewVect, viewVect);
      float invViewLen = rsqrt(viewLenSq);
      float viewLen = rcp(invViewLen);
      float3 view = viewVect*invViewLen;

      float start, end, infiniteEnd;
      BRANCH if (!calc_trace_init_distances(actualTraceDist, texcoord, screenpos, view, viewLen, startStepSize, start, end, infiniteEnd))
        return get_clouds_ret(float4(0,0,0,1), infiniteEnd, 0); // use INF dist

##if clouds_use_legacy_tracing == no
      TraceConstParams cp;
      cp.view = view;
      cp.end = end;
      cp.sunPixelHelper = getSunHelper(view);
      cp.scatteringTc = scatteringTc;
      cp.stepsPerSequence = stepsPerSequence;
      cp.randomOfs = get_random_offset(screenpos);
      cp.distStart = 0; // overwritten by get_and_apply_trace_init_modifiers
      cp.distMulAdd = float2(0, 1); // NOP by default
      cp.first_slice_disappear = false;

      return trace_clouds_impl(start, startStepSize, SEQUENCE_COUNT, viewVect, infiniteEnd, cp);
##else

      SunLightingPixelHelper sunPixelHelper = getSunHelper(view);

      float dist = 0;

      float randomOfs = get_random_offset(screenpos);

      // Contains integrated scattered luminance (in rgb ) and trasmittance (in a) along a ray .
      float weightedDist = 0, totalWeight = 0;
      float3 integratedScatteringColor = 0; float integratedTransmittance = 1.0;
      float3 additionalLighting = 0;
      float3 integratedScatteringTransmittanceEncoded = float3(0,0,1);
      #define GET_FOG get_close_fog

      #if CLOUDS_JUST_ONE_SEQUENCE
        int count = lerp(trace_steps.x, trace_steps.y, sqrt(saturate(viewVect.y)));
        stepSize = max(64., (end-start)/count);
        start -= (stepSize)*randomOfs;
        dist = start; start = 0;

        #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
          #define PERFORM_SINGLE_SEQUENCE(num_steps) {\
            float weightedSequenceDist = 0, totalSequenceWeight = 0;\
            float3 integratedScatteringTransmittance2 = float3(0,0,1);\
            float3 additionalLighting2 = 0;\
            performSequence(0, num_steps, view, stepSize,end,sunPixelHelper, randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD/max(integratedTransmittance, EPS),\
                            weightedSequenceDist, totalSequenceWeight, integratedScatteringTransmittance2, dist, additionalLighting2, float2(0,1), 1, false);\
            float seqAvgDist = weightedSequenceDist/max(EPS, totalSequenceWeight);\
            float3 decodedScatteringColor = decodeScatteringColor(integratedScatteringTransmittance2.xy, skies_world_view_pos + view*seqAvgDist);\
            if (totalSequenceWeight > EPS && integratedScatteringTransmittance2.z<1)\
            {\
              half3 extinction, inscatter;\
              GET_FOG(scatteringTc, view, seqAvgDist, extinction, inscatter);\
              decodedScatteringColor.rgb = extinction*decodedScatteringColor.rgb + inscatter*(1-integratedScatteringTransmittance2.z); \
              additionalLighting.rgb += extinction * integratedTransmittance*additionalLighting2;\
            }\
            integratedScatteringColor.rgb += integratedTransmittance*decodedScatteringColor.rgb;\
            integratedTransmittance *= integratedScatteringTransmittance2.z;\
            weightedDist += weightedSequenceDist; totalWeight += totalSequenceWeight;\
          }
        #else
          #define PERFORM_SINGLE_SEQUENCE(num_steps)\
            performSequence(0, num_steps, view, stepSize,end,sunPixelHelper, randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD,\
                            weightedDist, totalWeight, integratedScatteringTransmittanceEncoded, dist, additionalLighting2, float2(0,1), 1, false);\
            integratedTransmittance = integratedScatteringTransmittanceEncoded.z;
        #endif

        int num_steps = ceil((end-dist)/stepSize);
        #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
          num_steps = ceil((end-dist)*0.5/stepSize);//half dist
          PERFORM_SINGLE_SEQUENCE(num_steps);
          num_steps = ceil((end-dist)/stepSize);
          PERFORM_SINGLE_SEQUENCE(num_steps);
        #else
        PERFORM_SINGLE_SEQUENCE(num_steps);
        #endif
      #else
        #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_SEQUENCE
          #define PERFORM_SEQUENCE(seqNo, mulS) \
            get_offseted_dist(dist, start, randomOfs, stepSize, 64*4, stepsPerSequence);\
            float weightedSequenceDist = 0, totalSequenceWeight = 0;\
            float3 integratedScatteringTransmittance2 = float3(0,0,1);\
            float3 additionalLighting2 = 0;\
            int num_steps = get_steps(start, stepSize, stepSize*mulS, stepsPerSequence);\
            float erosionLevel = calc_erosion_level(seqNo, dist);\
            performSequence(distStart, num_steps, view, stepSize,end,sunPixelHelper, randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD/integratedTransmittance,\
                            weightedSequenceDist, totalSequenceWeight, integratedScatteringTransmittance2, dist, additionalLighting2, distMulAdd, erosionLevel, false);\
            float seqAvgDist = weightedSequenceDist/max(EPS, totalSequenceWeight);\
            float3 decodedScatteringColor = decodeScatteringColor(integratedScatteringTransmittance2.xy, skies_world_view_pos + view*seqAvgDist);\
            if (totalSequenceWeight > EPS && integratedScatteringTransmittance2.z<1)\
            {\
              half3 extinction, inscatter;\
              GET_FOG(scatteringTc, view, seqAvgDist, extinction, inscatter);\
              decodedScatteringColor.rgb = extinction*decodedScatteringColor.rgb + inscatter*(1-integratedScatteringTransmittance2.z); \
              additionalLighting.rgb += extinction * integratedTransmittance*additionalLighting2;\
            }\
            integratedScatteringColor.rgb += integratedTransmittance*decodedScatteringColor.rgb;\
            integratedTransmittance *= integratedScatteringTransmittance2.z;\
            weightedDist += weightedSequenceDist; totalWeight += totalSequenceWeight;\
            stepSize=stepSize*mulS;
        #else
          #define PERFORM_SEQUENCE(seqNo, mulS)\
            get_offseted_dist(dist, start, randomOfs, stepSize, 64*4, stepsPerSequence);\
            int num_steps = get_steps(start, stepSize, stepSize*mulS, stepsPerSequence);\
            float erosionLevel = calc_erosion_level(seqNo, dist);\
            float3 additionalLighting2 = 0;\
            performSequence(distStart, num_steps, view, stepSize,end,sunPixelHelper, randomOfs, CLOUDS_TRANSMITTANCE_THRESHOLD,\
                            weightedDist, totalWeight, integratedScatteringTransmittanceEncoded, dist, additionalLighting2, distMulAdd, erosionLevel, first_slice_disappear);\
            additionalLighting.rgb += integratedTransmittance*additionalLighting2;\
            integratedTransmittance = integratedScatteringTransmittanceEncoded.z;\
            stepSize=stepSize*mulS;
        #endif

        float distStart;
        float2 distMulAdd;
        bool first_slice_disappear;
        get_and_apply_trace_init_modifiers(start, end, stepSize, distStart, distMulAdd, first_slice_disappear);

        #if CLOUDS_PRESELECTED_SEQUENCE > 0
          // not exactly precise compared to original approach, but good enough
          // TODO: improve via subpass logic
          #if CLOUDS_PRESELECTED_SEQUENCE == 1
            PERFORM_SEQUENCE(0, 2.0)
          #else
            stepSize=stepSize*2.0;
            distMulAdd = float2(0,1);
            first_slice_disappear = false;
            #if CLOUDS_PRESELECTED_SEQUENCE == 2
              PERFORM_SEQUENCE(1, (SEQUENCE_COUNT == 3 ? 4 : 2))
            #else
              #undef GET_FOG
              #define GET_FOG get_inf_fog
              stepSize=stepSize*(SEQUENCE_COUNT == 3 ? 4 : 2);
              PERFORM_SEQUENCE(2, (SEQUENCE_COUNT == 4 ? 4 : 2))
            #endif
          #endif
        #else

        PERFORM_SEQUENCE(0, 2.0)
        distMulAdd = float2(0,1);
        first_slice_disappear = false;
        BRANCH
        if (SEQUENCE_COUNT >= 2 && integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && dist<=end)
        {
          PERFORM_SEQUENCE(1, (SEQUENCE_COUNT == 3 ? 4 : 2))

          BRANCH
          if (SEQUENCE_COUNT >=3 && integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && dist<=end)
          {
            #undef GET_FOG
            #define GET_FOG get_inf_fog
            PERFORM_SEQUENCE(2, (SEQUENCE_COUNT == 4 ? 4 : 2))

            BRANCH
            if (SEQUENCE_COUNT >=4 && integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && dist<=end)
            {
              PERFORM_SEQUENCE(3, 2)
              BRANCH
              if (SEQUENCE_COUNT >=5 && integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && dist<=end)
              {
                PERFORM_SEQUENCE(4, 2)
                BRANCH
                if (SEQUENCE_COUNT >=6 && integratedTransmittance >= CLOUDS_TRANSMITTANCE_THRESHOLD && dist<=end)
                {
                  PERFORM_SEQUENCE(5, 2)
                }
              }
            }
          }
        }

        #endif
      #endif
      float averageDist = totalWeight>EPS ? weightedDist/totalWeight : infiniteEnd;
      #if WEIGHTED_ATMOSPHERE_SCATTERING == WEIGHTED_ATMOSPHERE_SCATTERING_ONCE
      integratedScatteringColor = decodeScatteringColor(integratedScatteringTransmittanceEncoded.xy, skies_world_view_pos + view*averageDist);
      BRANCH
      if (integratedTransmittance<1)
      {
        float3 extinction, inscatter;
        float useDist = totalWeight>EPS ? averageDist : 0.5*(start+end);
        GET_FOG(scatteringTc, view, useDist, extinction, inscatter);
        integratedScatteringColor.rgb = extinction*integratedScatteringColor.rgb + inscatter*(1-integratedTransmittance);
      }
      #endif

      #if CLOUDS_PRESELECTED_SEQUENCE > 0
        const float blendDistEnd = CALC_PREV_LAYER_CLOUD_TRACE_DIST(CLOUDS_PRESELECTED_SEQUENCE, stepsPerSequence, startStepSize);
      #else
        const float blendDistEnd = CALC_PREV_LAYER_CLOUD_TRACE_DIST(SEQUENCE_COUNT, stepsPerSequence, startStepSize);
      #endif
      const float blendDistStart = blendDistEnd*clouds_blend_fadeout_start;
      float blendOut = saturate(1-(averageDist-blendDistStart)/(blendDistEnd-blendDistStart));
      integratedScatteringColor *= blendOut;
      integratedTransmittance = 1-blendOut*(1-integratedTransmittance);

      return get_clouds_ret(float4(integratedScatteringColor, integratedTransmittance), averageDist, additionalLighting);
##endif
    }
  }
endmacro

shader clouds2_temporal_ps, clouds2_close_temporal_ps, clouds2_direct
{
  cull_mode=none;
  z_write=false;
  if (shader == clouds2_direct)
  {
    blend_src = one;
    blend_dst = isa;
    USE_SPECIAL_VISION()
    INIT_HDR(ps)
    USE_HDR(ps)
    hlsl {
      // sequence are applied in reversed order: the first sequence is the furthest from the camera
      ##if clouds_direct_sequence == first
        #define CLOUDS_PRESELECTED_SEQUENCE_NO 2
      ##elif clouds_direct_sequence == second
        #define CLOUDS_PRESELECTED_SEQUENCE_NO 1
      ##elif clouds_direct_sequence == third
        #define CLOUDS_PRESELECTED_SEQUENCE_NO 0
      ##endif

      // TODO: these are deprecated, and only used for the legacy version
      ##if clouds_direct_sequence == first
        #define CLOUDS_PRESELECTED_SEQUENCE 1
      ##elif clouds_direct_sequence == second
        #define CLOUDS_PRESELECTED_SEQUENCE 2
      ##elif clouds_direct_sequence == third
        #define CLOUDS_PRESELECTED_SEQUENCE 3
      ##endif
    }
  }

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float2 tc : TEXCOORD0;
      float3 viewVect : TEXCOORD1;
    };
  }

  USE_POSTFX_VERTEX_POSITIONS()
  USE_AND_INIT_VIEW_VEC(vs)
  RAYCAST_CLOUDS(ps)
  ENABLE_ASSERT(ps)

  hlsl(vs) {
    VsOutput clouds_vs(uint vertexId : SV_VertexID)
    {
      VsOutput output;
      float2 pos = getPostfxVertexPositionById(vertexId);
      output.pos = float4(pos.xy, 1, 1);
      #if INFINITE_SKIES
        output.pos.z = 0;
      #endif
      output.tc = screen_to_texcoords(pos);
      output.viewVect = get_view_vec_by_vertex_id(vertexId);
      return output;
    }
  }

  hlsl(ps) {
    struct PS_CLOUDS_RET
    {
      float4 target0            : SV_Target0;
      #if HAS_DEPTH_TARGET
      float target1            : SV_Target1;
      #endif
    };
    PS_CLOUDS_RET clouds_ps(VsOutput input HW_USE_SCREEN_POS)
    {
      float4 screenpos = GET_SCREEN_POS(input.pos);
      float2 texcoord = input.tc;//fixme: remove me in panoram

      float3 viewVect = input.viewVect;
      CLOUDS_RET tr = trace_clouds(viewVect, texcoord, uint2(screenpos.xy), texcoord);
      ##if shader == clouds2_direct
        applySpecialVision(tr.target0);
        tr.target0.rgb = pack_hdr(tr.target0.rgb);
      ##endif
      PS_CLOUDS_RET ret;
      ret.target0 = tr.target0;
      #if HAS_DEPTH_TARGET
        ret.target1 = tr.dist;
      #endif
      return ret;
    }
  }

  compile("target_vs", "clouds_vs");
  compile("target_ps", "clouds_ps");
}

int4 clouds2_resolution;
float4 clouds2_dispatch_groups;

shader clouds2_temporal_cs, clouds2_close_temporal_cs
{
  INIT_AND_USE_ON_TOP_CAMERA_IN_CAMERA(cs)
  ENABLE_ASSERT(cs)
  RAYCAST_CLOUDS(cs)
  VIEW_VEC_OPTIMIZED(cs)

  if (shader == clouds2_close_temporal_cs)
  {
    (cs)
    {
      invres@f4 = (1./clouds2_resolution.z, 1./clouds2_resolution.w, 0.5/clouds2_resolution.z, 0.5/clouds2_resolution.w);
      res@u2 = clouds2_resolution.zw;
    }
  } else
  {
    (cs)
    {
      invres@f4 = (1./clouds2_resolution.x, 1./clouds2_resolution.y, 0.5/clouds2_resolution.x, 0.5/clouds2_resolution.y);
      res@u2 = clouds2_resolution.xy;
    }
  }

  hlsl(cs) {
    RWTexture2D<float4> target0: register(u0);
    RWTexture2D<float4> target1: register(u1);

    [numthreads(CLOUD_TRACE_WARP_X, CLOUD_TRACE_WARP_Y, 1)]
    void cs_main(uint2 dtid : SV_DispatchThreadID)
    {
      if (any(dtid >= res))
        return;

      float2 texcoord = dtid*invres.xy + invres.zw;
      DISCARD_IF_INVALID_VIEW_AREA_CS(texcoord);

      float3 viewVect = getViewVecOptimized(texcoord);
      CLOUDS_RET tr = trace_clouds(viewVect, texcoord, dtid, texcoord);

      texture2DAt(target0, dtid) = tr.target0;
      #if HAS_DEPTH_TARGET
      texture2DAt(target1, dtid) = tr.dist;
      #endif
    }
  }
  compile("cs_5_0", "cs_main");
}

texture sky_panorama_tex;
include "use_strata_clouds.dshl"
float4 clouds_panorama_subpixel;
float4 clouds_panorama_temp_res;
float4 clouds_panorama_tex_res;
float clouds_panorama_blend;

int subpassTrace0_reg_no = 11;

shader clouds_panorama, clouds_alpha_panorama
{
  cull_mode=none;
  z_write=false;
  z_test=false;
  ATMO(ps)
  GET_ATMO(ps)
  if (shader == clouds_panorama)
  {
    USE_SKIES_SUN_COLOR(ps)
    (ps) {
      skies_transmittance_texture@smp2d = skies_transmittance_texture;
      sky_panorama_tex@smp2d = sky_panorama_tex;
      skies_froxels_resolutionInv@f3 = (1./skies_froxels_resolution.x, 1./skies_froxels_resolution.y, 1./skies_froxels_resolution.z);
    }
  }

  if (clouds_panorama_split != off)
  {
    //keep it compiled only where it is usefull
    if ((shader != clouds_panorama) || (clouds_panorama_depth_out == on))
    {
      dont_render;
    }
  }

  if (clouds_panorama_split != trace)
  {
    blend_src = sa;
    blend_dst = isa;
  }

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float2 tc : TEXCOORD0;
    };
  }

  USE_POSTFX_VERTEX_POSITIONS()
  (vs) { tc_pos_ofs@f4 = panoramaTC; }
  (ps) {
    tc_pos_ofs@f4 = panoramaTC;
    skies_panorama_sun_opposite_tc_x@f1 = skies_panorama_sun_opposite_tc_x;
    clouds_panorama_blend_weight@f1 = (clouds_panorama_blend,0,0,0);
  }
  INIT_AND_USE_PANORAMA_VIEW_VECT(ps)

  RAYCAST_CLOUDS(ps)
  hlsl(ps) {
    #define USE_STRATA_LOD(a) 0
  }
  USE_STRATA_CLOUDS(ps)
  if (shader == clouds_panorama && use_postfx == off)
  {
    FULL_TONEMAP_LUT_APPLY(ps)
  }

  if (clouds_panorama_split == blend && shader == clouds_panorama)
  {
    USE_SUBPASS_LOADS()

    // @TODO: make SUBPASS_RESOURCE a dshl macro which uses the new syntax for hardcoding vars
    if (hardware.vulkan || hardware.metaliOS)
    {
      hlsl(ps) {
        SUBPASS_RESOURCE(subpassTrace0, t11, 0); // subpass_read_bind_offset
      }
    }
    else
    {
      (ps) {
        subpassTrace0@tex2d : register(subpassTrace0_reg_no);
      }
    }
  }

  hlsl(vs) {
    VsOutput clouds_vs(uint vertexId : SV_VertexID)
    {
      VsOutput output;
      float2 pos = getPostfxVertexPositionById(vertexId);
      output.pos = float4(pos.xy, 0, 1);
      output.tc = screen_to_texcoords(pos);
      if (tc_pos_ofs.z != 0)
        output.tc = output.tc * tc_pos_ofs.zw + tc_pos_ofs.xy;
      return output;
    }
  }

  hlsl(ps) {
    struct PS_CLOUDS_RET
    {
      float4 target0            : SV_Target0;

      // for clouds_panorama_depth_out contains dist data
      // for clouds_panorama_split metal path it contains final color data
      ##if (shader != clouds_alpha_panorama && clouds_panorama_depth_out == on) || (hardware.metal && (shader == clouds_panorama) && (clouds_panorama_split == blend))
        float4 target1            : SV_Target1;
      ##endif
    };

    PS_CLOUDS_RET clouds_ps(VsOutput input HW_USE_SCREEN_POS)
    {
      float4 screenpos = GET_SCREEN_POS(input.pos);
      int2 screenposi = int2(screenpos.xy);
      float2 texcoord = input.tc;

      // Make bottom of the panorama uniformly dark (avoid unpleasant pole).
      if (int(screenpos.y) <= 1 && tc_pos_ofs.z != 0)
        texcoord = float2(skies_panorama_sun_opposite_tc_x, 0);

      float3 viewVect = get_panorama_viewvect(texcoord);
      float3 patchView = get_panorama_patch_viewvect(texcoord);

      if (tc_pos_ofs.z == 0)
      {
        viewVect = patchView;
      }
      ##if shader != clouds_alpha_panorama

        float2 panoramaTc = texcoord;
        if (tc_pos_ofs.z == 0)
          panoramaTc = get_panorama_tc_from_view(viewVect);

        float2 scatteringTc = panoramaTc;//we render scattering specially for panorama. Better distribution, knowing that not much is needed lower than horizon
        #if !MOBILE_DEVICE
          float radius = (((uint(current_frame_info.x)%(PANORAMA_TEMPORAL_SAMPLES+1))>>2)+0.5)/((PANORAMA_TEMPORAL_SAMPLES)>>2);
          //blur scattering a bit
          scatteringTc += radius*float2(((uint(current_frame_info.x)&1)-0.5), (((uint(current_frame_info.x)>>1)&1)-0.5))*skies_froxels_resolutionInv.xy;
        #endif
      ##else
        float2 scatteringTc = 0;
      ##endif
      //for panorama in particular, it makes WAY more sense to use same panoramic representation (less detailed when looking down)
      //todo: optimize allocation!

      ##if (clouds_panorama_split == blend) && (shader == clouds_panorama)
        CLOUDS_RET tr;
        tr.target0 = SUBPASS_LOAD(subpassTrace0, texcoord);
        //not used as for now, implement on demand
        tr.dist = 0;//SUBPASS_LOAD(subpassTrace1, texcoord);
      ##else
        CLOUDS_RET tr = trace_clouds(viewVect, texcoord, screenposi, scatteringTc);
      ##endif

      PS_CLOUDS_RET ret;


      ##if (clouds_panorama_split == trace) && (shader == clouds_panorama)
        ret.target0 = tr.target0;
        return ret;
      ##endif

      ##if shader == clouds_alpha_panorama
        ret.target0 = (1 - tr.target0.a)*(1-get_strata_clouds(viewVect, 0).a);
        ret.target0.a = clouds_panorama_blend_weight ? clouds_panorama_blend_weight : 0.1;
      ##else
        half3 sky = 0;
        //BRANCH
        //if (tr.target0.a < 1)
        {
          sky = tex2Dlod(sky_panorama_tex, float4(panoramaTc,0,0)).rgb;
          float nu = dot(viewVect, real_skies_sun_light_dir.xzy);
          Length r = skies_world_view_pos.y/1000+theAtmosphere.bottom_radius;
          if (abs(r - theAtmosphere.top_radius)<0.01)
            r = theAtmosphere.top_radius+0.01;
          BRANCH
          if (visibleSun(nu) && !RayIntersectsGround(theAtmosphere, r, viewVect.y) && real_skies_sun_color.r>0)
          {
            DimensionlessSpectrum sun_transmittance = GetTransmittanceToTopAtmosphereBoundary(
                theAtmosphere,
                SamplerTexture2DFromName(skies_transmittance_texture),
                r, viewVect.y);
            if (sun_transmittance.x > 0 )
              sky += calcSunColor(nu, sun_transmittance, real_skies_sun_color.rgb);
          }
          half4 strata = get_strata_clouds(viewVect, scatteringTc);
          sky.rgb = lerp(sky.rgb, strata.rgb, strata.a);
          tr.target0.rgb = tr.target0.rgb + (1-tr.target0.a)*sky;
        }

        float3 resultRGB = tr.target0.rgb;
        float resultAlpha = clouds_panorama_blend_weight ? clouds_panorama_blend_weight :
          (tr.target0.a > 0 ? lerp(0.15, 0.12, tr.target0.a) : 0.15);
      ##if use_postfx == off
        //with PBR we apply tonemap at panorama apply
        //otherwise exposure will be applied wrongly
        #if !PBR_FORWARD_SHADING
          resultRGB = performLUTTonemap(resultRGB);
        #endif
      ##endif

        float4 result = float4(resultRGB, resultAlpha);

        // for metal all targets are bound so here we have to
        // explicitly write to second target
        ##if hardware.metal && (shader == clouds_panorama) && (clouds_panorama_split == blend)
          ret.target0 = float4(0, 0, 0, 0);
          ret.target1 = result;
        ##else
          ret.target0 = result;

          ##if clouds_panorama_depth_out == on
            ret.target1 = tr.dist;
            ret.target1.a = current_frame_info.y;
          ##endif
        ##endif
      ##endif // tied to shader == clouds_alpha_panorama
      return ret;
    }
  }

  compile("target_vs", "clouds_vs");
  compile("target_ps", "clouds_ps");
}
