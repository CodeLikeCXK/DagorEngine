include "shader_global.dshl"
include "pivot_painter.dshl"
include "rt/bvh_process_tree_vertices_inc.dshl"
include "bvh_math_util.dshl"

texture perlin_noise3d;

int bvh_process_tree_vertices_is_pivoted;
interval bvh_process_tree_vertices_is_pivoted : no < 1, yes;

int bvh_process_tree_vertices_is_pos_inst;
interval bvh_process_tree_vertices_is_pos_inst : no < 1, yes;

int bvh_process_tree_vertices_source_const_no = 6 always_referenced;
int bvh_process_tree_vertices_output_uav_no = 0 always_referenced;
int bvh_process_tree_vertices_pp_pos_no = 7 always_referenced;
int bvh_process_tree_vertices_pp_dir_no = 8 always_referenced;
int bvh_process_tree_vertices_pp_sampler_no = 4 always_referenced;
int bvh_process_tree_vertices_params_no = 5 always_referenced;

float tree_wind_branch_amp = 0.5;
float tree_wind_detail_amp = 0.5;
float tree_wind_speed = 0.1;
float tree_wind_time = 0;

float4 tree_wind_blend_params1 = (1, 0, 0, 0); // treeWindBlendScale; treeWindBlendOutStart; treeDeformStart; treeDeformScale

block(scene) bvh_process_tree_vertices_block
{
  (cs) {
    tree_wind_params@f4 = (tree_wind_time, tree_wind_branch_amp, tree_wind_detail_amp, tree_wind_speed);
    tree_wind_blend_params1@f4 = tree_wind_blend_params1;

    perlin_noise3d@smp3d = perlin_noise3d;
  }
  INIT_BVH_TREE_ANIMATION()
}

shader bvh_process_tree_vertices
{
  NO_DYNSTCODE()

  supports bvh_process_tree_vertices_block;

  if (compatibility_mode == compatibility_mode_on)
  {
    dont_render;
  }
  ENABLE_ASSERT(cs)

  hlsl(cs) {
    Texture2D pp_pos_tex : register(t7);
    Texture2D pp_dir_tex : register(t8);

    SamplerState pp_sampler : register(s4);

    ByteAddressBuffer source : register(t6);
    RWByteAddressBuffer output : register(u0);

    float4 sample_pp_pos_tex(float2 tc) { return pp_pos_tex.SampleLevel(pp_sampler, tc, 0); }
    float4 sample_pp_dir_tex(float2 tc) { return pp_dir_tex.SampleLevel(pp_sampler, tc, 0); }

    #include "bvh_process_tree_vertices.hlsli"
    ConstantBuffer<BvhTreeInstanceData> params : register(b5);

    float3 get_wind_channel_strength() { return params.wind_channel_strength.xyz; }
    float get_wind_noise_speed_base() { return params.wind_noise_speed_base; }
    float get_wind_noise_speed_level_mul() { return params.wind_noise_speed_level_mul; }
    float get_wind_angle_rot_base() { return params.wind_angle_rot_base; }
    float get_wind_angle_rot_level_mul() { return params.wind_angle_rot_level_mul; }
    float get_wind_parent_contrib() { return params.wind_parent_contrib; }
    float get_wind_motion_damp_base() { return params.wind_motion_damp_base; }
    float get_wind_motion_damp_level_mul() { return params.wind_motion_damp_level_mul; }
    float4 get_wind_per_level_angle_rot_max() { return params.wind_per_level_angle_rot_max ;}
  }

  // Game specific
  BVH_TREE_ANIMATION()
  USE_PACKED_ITM_PRECISE(cs)

  hlsl(cs) {
    #pragma wave32

    #include "riextra_per_instance.hlsli"

    [numthreads( 32, 1, 1 )]
    void bvh_process_tree_vertices(uint3 dtId : SV_DispatchThreadID)
    {
      uint vertexId = dtId.x;
      if (vertexId >= params.vertex_count)
        return;

      uint vertexStart = (params.start_vertex + vertexId) * params.vertex_stride;

      const uint4 INPUT_ENCODING_OFFSET = uint4(16, 8, 0, 24);

      PRECISE float3 inputPos = asfloat(loadBuffer3(source, vertexStart + params.position_offset));
      uint   packedNormal     = loadBuffer(source, vertexStart + params.normal_offset);
      float3 inputNormal      = (float4((packedNormal >> INPUT_ENCODING_OFFSET) & 255).xyz / 255) * 2 - 1;
      uint   packedColor      = loadBuffer(source, vertexStart + params.color_offset);
      float4 inputColor       = float4((packedColor >> INPUT_ENCODING_OFFSET) & 255) / 255;
      float2 indirectTexcoord = 0;
      if (params.indirect_texcoord_offset != ~0u)
        indirectTexcoord = asfloat(loadBuffer2(source, vertexStart + params.indirect_texcoord_offset));

      uint perInstanceRenderDataOffset = params.perInstanceRenderAdditionalData&RIEXTRA_PER_INSTANCE_RENDER_OFFSET_MASK;
      uint perInstanceRenderDataFlags  = (params.perInstanceRenderAdditionalData&RIEXTRA_PER_INSTANCE_RENDER_DATA_FLAG_MASK)>>RIEXTRA_PER_INSTANCE_RENDER_DATA_FLAG_BIT_OFFSET;

      PRECISE float4 worldPos4;
      float3 worldNormal;

      // Game specific
      bvh_tree_animation(indirectTexcoord,
                         inputColor,
                         params.wtm,
                         inputPos,
                         inputNormal,
                         tree_wind_params,
                         perInstanceRenderDataOffset,
                         perInstanceRenderDataFlags,
                         worldPos4,
                         worldNormal);

      float3 animatedLocalPos = mul_packed_itm(worldPos4.xyz, params.packed_itm);

      storeBuffer3(output, params.target_offset + vertexId * params.processed_vertex_stride, asuint(animatedLocalPos));

      uint offset = 12;

      if (params.texcoord_size == 4)
      {
        storeBuffer(output, params.target_offset + vertexId * params.processed_vertex_stride + offset, loadBuffer(source, vertexStart + params.texcoord_offset));
        offset += 4;
      }
      else if (params.texcoord_size == 8)
      {
        storeBuffer2(output, params.target_offset + vertexId * params.processed_vertex_stride + offset, loadBuffer2(source, vertexStart + params.texcoord_offset));
        offset += 8;
      }

      float3 animatedLocalNormal  = normalize(mul(worldNormal, extract_mat33_from_packed_itm(params.packed_itm)));
      uint3  animatedLocalNormalI = uint3((animatedLocalNormal * 0.5 + 0.5) * 255) << INPUT_ENCODING_OFFSET.xyz;
      uint   animatedLocalNormalP = animatedLocalNormalI.x | animatedLocalNormalI.y | animatedLocalNormalI.z | (packedNormal << 24);
      storeBuffer(output, params.target_offset + vertexId * params.processed_vertex_stride + offset, animatedLocalNormalP);
      offset += 4;
    }
  }

  compile("target_cs", "bvh_process_tree_vertices");
}
