include_optional "trace_inline_ps5.dshl"
include "heightmap_common.dshl"
include_optional "rt/rt_underwater_fade.dshl"

buffer bvh_meta;
buffer bvh_per_instance_data;
buffer bvh_particle_data;

tlas bvh_main;
tlas bvh_terrain;
tlas bvh_particles;

int bvh_main_valid;
int bvh_terrain_valid;
int bvh_particles_valid;

int bvh_textures_range_start = 0;
int bvh_cube_textures_range_start = 0;
int bvh_buffers_range_start = 0;
int bvh_samplers_range_start = 0;
int bvh_meta_count = 0;

float4 bvh_origin;

float bvh_mip_range;
float bvh_mip_scale;
float bvh_mip_bias;
float bvh_additional_impostor_mip_bias = 0;
float bvh_tan_pixel_angular_radius = 0.0;
float bvh_smoothness_coef = 0.7;
float bvh_foliage_bias = 0.02;

int bvh_debug_value = 0;
int bvh_max_ahs_calls = 1000;

int bvh_impostor_start_offset = 0;
int bvh_impostor_end_offset = 0;

int bvh_terrain_has_holes = 0;
interval bvh_terrain_has_holes: no < 1, yes;

// Needed for dissolving
texture perlin_noise3d;

macro INIT_BVH_DISSOLVE(stage)
  (stage) {
    perlin_noise3d@smp3d = perlin_noise3d;
  }
endmacro

macro USE_BVH_DISSOLVE(stage)
  hlsl (stage) {
    float get_dissolve_value_from_world_position(float3 world_pos)
    {
      return tex3Dlod(perlin_noise3d, float4(frac(world_pos * 10), 0)).x;
    }

    #define BVH_SUPPORT_DISSOLVE 1
  }
endmacro

hlsl
{
  #define INF 1e6
}

macro INIT_MAIN_BVH(stage, coherent_rays, thirty_two_waves)
  if (hardware.ps5)
  {
    INIT_PS5_INLINE_RT(stage)
  }

  if (bvh_terrain_has_holes == yes)
  {
    INIT_HMAP_HOLES(stage)
  }

  (stage)
  {
    bvh_debug_value@i1 = bvh_debug_value;
    bvh_textures_range_start@i1 = bvh_textures_range_start;
    bvh_cube_textures_range_start@i1 = bvh_cube_textures_range_start;
    bvh_buffers_range_start@i1 = bvh_buffers_range_start;
    bvh_meta_count@i1 = bvh_meta_count;
    bvh_origin@f3 = bvh_origin;
    bvh_mip_range@f1 = bvh_mip_range;
    bvh_mip_scale@f1 = bvh_mip_scale;
    bvh_mip_bias@f1 = bvh_mip_bias;
    bvh_additional_impostor_mip_bias@f1 = bvh_additional_impostor_mip_bias;
    bvh_tan_pixel_angular_radius@f1 = bvh_tan_pixel_angular_radius;
    bvh_smoothness_coef@f1 = bvh_smoothness_coef;
    bvh_foliage_bias@f1 = bvh_foliage_bias;
    bvh_max_ahs_calls@i1 = bvh_max_ahs_calls;
    bvh_impostor_begin_end@u2 = (bvh_impostor_start_offset, bvh_impostor_end_offset);
    bvh_meta@buf = bvh_meta hlsl
    {
      #include "bvh_mesh_meta.hlsli"
      StructuredBuffer<BVHMeta> bvh_meta@buf;
    }
    bvh_per_instance_data@buf = bvh_per_instance_data hlsl
    {
      StructuredBuffer<uint2> bvh_per_instance_data@buf;
    }

    bvhMainValid@u1 = bvh_main_valid;
  }
  // ps5 currently doesn't support shadervar tlas binding
  if (!hardware.ps5)
  {
    (stage) { bvhMain@tlas = bvh_main; }
  }
  else
  {
    hlsl (stage) { DECLARE_BVH_VAR(bvhMain, BVH_MAIN_INDEX); }
    if (thirty_two_waves)
    {
      USE_PS5_WAVE32_MODE()
    }
  }

  hlsl(stage) {
    ##if !hardware.ps5
      BINDLESS_TEX_ARRAY(Texture2D, bvh_textures, 2);
      BINDLESS_TEX_ARRAY(TextureCube, bvh_cube_textures, 3);
      BINDLESS_BUF_ARRAY(ByteAddressBuffer, bvh_geometry, 4);
      BINDLESS_SMP_ARRAY(SamplerState, bvh_samplers, 2);
    ##else
      BINDLESS_NON_UNIFORM_TEX_ARRAY(Texture2D, bvh_textures, 2);
      BINDLESS_NON_UNIFORM_TEX_ARRAY(TextureCube, bvh_cube_textures, 3);
      BINDLESS_BUF_ARRAY(ByteAddressBuffer, bvh_geometry, 4);
      BINDLESS_SMP_ARRAY(SamplerState, bvh_samplers, 2);
    ##endif

    #pragma hlsl2021

    ##if hardware.scarlett
      ##if thirty_two_waves
        #pragma wave32
        #define RT_GROUP_SIZE [numthreads(8, 4, 1)]
        #define XDXR_TRAVERSAL_WAVE_SIZE 32
      ##else
        #pragma wave64
        #define RT_GROUP_SIZE [numthreads(8, 8, 1)]
        #define XDXR_TRAVERSAL_WAVE_SIZE 64
      ##endif
      #define AHSLambda : InlineAHSBaseLambda
      #define GenericRayQuery(flags, lambda) XboxRayQuery<flags, lambda>
      #if coherent_rays
        #include "XDXRStandaloneTraverseHT.hlsli"
      #else
        #include "XDXRStandaloneTraverseLongStack.hlsli"
      #endif
    ##elif hardware.ps5
      ##if thirty_two_waves
        #define RT_GROUP_SIZE [numthreads(8, 4, 1)]
      ##else
        #define RT_GROUP_SIZE [numthreads(8, 8, 1)]
      ##endif
      #define AHSLambda
    ##else
      #define RT_GROUP_SIZE [numthreads(16, 8, 1)]
      #define AHSLambda
      #define GenericRayQuery(flags, lambda) RayQuery<flags>
    ##endif

    // Metal doesn't support CandidateInstanceContributionToHitGroupIndex / CommittedInstanceContributionToHitGroupIndex
    ##if hardware.metal
      #define CANDIDATE_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX (ICTHGI_LOAD_PER_INSTANCE_DATA_WITH_INSTANCE_INDEX)
      #define COMMITTED_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX (ICTHGI_LOAD_PER_INSTANCE_DATA_WITH_INSTANCE_INDEX)
    ##elif !hardware.ps5
      #define CANDIDATE_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX (query.CandidateInstanceContributionToHitGroupIndex())
      #define COMMITTED_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX (query.CommittedInstanceContributionToHitGroupIndex())
    ##endif

    #define AHSArgs float3 ray_origin, float3 ray_direction, float ray_t, uint triangleIx, uint instanceId, uint geometryIndex, uint icthgi, float2 barycentrics2, float3x4 to_world, bool isFrontFace, uint instanceIndex
    #define ForwardAHSParams ray_origin, ray_direction, ray_t, triangleIx, instanceId, geometryIndex, icthgi, barycentrics2, to_world, isFrontFace, instanceIndex
    #define PassAHSParams query.WorldRayOrigin(),                             \
                          query.WorldRayDirection(),                          \
                          query.CandidateTriangleRayT(),                      \
                          query.CandidatePrimitiveIndex(),                    \
                          query.CandidateInstanceID(),                        \
                          query.CandidateGeometryIndex(),                     \
                          CANDIDATE_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX, \
                          query.CandidateTriangleBarycentrics(),              \
                          query.CandidateObjectToWorld3x4(),                  \
                          query.CandidateTriangleFrontFace(),                 \
                          query.CandidateInstanceIndex()
  }
endmacro

macro INIT_BVH(stage, coherent_rays, thirty_two_waves)
  INIT_MAIN_BVH(stage, coherent_rays, thirty_two_waves)
  (stage)
  {
    bvh_particle_data@buf = bvh_particle_data hlsl
    {
      #include "modfx/modfx_bvh.hlsli"
      StructuredBuffer<ModfxBVHParticleData> bvh_particle_data@buf;
    }

    bvhTerrainValid@u1 = bvh_terrain_valid;
    bvhParticlesValid@u1 = bvh_particles_valid;
  }

  if (!hardware.ps5)
  {
    (stage)
    {
      bvhTerrain@tlas = bvh_terrain;
      bvhParticles@tlas = bvh_particles;
    }
  }
  else
  {
    hlsl (stage) {
      DECLARE_BVH_VAR(bvhTerrain, BVH_TERRAIN_INDEX);
      DECLARE_BVH_VAR(bvhParticles, BVH_PARTICLES_INDEX);
    }
  }
endmacro

macro USE_BVH_ATTRIBUTE_FUNCTIONS(stage)
  hlsl(stage)
  {
    static const uint bvhAttributeFloat1 = 0 << 16;
    static const uint bvhAttributeFloat2 = 1 << 16;
    static const uint bvhAttributeFloat3 = 2 << 16;
    static const uint bvhAttributeFloat4 = 3 << 16;

    static const uint bvhAttributeColor = 4 << 16;

    static const uint bvhAttributeShort2   = 6  << 16;
    static const uint bvhAttributeShort4   = 7  << 16;
    static const uint bvhAttributeShort2N  = 9  << 16;
    static const uint bvhAttributeShort4N  = 10 << 16;
    static const uint bvhAttributeUShort2N = 11 << 16;
    static const uint bvhAttributeUShort4N = 12 << 16;

    static const uint bvhAttributeShort2TC = 25 << 16;

    int ShortToIntLow(uint u)
    {
      int result = asuint(u & 0xFFFF);
      if (result & 0x8000)
        result |= 0xFFFF0000;
      return result;
    }

    int ShortToIntHigh(uint u)
    {
      int result = asuint(u >> 16);
      if (result & 0x8000)
        result |= 0xFFFF0000;
      return result;
    }

    void LoadAttribute(ByteAddressBuffer vb, uint attributeBase, uint attributeFormat, out float2 attribute)
    {
      switch (attributeFormat)
      {
        case bvhAttributeFloat2:
          attribute = asfloat(loadBuffer2(vb, attributeBase));
          break;
        case bvhAttributeShort2TC:
          {
            uint packd = loadBuffer(vb, attributeBase); // note: packed is a keyword in PSSL
            attribute.x = ShortToIntLow(packd) / 4096.0;
            attribute.y = ShortToIntHigh(packd) / 4096.0;
            break;
          }
          break;
        case bvhAttributeShort2N:
          {
            uint packd = loadBuffer(vb, attributeBase);
            attribute.x = ShortToIntLow(packd);
            attribute.y = ShortToIntHigh(packd);
            attribute = (attribute - 32767) / 32767.0;
            break;
          }
          break;
        case bvhAttributeUShort2N:
          {
            uint packd = loadBuffer(vb, attributeBase);
            attribute = float2(packd & 0xFFFF, packd >> 16) / 65535.0;
            break;
          }
          break;
       ##if DEBUG
        default:
          ##assert(false, "LoadAttribute (out float2): Bad attribute: %i", attributeFormat);
          break;
       ##endif
      }
    }

    void LoadAttribute(ByteAddressBuffer vb, uint attributeBase, uint attributeFormat, out float3 attribute)
    {
      switch (attributeFormat)
      {
        case bvhAttributeColor:
          {
            const uint4 INPUT_ENCODING_OFFSET = uint4(16, 8, 0, 24);

            uint packd = loadBuffer(vb, attributeBase);
            attribute = ((packd >> INPUT_ENCODING_OFFSET).xyz & 255) / 255.0;
            break;
          }
          break;
        case bvhAttributeFloat3:
          attribute = asfloat(loadBuffer3(vb, attributeBase));
          break;
       ##if DEBUG
        default:
          ##assert(false, "LoadAttribute (out float3): Bad attribute: %i", attributeFormat);
          break;
       ##endif
      }
    }
  }
endmacro

macro USE_MAIN_BVH(stage, need_textures, need_normal, need_color, cull_back_face, handle_translucent, first_hit, terrain_has_normal, gen_face_normal)
  USE_BVH_ATTRIBUTE_FUNCTIONS(stage)
  if (bvh_terrain_has_holes == yes)
  {
    USE_HMAP_HOLES(stage)
  }

  hlsl(stage)
  {
    static const uint bvhMaterialTerrain  = 0;
    static const uint bvhMaterialRendinst = 1;
    static const uint bvhMaterialInterior = 2;
    static const uint bvhMaterialParticle = 3;
    static const uint bvhMaterialCable    = 4;

    static const uint bvhMaterialAlphaTest = 1 << 16;
    static const uint bvhMaterialPainted = 1 << 17;
    static const uint bvhMaterialImpostor = 1 << 18;
    static const uint bvhMaterialAtlas = 1 << 19;
    static const uint bvhInstanceColor = 1 << 20;
    static const uint bvhMaterialCamo = 1 << 21;
    static const uint bvhMaterialLayered = 1 << 22;
    static const uint bvhMaterialGrass = 1 << 23;
    static const uint bvhMaterialEmissive = 1 << 24;
    static const uint bvhMaterialMFD = 1 << 25;
    static const uint bvhMaterialTexcoordAdd = 1 << 26;
    static const uint bvhMaterialPerlinLayered = 1 << 27;
    static const uint bvhMaterialAlphaInRed = 1 << 28;
    static const uint bvhMaterialEye = 1 << 29;

    static const uint bvhMaterialTypeMask = (1 << 16) - 1;

    static const uint bvhGroupTerrain  = 1 << 0;
    static const uint bvhGroupRiGen    = 1 << 1;
    static const uint bvhGroupRiExtra  = 1 << 2;
    static const uint bvhGroupDynrend  = 1 << 3;
    static const uint bvhGroupGrass    = 1 << 4;
    static const uint bvhGroupImpostor = 1 << 5;
    static const uint bvhGroupNoShadow = 1 << 6;

    static const uint bvhGroupAll = 0xff;

    static const uint bvhGroupRender     = bvhGroupAll;
    static const uint bvhGroupSoftShadow = bvhGroupAll & ~bvhGroupTerrain & ~bvhGroupNoShadow;
    static const uint bvhGroupHardShadow = bvhGroupAll & ~bvhGroupTerrain & ~bvhGroupGrass & ~bvhGroupNoShadow;
    static const uint bvhGroupAO         = bvhGroupAll;
    static const uint bvhGroupGI         = bvhGroupAll & ~bvhGroupGrass;
    static const uint bvhGroupProbe      = bvhGroupAll & ~bvhGroupGrass & ~bvhGroupDynrend;

    struct LayerData
    {
      float2 maskGamma;
      float3 maskTile;
      float4 detailTile;
      float  objectScale;
    };

    uint get_material_type(uint material)
    {
      return material & bvhMaterialTypeMask;
    }
    bool has_material_painted(uint material)
    {
      return material & bvhMaterialPainted;
    }
    bool is_impostor(uint material)
    {
      return material & bvhMaterialImpostor;
    }
    bool is_atlas(uint material)
    {
      return material & bvhMaterialAtlas;
    }
    bool is_camo(uint material)
    {
      return material & bvhMaterialCamo;
    }
    bool is_mfd(uint material)
    {
      return material & bvhMaterialMFD;
    }
    bool need_texcoord_add(uint material)
    {
      return material & bvhMaterialTexcoordAdd;
    }
    bool is_layered(uint material)
    {
      return material & bvhMaterialLayered;
    }
    bool is_perlin_layered(uint material)
    {
      return material & bvhMaterialPerlinLayered;
    }
    bool is_eye(uint material)
    {
      return material & bvhMaterialEye;
    }
    bool is_alpha_in_red(uint material)
    {
      return material & bvhMaterialAlphaInRed;
    }
    bool is_grass(uint material)
    {
      return material & bvhMaterialGrass;
    }
    bool is_emissive(uint material)
    {
      return material & bvhMaterialEmissive;
    }
    bool has_second_texcoord(uint material)
    {
      return is_camo(material) || (is_layered(material) && is_atlas(material));
    }
    bool has_instance_color(uint material)
    {
      return material & bvhInstanceColor;
    }
    uint get_vertex_offset(BVHMeta meta)
    {
      return meta.vertexOffset;
    }
    uint get_texcoord_offset(BVHMeta meta)
    {
      return meta.texcoordOffset;
    }
    uint get_sec_texcoord_offset(BVHMeta meta)
    {
      return is_layered(meta.materialType) ? meta.texcoordScale + 0.5f : meta.atlasTileSize;
    }
    uint get_texcoord_format(BVHMeta meta)
    {
      return meta.texcoordFormat;
    }
    uint get_normal_offset(BVHMeta meta)
    {
      return meta.normalOffset;
    }
    uint get_color_offset(BVHMeta meta)
    {
      return meta.colorOffset;
    }
    uint get_vertex_stride(BVHMeta meta)
    {
      return meta.vertexStride;
    }
    uint get_index_buffer_index(BVHMeta meta)
    {
      return meta.indexBufferIndex;
    }
    uint get_vertex_buffer_index(BVHMeta meta)
    {
      return meta.vertexBufferIndexLow | (meta.vertexBufferIndexHigh << 16);
    }
    uint get_ahs_vertex_buffer_index(BVHMeta meta)
    {
      return meta.ahsVertexBufferIndex;
    }
    uint get_index_format(BVHMeta meta)
    {
      // 2 or 4 if the MSB is set
      return meta.indexBit * 2 + 2;
    }
    uint get_texture_index(uint packd, out uint sampler_index)
    {
      sampler_index = packd & 0xFFFF;
      return packd >> 16;
    }
    uint get_albedo_texture_index(BVHMeta meta, out uint sampler_index)
    {
      sampler_index = meta.albedoAndNormalSamplerIndex;
      return meta.albedoTextureIndex;
    }
    uint get_alpha_texture_index(BVHMeta meta, out uint sampler_index)
    {
      sampler_index = meta.alphaSamplerIndex;
      return meta.alphaTextureIndex;
    }
    uint get_normal_texture_index(BVHMeta meta, out uint sampler_index)
    {
      sampler_index = meta.albedoAndNormalSamplerIndex;
      return meta.normalTextureIndex;
    }
    uint get_extra_texture_index(BVHMeta meta, out uint sampler_index)
    {
      sampler_index = meta.extraSamplerIndex;
      return meta.extraTextureIndex;
    }
    float get_texcoord_scale(BVHMeta meta)
    {
      return is_layered(meta.materialType) ? 1 : meta.texcoordScale;
    }
    LayerData get_layer_data(BVHMeta meta, float3x4 to_world)
    {
      float gs = f16tof32(meta.layerData.x);
      float ge = f16tof32(meta.layerData.x >> 16);

      float mu = f16tof32(meta.layerData.y);
      float mv = f16tof32(meta.layerData.y >> 16);

      float3 ay = to_world[1].xyz;
      float3 az = to_world[2].xyz;

      LayerData data;
      data.maskGamma.x = ge - gs - 0.001f;
      data.maskGamma.y = gs + 0.001f;
      data.maskTile.x = abs(mu);
      data.maskTile.y = mv;
      data.maskTile.z = mu;
      data.detailTile.x = f16tof32(meta.layerData.z);
      data.detailTile.y = f16tof32(meta.layerData.z >> 16);
      data.detailTile.z = f16tof32(meta.layerData.w);
      data.detailTile.w = f16tof32(meta.layerData.w >> 16);
      data.objectScale = max(sqrt(0.5 * (dot(ay, ay) + dot(az, az))), 1);
      return data;
    }

    struct HitInfo
    {
      float t;

      float3 centerWorldPos;

      float3 position;
      float2 texcoord;
      float2 secTexcoord;
      half3 normal;
      half3 vertexColor;
      half3 instanceColor;

      uint material;

      half translucency;

      float4 materialData1;
      float4 materialData2;

      uint2 perInstanceDataCompressed;

      uint albedoTextureIndex;
      uint alphaTextureIndex;
      uint normalTextureIndex;
      uint extraTextureIndex;

      uint albedoSamplerIndex;
      uint alphaSamplerIndex;
      uint normalSamplerIndex;
      uint extraSamplerIndex;

      bool isImpostor;
      bool isCamo;
      bool isMFD;
      bool isLayered;
      bool isGrass;
      bool isEmissive;
      bool isPerlinLayered;
      bool isEye;

      uint4 rawLayerData;
      uint rawAtlasTileSize;
      uint rawAtlasFirstLastTile;

      uint perInstanceDataIndex;

      LayerData layerData;
    };

    bool IsAlphaGreaterThan(HitInfo hit_info, float mip_level, float treshold)
    {
      float alpha;

      [branch]
      if (hit_info.alphaTextureIndex == 0xFFFF)
        alpha = bvh_textures[NonUniformResourceIndex(bvh_textures_range_start + hit_info.albedoTextureIndex)].SampleLevel(bvh_samplers[NonUniformResourceIndex(hit_info.albedoSamplerIndex)], hit_info.texcoord, mip_level).a;
      else
        alpha = bvh_textures[NonUniformResourceIndex(bvh_textures_range_start + hit_info.alphaTextureIndex)].SampleLevel(bvh_samplers[NonUniformResourceIndex(hit_info.alphaSamplerIndex)], hit_info.texcoord, mip_level).r;

      return alpha > treshold;
    }

    uint3 LoadIndices(ByteAddressBuffer ib, uint ibBase, uint indexFormat)
    {
      uint3 indices;
      if (indexFormat == 2)
      {
        if ((ibBase & 3) == 0)
        {
          // Aligned for 4-byte
          uint2 packedIndices = loadBuffer2(ib, ibBase);
          indices.x = packedIndices.x & 0xFFFF;
          indices.y = packedIndices.x >> 16;
          indices.z = packedIndices.y & 0xFFFF;
        }
        else
        {
          // Aligned for 2-byte
          uint2 packedIndices = loadBuffer2(ib, ibBase - 2);
          indices.x = packedIndices.x >> 16;
          indices.y = packedIndices.y & 0xFFFF;
          indices.z = packedIndices.y >> 16;
        }
      }
      else
      {
        indices = loadBuffer3(ib, ibBase);
      }
      return indices;
    }

    // This function is tailored for collision geometry. Everything else should have its own normal precalculated.
    float3 calc_face_normal(ByteAddressBuffer vb, uint stride, uint vb_base, uint3 indices)
    {
      float3 positions[ 3 ];

      uint2 packd;
      packd = loadBuffer2(vb, vb_base + indices.x * stride);
      positions[ 0 ] = float3(f16tof32(packd.x), f16tof32(packd.x >> 16), f16tof32(packd.y));
      packd = loadBuffer2(vb, vb_base + indices.y * stride);
      positions[ 1 ] = float3(f16tof32(packd.x), f16tof32(packd.x >> 16), f16tof32(packd.y));
      packd = loadBuffer2(vb, vb_base + indices.z * stride);
      positions[ 2 ] = float3(f16tof32(packd.x), f16tof32(packd.x >> 16), f16tof32(packd.y));

      float3 e1 = positions[ 1 ] - positions[ 0 ];
      float3 e2 = positions[ 2 ] - positions[ 0 ];
      return normalize(cross(e1, e2));
    }

    float get_cone_angle_from_smoothness(float smoothness)
    {
      float tanConeAngle = 1.0 - smoothness * smoothness * bvh_smoothness_coef;
      return max(saturate(tanConeAngle), bvh_tan_pixel_angular_radius);
    }

    float calc_mip_level(float d, bool is_impostor, bool for_atest = false)
    {
      float bias = bvh_mip_bias + (is_impostor ? bvh_additional_impostor_mip_bias : 0); // Since impostors are meant to be viewed from a distance
      return bias + saturate(sqrt(d / bvh_mip_range)) * bvh_mip_scale * (for_atest ? 0.5 : 1);
    }

    bool need_clip_impostor(float2 clipping_info)
    {
      return abs(clipping_info.x) > abs(clipping_info.y);
    }

    float2 unpack_ahs_tc(uint packd)
    {
      return float2(f16tof32(packd), f16tof32(packd >> 16));
    }

    void decode_instance_id(uint instance_id, out float translucency, out uint meta_region_index)
    {
      // The instance ID is 24 bits.
      // The most significant bit tells if the instance has translucency.
      // If it has, the next 8 bits are the translucency value
      bool hasTranslucency = instance_id >> 23;
      uint translucencyI = hasTranslucency ? ((instance_id >> 15) & 0xFF) : 0;
      translucency = translucencyI / 255.0;

      meta_region_index = hasTranslucency ? (instance_id & 0x7FFF) : instance_id;
    }

    typedef uint AHSResult;
    static const AHSResult AHS_Hit    = 0;
    static const AHSResult AHS_Miss   = 1;
    static const AHSResult AHS_NoData = 2;

    AHSResult hmap_holes_ahs(float3 ray_origin, float3 ray_direction, float primary_t, float ray_t, uint instanceId)
    {
      ##if bvh_terrain_has_holes == yes && heightmap_holes_support_assume == on
        ##assert(instanceId < bvh_meta_count, "hmap hole meta %d but max is %d", instanceId, bvh_meta_count);
        BVHMeta meta = structuredBufferAt(bvh_meta, instanceId);
        if (get_material_type(meta.materialType) != bvhMaterialTerrain)
          return AHS_NoData;
        float3 worldPos = bvh_origin + ray_origin + ray_direction * ray_t;
        bool hole = false;
        hole = hole || checkHeightmapHoles(worldPos + float3(+hmap_holes_sampling_step_dist, 0, +hmap_holes_sampling_step_dist), 0);
        hole = hole || checkHeightmapHoles(worldPos + float3(+hmap_holes_sampling_step_dist, 0, -hmap_holes_sampling_step_dist), 0);
        hole = hole || checkHeightmapHoles(worldPos + float3(-hmap_holes_sampling_step_dist, 0, +hmap_holes_sampling_step_dist), 0);
        hole = hole || checkHeightmapHoles(worldPos + float3(-hmap_holes_sampling_step_dist, 0, -hmap_holes_sampling_step_dist), 0);
        if (hole)
          return AHS_Miss;
        return AHS_Hit;
      ##else
        return AHS_NoData;
      ##endif
    }

    AHSResult alpha_test_ahs(float3 ray_origin, float3 ray_direction, float primary_t, float ray_t, uint triangleIx, uint instanceId, uint geometryIndex, float2 barycentrics2, uint instanceIndex, float alpha_treshold)
    {
      static const uint ahsVertexStride = 4;

      float translucency;
      uint metaRegionIndex;
      decode_instance_id(instanceId, translucency, metaRegionIndex);
      bool isImpostor = instanceIndex >= bvh_impostor_begin_end.x && instanceIndex < bvh_impostor_begin_end.y;
      uint bhvMetaIndex = metaRegionIndex + (isImpostor ? 0 : geometryIndex);

      #if BVH_SUPPORT_DISSOLVE
        [branch]
        if (translucency > 0)
        {
          float3 hitPosition = ray_origin + ray_direction * ray_t;
          float dissolveAlpha = get_dissolve_value_from_world_position(hitPosition + bvh_origin);

          [branch]
          if (translucency > dissolveAlpha)
            return AHS_Miss;
        }
      #endif

      ##assert(bhvMetaIndex < bvh_meta_count, "alpha_test_ahs meta %d but max is %d", bhvMetaIndex, bvh_meta_count);
      BVHMeta meta = structuredBufferAt(bvh_meta, bhvMetaIndex);

      uint vbSlotIndex = get_ahs_vertex_buffer_index(meta);
      [branch]
      if (vbSlotIndex == BVH_BINDLESS_BUFFER_MAX)
        return AHS_NoData;

      ByteAddressBuffer vb = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + vbSlotIndex)];

      uint3 indices;
      indices.x = triangleIx * 3 + 0;
      indices.y = triangleIx * 3 + 1;
      indices.z = triangleIx * 3 + 2;

      uint vertexCount = meta.indexCount;
      ##assert(indices.x < vertexCount, "Can't load vertex %i, max is %i, triangle %i, meta %i, t is %.f", indices.x, vertexCount, triangleIx, bhvMetaIndex, ray_t);
      ##assert(indices.y < vertexCount, "Can't load vertex %i, max is %i, triangle %i, meta %i, t is %.f", indices.y, vertexCount, triangleIx, bhvMetaIndex, ray_t);
      ##assert(indices.z < vertexCount, "Can't load vertex %i, max is %i, triangle %i, meta %i, t is %.f", indices.z, vertexCount, triangleIx, bhvMetaIndex, ray_t);

      float2 tc1 = unpack_ahs_tc(loadBuffer(vb, indices.x * ahsVertexStride));
      float2 tc2 = unpack_ahs_tc(loadBuffer(vb, indices.y * ahsVertexStride));
      float2 tc3 = unpack_ahs_tc(loadBuffer(vb, indices.z * ahsVertexStride));

      float3 barycentrics = float3(1.0 - barycentrics2.x - barycentrics2.y, barycentrics2.x, barycentrics2.y);

      float2 tc = tc1 * barycentrics.x + tc2 * barycentrics.y + tc3 * barycentrics.z;

      if (need_texcoord_add(meta.materialType))
        tc += f16tof32(meta.texcoordAdd.xx >> uint2(0, 16));

      [branch]
      if (is_impostor(meta.materialType))
      {
        [branch]
        if (any(or(tc < 0, tc > 1)))
          return AHS_Miss;

        uint vertexCount = meta.indexCount;

        float2 sd1 = unpack_ahs_tc(loadBuffer(vb, (indices.x + vertexCount) * ahsVertexStride));
        float2 sd2 = unpack_ahs_tc(loadBuffer(vb, (indices.y + vertexCount) * ahsVertexStride));
        float2 sd3 = unpack_ahs_tc(loadBuffer(vb, (indices.z + vertexCount) * ahsVertexStride));

        float2 sliceData = sd1 * barycentrics.x + sd2 * barycentrics.y + sd3 * barycentrics.z;

        [branch]
        if (need_clip_impostor(sliceData))
          return AHS_Miss;
      }

      uint alphaSamplerIndex;
      uint alphaTextureIndex = get_alpha_texture_index(meta, alphaSamplerIndex);

      float mipLevel = calc_mip_level(primary_t + ray_t, is_impostor(meta.materialType), true);
      float4 smp = bvh_textures[NonUniformResourceIndex(bvh_textures_range_start + alphaTextureIndex)].SampleLevel(bvh_samplers[NonUniformResourceIndex(alphaSamplerIndex)], tc, mipLevel);
      float alpha = is_alpha_in_red(meta.materialType) ? smp.r : smp.a;

      return alpha > alpha_treshold ? AHS_Hit : AHS_Miss;
    }

    HitInfo CalcHitInfo(float3 ray_origin, float3 ray_direction, float ray_t, uint triangleIx, uint instanceId, uint geometryIndex, uint icthgi, float2 barycentrics2, float3x4 to_world, bool isFrontFace, uint instanceIndex, half3 defaultColor)
    {
      HitInfo hitInfo = (HitInfo)0;

      hitInfo.t = ray_t;
      hitInfo.position = ray_origin + ray_direction * ray_t;

      hitInfo.centerWorldPos = to_world._14_24_34 + bvh_origin;

      float translucency;
      uint metaRegionIndex;
      decode_instance_id(instanceId, translucency, metaRegionIndex);

      uint icthgiFlags = icthgi & ICTHGI_MASK;
      uint icthgiData = (icthgi >> 3) & 0x001FFFFFu;
      bool hasPerInstanceData = icthgiFlags == ICTHGI_LOAD_PER_INSTANCE_DATA_WITH_INSTANCE_INDEX || icthgiFlags == ICTHGI_LOAD_PER_INSTANCE_DATA_WITH_ICTHGI_INDEX;
      uint instanceDataIndex = icthgiFlags == ICTHGI_LOAD_PER_INSTANCE_DATA_WITH_ICTHGI_INDEX ? icthgiData : instanceIndex;

      bool isImpostor = instanceIndex >= bvh_impostor_begin_end.x && instanceIndex < bvh_impostor_begin_end.y;
      uint bhvMetaIndex = metaRegionIndex + (isImpostor ? 0 : geometryIndex);
      BVHMeta meta = structuredBufferAt(bvh_meta, bhvMetaIndex);
      hitInfo.material = meta.materialType;
      hitInfo.albedoTextureIndex = get_albedo_texture_index(meta, hitInfo.albedoSamplerIndex);
      hitInfo.alphaTextureIndex = get_alpha_texture_index(meta, hitInfo.alphaSamplerIndex);
      hitInfo.normalTextureIndex = get_normal_texture_index(meta, hitInfo.normalSamplerIndex);
      hitInfo.extraTextureIndex = get_extra_texture_index(meta, hitInfo.extraSamplerIndex);
      hitInfo.translucency = half(translucency);
      hitInfo.materialData1 = meta.materialData1;
      hitInfo.materialData2 = meta.materialData2;
      hitInfo.isImpostor = is_impostor(meta.materialType);
      hitInfo.isCamo = is_camo(meta.materialType);
      hitInfo.isMFD = is_mfd(meta.materialType);
      hitInfo.isLayered = is_layered(meta.materialType);
      hitInfo.isGrass = is_grass(meta.materialType);
      hitInfo.isEmissive = is_emissive(meta.materialType);
      hitInfo.isPerlinLayered = is_perlin_layered(meta.materialType);
      hitInfo.isEye = is_eye(meta.materialType);
      hitInfo.perInstanceDataCompressed = hasPerInstanceData ? structuredBufferAt(bvh_per_instance_data, instanceDataIndex) : (icthgiFlags == ICTHGI_USE_AS_HASH_VALUE ? uint2(icthgiData, 0) : 0);
      hitInfo.rawLayerData = meta.layerData;
      hitInfo.rawAtlasTileSize = meta.atlasTileSize;
      hitInfo.rawAtlasFirstLastTile = meta.atlasFirstLastTile;
      hitInfo.vertexColor = defaultColor;
      hitInfo.instanceColor = 1;

      if (hitInfo.isLayered)
        hitInfo.layerData = get_layer_data(meta, to_world);

      if (icthgiFlags == ICTHGI_REPLACE_ALBEDO_TEXTURE)
        hitInfo.albedoTextureIndex = icthgiData;
      else if (hitInfo.perInstanceDataCompressed.x == 0xA1B3D0U)
        hitInfo.albedoTextureIndex = get_texture_index(asuint(hitInfo.perInstanceDataCompressed.y), hitInfo.albedoSamplerIndex);

      if (get_material_type(meta.materialType) == bvhMaterialTerrain)
      {
        hitInfo.texcoord = 0;

        #if terrain_has_normal
          float3 normals[3];

          uint ibSlotIndex = get_index_buffer_index(meta);
          uint vbSlotIndex = get_vertex_buffer_index(meta);

          ByteAddressBuffer vb = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + vbSlotIndex)];
          ByteAddressBuffer ib = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + ibSlotIndex)];

          uint vertexStride = 16; // float3 + uint

          uint ibBase = triangleIx * 6;
          uint3 indices = LoadIndices(ib, ibBase, 2);

          uint vbBase = 12; // float3

          LoadAttribute(vb, vbBase + indices.x * vertexStride, bvhAttributeColor, normals[0]);
          LoadAttribute(vb, vbBase + indices.y * vertexStride, bvhAttributeColor, normals[1]);
          LoadAttribute(vb, vbBase + indices.z * vertexStride, bvhAttributeColor, normals[2]);

          half3 barycentrics = half3( 1.0 - barycentrics2.x - barycentrics2.y, barycentrics2.x, barycentrics2.y );

          hitInfo.normal = half3( normals[0] * barycentrics.x
                                + normals[1] * barycentrics.y
                                + normals[2] * barycentrics.z );
          hitInfo.normal = normalize(hitInfo.normal * 2 - 1);
          hitInfo.normal = isFrontFace ? hitInfo.normal : -hitInfo.normal;
        #endif
      }
      else
      {
        uint ibSlotIndex = get_index_buffer_index(meta);
        uint vbSlotIndex = get_vertex_buffer_index(meta);

        ByteAddressBuffer vb = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + vbSlotIndex)];

        uint vertexStride = get_vertex_stride(meta);

        uint3 indices;

        /* This branch is removed for performance reasons. If it is really needed, lets discuss it.
        if (ibSlotIndex == 0xFFFF)
        {
          indices.x = triangleIx * 3 + 0;
          indices.y = triangleIx * 3 + 1;
          indices.z = triangleIx * 3 + 2;
        }
        else*/
        {
          ByteAddressBuffer ib = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + ibSlotIndex)];
          uint indexFormat = get_index_format(meta);
          uint ibBase = (meta.startIndex + triangleIx * 3) * indexFormat;

          indices = LoadIndices(ib, ibBase, indexFormat);
        }

        float3 barycentrics = float3( 1.0 - barycentrics2.x - barycentrics2.y, barycentrics2.x, barycentrics2.y );

        #if need_textures
          if (get_texcoord_offset(meta) != 255)
          {
            float2 texcoords[3];
            uint texcoordFormat = get_texcoord_format(meta);
            uint vbBase = get_vertex_offset(meta) + meta.startVertex * vertexStride + get_texcoord_offset(meta);
            LoadAttribute(vb, vbBase + indices.x * vertexStride, texcoordFormat, texcoords[0]);
            LoadAttribute(vb, vbBase + indices.y * vertexStride, texcoordFormat, texcoords[1]);
            LoadAttribute(vb, vbBase + indices.z * vertexStride, texcoordFormat, texcoords[2]);

            hitInfo.texcoord = texcoords[ 0 ] * barycentrics.x
                             + texcoords[ 1 ] * barycentrics.y
                             + texcoords[ 2 ] * barycentrics.z;
            hitInfo.texcoord *= get_texcoord_scale(meta);

            if (need_texcoord_add(meta.materialType))
              hitInfo.texcoord += f16tof32(meta.texcoordAdd.xx >> uint2(0, 16));

            if (is_atlas(meta.materialType))
            {
              float4 atlasParams = float4(f16tof32(meta.atlasTileSize), f16tof32(meta.atlasTileSize >> 16), meta.atlasFirstLastTile & 0xFFFFU, meta.atlasFirstLastTile >> 16);
              float2 uv_inside_tile = frac(hitInfo.texcoord / atlasParams.xy) * atlasParams.xy;
              float obj_unique_index = floor(dot(hitInfo.centerWorldPos.xz, hitInfo.centerWorldPos.xz));
              float tile_i = atlasParams.z + fmod(obj_unique_index, atlasParams.w);
              float row_i = floor(tile_i * atlasParams.x);
              float coll_i = tile_i - row_i / atlasParams.x;
              float2 tile_ij = float2(coll_i, row_i) * atlasParams.xy;
              hitInfo.texcoord = tile_ij + uv_inside_tile;
            }

            if (has_second_texcoord(meta.materialType))
            {
              ##assert(get_sec_texcoord_offset(meta) < 255, "CalcHitInfo: second texcoord offset is invalid.");
              uint vbBase = get_vertex_offset(meta) + meta.startVertex * vertexStride + get_sec_texcoord_offset(meta);
              LoadAttribute(vb, vbBase + indices.x * vertexStride, texcoordFormat, texcoords[0]);
              LoadAttribute(vb, vbBase + indices.y * vertexStride, texcoordFormat, texcoords[1]);
              LoadAttribute(vb, vbBase + indices.z * vertexStride, texcoordFormat, texcoords[2]);

              hitInfo.secTexcoord = texcoords[ 0 ] * barycentrics.x
                                  + texcoords[ 1 ] * barycentrics.y
                                  + texcoords[ 2 ] * barycentrics.z;
              hitInfo.secTexcoord *= get_texcoord_scale(meta);
            }
            else
              hitInfo.secTexcoord = 0;
          }
          else
          {
            hitInfo.texcoord = 0;
            hitInfo.secTexcoord = 0;
          }
        #endif

        #if need_normal
          if (get_normal_offset(meta) == 255)
          {
            #if gen_face_normal
              uint vbBase = get_vertex_offset(meta) + meta.startVertex * vertexStride;
              float3 normal = calc_face_normal(vb, vertexStride, vbBase, indices);
              hitInfo.normal = (half3)normalize(mul((float3x3) to_world, normal));
              hitInfo.normal = isFrontFace ? hitInfo.normal : -hitInfo.normal;
            #else
              hitInfo.normal = half3(0, 1, 0);
            #endif
          }
          else
          {
            float3 normals[3];
            uint vbBase = get_vertex_offset(meta) + meta.startVertex * vertexStride + get_normal_offset(meta);
            LoadAttribute(vb, vbBase + indices.x * vertexStride, bvhAttributeColor, normals[0]);
            LoadAttribute(vb, vbBase + indices.y * vertexStride, bvhAttributeColor, normals[1]);
            LoadAttribute(vb, vbBase + indices.z * vertexStride, bvhAttributeColor, normals[2]);

            float3 normal = normals[ 0 ] * barycentrics.x
                          + normals[ 1 ] * barycentrics.y
                          + normals[ 2 ] * barycentrics.z;
            hitInfo.normal = (half3)normalize(mul((float3x3)to_world, normal * 2 - 1));
            if (hitInfo.isImpostor)
              hitInfo.normal.xz = isFrontFace ? hitInfo.normal.xz : -hitInfo.normal.xz;
            else
              hitInfo.normal = isFrontFace ? hitInfo.normal : -hitInfo.normal;
          }
        #endif

        if ((need_color || get_material_type(hitInfo.material) == bvhMaterialCable) && get_color_offset(meta) != 255)
        {
          float3 colors[3];
          uint vbBase = get_vertex_offset(meta) + meta.startVertex * vertexStride + get_color_offset(meta);
          uint colorFormat = hitInfo.isImpostor ? bvhAttributeFloat3 : bvhAttributeColor;
          LoadAttribute(vb, vbBase + indices.x * vertexStride, colorFormat, colors[0]);
          LoadAttribute(vb, vbBase + indices.y * vertexStride, colorFormat, colors[1]);
          LoadAttribute(vb, vbBase + indices.z * vertexStride, colorFormat, colors[2]);

          hitInfo.vertexColor = half3( colors[ 0 ] * barycentrics.x
                                     + colors[ 1 ] * barycentrics.y
                                     + colors[ 2 ] * barycentrics.z );

        }

        if (icthgiFlags == ICTHGI_USE_AS_777_ISTANCE_COLOR)
        {
          hitInfo.instanceColor = half3((icthgiData.rrr >> uint3(0, 7, 14)).zyx & 127) / 127.0h;
          hitInfo.instanceColor = pow(hitInfo.instanceColor * 4, 2.2);
        }
        ##if hardware.metal
        else if (has_instance_color(hitInfo.material))
        {
          hitInfo.instanceColor = half3((hitInfo.perInstanceDataCompressed.rrr >> uint3(0, 8, 16)).zyx & 255) / 255.0h; // E3DCOLOR
          hitInfo.instanceColor = pow(hitInfo.instanceColor * 4, 2.2);
        }
        ##endif
      }

      return hitInfo;
    }

##if !hardware.ps5
    struct IsObstructedAHSLambda AHSLambda
    {
      float primaryT;
      half3 defaultColor;
      int callCounter;

      bool InlineAHSImpl(AHSArgs)
      {
        callCounter++;
        if (callCounter >= bvh_max_ahs_calls)
          return true; // Giving up finding the correct hit

        AHSResult hmapResult = hmap_holes_ahs(ray_origin, ray_direction, primaryT, ray_t, instanceId);
        if (hmapResult != AHS_NoData)
          return hmapResult == AHS_Hit;
        #if handle_translucent
          AHSResult ahsResult = alpha_test_ahs(ray_origin, ray_direction, primaryT, ray_t, triangleIx, instanceId, geometryIndex, barycentrics2, instanceIndex, 0.5);
          return ahsResult == AHS_Hit;
        #endif
        return false;
      }

      ##if hardware.scarlett
        void InlineAHS(inout XboxRayQueryProxy query)
        {
          if (InlineAHSImpl(PassAHSParams))
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif
    };

    bool is_obstructed(RaytracingAccelerationStructure bvh, float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT, uint group_mask, half3 defaultColor = 1, uint extra_flags = 0)
    {
      const uint flags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_CULL_BACK_FACING_TRIANGLES | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES;

      GenericRayQuery(flags, IsObstructedAHSLambda) query;

      RayDesc ray;
      ray.Origin    = ray_origin;
      ray.Direction = ray_direction;
      ray.TMin      = ray_min;
      ray.TMax      = ray_max;

      query.TraceRayInline(bvh, flags | extra_flags, group_mask, ray);

      IsObstructedAHSLambda lambda;
      lambda.primaryT = primaryT;
      lambda.defaultColor = defaultColor;
      lambda.callCounter = 0;

      ##if hardware.scarlett
        query.Proceed(lambda);
      ##else
        while (query.Proceed())
        {
          // Can only be CANDIDATE_NON_OPAQUE_TRIANGLE
          if (lambda.InlineAHSImpl(PassAHSParams))
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif

      return query.CommittedStatus() == COMMITTED_TRIANGLE_HIT;
    }
##else // hardware.ps5
    HitInfo CalcHitInfoPS(float3 ray_origin, float3 ray_dir, sce::Psr::Hit hit, half3 default_color)
    {
      float m[12] = hit.m_instance->m_objectToWorld3x4; // row-major

      float3x4 objToWorld = {
        m[0], m[1], m[2], m[3],
        m[4], m[5], m[6], m[7],
        m[8], m[9], m[10],m[11]
      };

      return CalcHitInfo(ray_origin, // no info in psHit
        ray_dir,
        hit.m_depth,
        hit.m_primitiveIndex,
        hit.m_instanceID,
        hit.m_geometryIndex,
        hit.m_shaderTableContribution,
        float2(hit.m_u, hit.m_v),
        objToWorld,
        hit.m_hitKind == sce::Psr::HitKind::kTriangleFrontFace,
        hit.m_instanceIndex,
        default_color);
    }

    bool is_obstructed(RaytracingAccelerationStructure bvh,
        float3 ray_origin,
        float3 ray_direction,
        float ray_min,
        float ray_max,
        float primaryT,
        uint group_mask,
        half3 default_color = 1,
        uint extra_flags = 0)
    {
      constexpr auto optimizedFlags = DEFAULT_TRAVERSAL_FLAFS;

      sce::Psr::Ray const ray = {
        .m_org = ray_origin,
        .m_tmin = ray_min,
        .m_dir = ray_direction,
        .m_tmax = ray_max
      };

      sce::Psr::RayFlags rayFlags = sce::Psr::RayFlags::kCullBackFacingTriangles;

      auto const noIntersection = sce::Psr::NoIntersection{};
      auto const noAABBInstance = sce::Psr::NoAABBInstance {bvh.m_bvh};

      int callCounter = 0;

      auto lambda = [&](float3 object_space_org, float3 object_space_dir, sce::Psr::Hit hit)
      {
        callCounter++;
        if (callCounter >= bvh_max_ahs_calls)
          return true; // Giving up finding the correct hit

        AHSResult hmapResult = hmap_holes_ahs(ray_origin, ray_direction, primaryT, hit.m_depth, hit.m_instanceID);
        if (hmapResult != AHS_NoData)
          return hmapResult == AHS_Hit;
      #if handle_translucent
        AHSResult ahsResult = alpha_test_ahs(ray_origin, ray_direction, primaryT,
          hit.m_depth, hit.m_primitiveIndex, hit.m_instanceID, hit.m_geometryIndex, float2(hit.m_u, hit.m_v), hit.m_instanceIndex, 0.5);
        return ahsResult == AHS_Hit;
      #endif
        return false;
      };

      auto psHit = sce::Psr::Closest<optimizedFlags>(bvh.m_bvh, rayFlags,
        group_mask, ray, lambda, noIntersection, noAABBInstance);
      return psHit.isHit();
    }
##endif

##if !hardware.ps5
    struct TraceRayAHSLambda AHSLambda
    {
      float primaryT;
      half3 rayColor;
      half3 defaultColor;
      float translucentT;
      int callCounter;

      bool InlineAHSImpl(AHSArgs)
      {
        callCounter++;
        if (callCounter >= bvh_max_ahs_calls)
          return true; // Giving up finding the correct hit

        AHSResult hmapResult = hmap_holes_ahs(ray_origin, ray_direction, primaryT, ray_t, instanceId);
        if (hmapResult != AHS_NoData)
          return hmapResult == AHS_Hit;
        #if handle_translucent
          AHSResult ahsResult = alpha_test_ahs(ray_origin, ray_direction, primaryT, ray_t, triangleIx, instanceId, geometryIndex, barycentrics2, instanceIndex, 0.5);
          return ahsResult == AHS_Hit;
        #endif
        return false;
      }

      ##if hardware.scarlett
        void InlineAHS(inout XboxRayQueryProxy query)
        {
          if (InlineAHSImpl(PassAHSParams))
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif
    };

    bool trace_ray(RaytracingAccelerationStructure bvh, float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT, uint group_mask, out HitInfo hit_info, out half3 ray_color, out float translucent_t, half3 defaultColor = 1, uint extra_flags = 0)
    {
      hit_info = (HitInfo)0;

      const uint flags = RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES
                       | (handle_translucent ? RAY_FLAG_NONE : RAY_FLAG_FORCE_OPAQUE)
                       | (first_hit ? RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH : RAY_FLAG_NONE)
                       | (cull_back_face ? RAY_FLAG_CULL_BACK_FACING_TRIANGLES : RAY_FLAG_NONE)
                       #ifdef TRACE_RAY_EXTRA_FLAGS
                         | TRACE_RAY_EXTRA_FLAGS
                       #endif
                       ;

      GenericRayQuery(flags, TraceRayAHSLambda) query;

      RayDesc ray;
      ray.Origin    = ray_origin;
      ray.Direction = ray_direction;
      ray.TMin      = ray_min;
      ray.TMax      = ray_max;

      translucent_t = 0;
      ray_color = 1;

      query.TraceRayInline(bvh, flags | extra_flags, group_mask, ray);

      TraceRayAHSLambda lambda;
      lambda.primaryT = primaryT;
      lambda.rayColor = ray_color;
      lambda.translucentT = translucent_t;
      lambda.defaultColor = defaultColor;
      lambda.callCounter = 0;
      ##if hardware.scarlett
        query.Proceed(lambda);
      ##else
        while (query.Proceed())
        {
          // Can only be CANDIDATE_NON_OPAQUE_TRIANGLE
          if (lambda.InlineAHSImpl(PassAHSParams))
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif

      ray_color = lambda.rayColor;
      translucent_t = lambda.translucentT;

      if (query.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
      {
        hit_info = CalcHitInfo(query.WorldRayOrigin(),
                               query.WorldRayDirection(),
                               query.CommittedRayT(),
                               query.CommittedPrimitiveIndex(),
                               query.CommittedInstanceID(),
                               query.CommittedGeometryIndex(),
                               COMMITTED_INSTANCE_CONTRIBUTION_TO_HIT_GROUP_INDEX,
                               query.CommittedTriangleBarycentrics(),
                               query.CommittedObjectToWorld3x4(),
                               query.CommittedTriangleFrontFace(),
                               query.CommittedInstanceIndex(),
                               defaultColor);
        ray_color = 0;
        return true;
      }

      hit_info.t = INF;
      return false;
    }
##else // hardware.ps5
    bool trace_ray(RaytracingAccelerationStructure bvh, float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT,
      uint group_mask, out HitInfo hit_info, out half3 ray_color, out float translucent_t, half3 default_color = 1, uint extra_flags = 0)
    {
      hit_info = HitInfo();

      constexpr auto optimizedFlags = DEFAULT_TRAVERSAL_FLAFS;

      sce::Psr::Ray const ray = {
        .m_org = ray_origin,
        .m_tmin = ray_min,
        .m_dir = ray_direction,
        .m_tmax = ray_max
      };

      translucent_t = 0;
      ray_color = 1;

      sce::Psr::RayFlags rayFlags =
        (handle_translucent ? sce::Psr::RayFlags::kNone : sce::Psr::RayFlags::kForceOpaque) |
        (first_hit ? sce::Psr::RayFlags::kAcceptFirstHitAndEndSearch : sce::Psr::RayFlags::kNone) |
        (cull_back_face? sce::Psr::RayFlags::kCullBackFacingTriangles  : sce::Psr::RayFlags::kNone);

      sce::Psr::RayFlags psExtraFlags = remap_DX12_ray_flags(extra_flags);
      rayFlags = rayFlags | psExtraFlags;

    #ifdef TRACE_RAY_EXTRA_FLAGS
      rayFlags |= remap_DX12_ray_flags(TRACE_RAY_EXTRA_FLAGS);
    #endif

      auto const noIntersection = sce::Psr::NoIntersection{};
      auto const noAABBInstance = sce::Psr::NoAABBInstance {bvh.m_bvh};

      int callCounter = 0;

      auto inlineLambda = [&](float3 object_space_org, float3 object_space_dir, sce::Psr::Hit hit)
      {
        callCounter++;
        if (callCounter >= bvh_max_ahs_calls)
          return true; // Giving up finding the correct hit

        AHSResult hmapResult = hmap_holes_ahs(ray_origin, ray_direction, primaryT, hit.m_depth, hit.m_instanceID);
        if (hmapResult != AHS_NoData)
          return hmapResult == AHS_Hit;
      #if handle_translucent
        AHSResult ahsResult = alpha_test_ahs(ray_origin, ray_direction, primaryT,
            hit.m_depth, hit.m_primitiveIndex, hit.m_instanceID, hit.m_geometryIndex, float2(hit.m_u, hit.m_v), hit.m_instanceIndex, 0.5);
        return ahsResult == AHS_Hit;
      #endif
        return false;
      };

    sce::Psr::Hit psHit;
    #if handle_translucent
      if (rayFlags & sce::Psr::RayFlags::kAcceptFirstHitAndEndSearch)
        psHit = sce::Psr::Occluded<optimizedFlags>(bvh.m_bvh, rayFlags, group_mask, ray, inlineLambda, noIntersection, noAABBInstance);
      else
        psHit = sce::Psr::Closest<optimizedFlags>(bvh.m_bvh, rayFlags, group_mask, ray, inlineLambda, noIntersection, noAABBInstance);
    #else
      if (rayFlags & sce::Psr::RayFlags::kAcceptFirstHitAndEndSearch)
        psHit = sce::Psr::Occluded<optimizedFlags>(bvh.m_bvh, rayFlags, group_mask, ray);
      else
        psHit = sce::Psr::Closest<optimizedFlags>(bvh.m_bvh, rayFlags, group_mask, ray);
    #endif

      if (psHit.isHit())
      {
        hit_info  = CalcHitInfoPS(ray_origin, ray_direction, psHit, default_color);
        ray_color = 0;
        return true;
      }

      hit_info.t = INF;
      return false;
    }
##endif

    bool trace_ray(RaytracingAccelerationStructure bvh, float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT, uint group_mask, out HitInfo hit_info, half3 defaultColor = 1, uint extra_flags = 0)
    {
      half3 rayColor;
      float translucentT;
      return trace_ray(bvh, ray_origin, ray_direction, ray_min, ray_max, primaryT, group_mask, hit_info, rayColor, translucentT, defaultColor, extra_flags);
    }
  }
endmacro

macro USE_PARTICLE_BVH(stage)
  hlsl(stage)
  {
    HitInfo CalcParticleHitInfo( float3 ray_origin, float3 ray_direction, float ray_t, uint triangleIx, uint instanceId, uint geometryIndex, int icthgi, float2 barycentrics2, float3x4 to_world, bool isFrontFace, uint instanceIndex )
    {
      HitInfo hitInfo = (HitInfo)0;

      hitInfo.t = ray_t;
      hitInfo.position = ray_origin + ray_direction * ray_t;

      hitInfo.centerWorldPos = to_world._14_24_34 + bvh_origin;

      BVHMeta meta = structuredBufferAt(bvh_meta, instanceId);
      hitInfo.material = meta.materialType;
      hitInfo.albedoTextureIndex = get_albedo_texture_index(meta, hitInfo.albedoSamplerIndex);

      // For particles, the instance index is the particle data index
      hitInfo.perInstanceDataIndex = instanceIndex;
      ModfxBVHParticleData pd = structuredBufferAt(bvh_particle_data, instanceIndex);

      hitInfo.instanceColor = half3(pd.color.xyz);
      hitInfo.translucency = half(1 - pd.color.w);

      uint ibSlotIndex = get_index_buffer_index(meta);
      uint vbSlotIndex = get_vertex_buffer_index(meta);

      ByteAddressBuffer vb = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + vbSlotIndex)];
      ByteAddressBuffer ib = bvh_geometry[NonUniformResourceIndex(bvh_buffers_range_start + ibSlotIndex)];

      uint indexFormat = get_index_format(meta);
      uint ibBase = (meta.startIndex + triangleIx * 3) * indexFormat;

      uint3 indices = LoadIndices(ib, ibBase, indexFormat);

      float3 barycentrics = float3( 1.0 - barycentrics2.x - barycentrics2.y, barycentrics2.x, barycentrics2.y );

      uint vertexStride = get_vertex_stride(meta);

      ##assert(get_texcoord_offset(meta) < 255, "CalcParticleHitInfo: texcoord offset is invalid.");
      float2 texcoords[3];
      uint texcoordFormat = get_texcoord_format(meta);
      uint vbBase = meta.startVertex * vertexStride + get_texcoord_offset(meta);
      LoadAttribute(vb, vbBase + indices.x * vertexStride, texcoordFormat, texcoords[0]);
      LoadAttribute(vb, vbBase + indices.y * vertexStride, texcoordFormat, texcoords[1]);
      LoadAttribute(vb, vbBase + indices.z * vertexStride, texcoordFormat, texcoords[2]);

      hitInfo.texcoord = texcoords[ 0 ] * barycentrics.x
                       + texcoords[ 1 ] * barycentrics.y
                       + texcoords[ 2 ] * barycentrics.z;

      hitInfo.materialData1.zw = hitInfo.texcoord;
      hitInfo.materialData1.w  = 1 - hitInfo.materialData1.w;


      // The second frame UV for frame blend
      float2 t = lerp(pd.texcoord3.zw, pd.texcoord2.zw, hitInfo.texcoord.x);
      float2 b = lerp(pd.texcoord0.zw, pd.texcoord1.zw, hitInfo.texcoord.x);
      hitInfo.materialData1.xy = lerp(t, b, hitInfo.texcoord.y);

      // The first frame UV for frame blend
      t = lerp(pd.texcoord3.xy, pd.texcoord2.xy, hitInfo.texcoord.x);
      b = lerp(pd.texcoord0.xy, pd.texcoord1.xy, hitInfo.texcoord.x);
      hitInfo.texcoord = lerp(t, b, hitInfo.texcoord.y);

      return hitInfo;
    }
  }
endmacro

macro USE_BVH(stage, need_textures, need_normal, need_color, cull_back_face, handle_translucent, first_hit, terrain_has_normal, gen_face_normal)
  USE_MAIN_BVH(stage, need_textures, need_normal, need_color, cull_back_face, handle_translucent, first_hit, terrain_has_normal, gen_face_normal)
  USE_PARTICLE_BVH(stage)
endmacro

macro USE_BVH_FX_RENDER(stage)
  hlsl(stage) {

    #include "dafx_def.hlsli"
    #include "dafx_hlsl_funcs.hlsli"
    #include "dafx_packers.hlsli"
    #include "modfx/modfx_curve_inc.hlsli"

    bool use_atmophere_for_fx()
    {
      ##if shader == bvh_debug
        return bvh_debug_use_atmosphere;
      ##else
        return true;
      ##endif
    }

    float wboit_weight(float z, float a)
    {
      // https://jcgt.org/published/0002/02/09/paper.pdf
      //return a * max(pow(10.f, -2.f), min(3*pow(10.f, 3.f), 10.f / (pow(10.f, -5.f) + pow(abs(z)/5.f, 2.f) + pow(abs(z)/200.f, 6.f))));
      return a * max(0.00001, min(1000.f, 10.f / (1e-05 + pow((z)/5.f, 2.f) + pow((z)/200.f, 6.f))));
    }

    half3 calc_particle_color(half4 texel, HitInfo hit_info, ModfxBVHParticleData pd, half alpha, half vol_alpha)
    {
      #define MODFX_LIGHTING_TYPE_UNIFORM 0
      #define MODFX_LIGHTING_TYPE_DISC 1
      #define MODFX_LIGHTING_TYPE_SPHERE 2
      #define MODFX_LIGHTING_TYPE_NORMALMAP 3

      half3 emissive_part;
      half3 lighting_part;
      if (pd.flags & BVH_MODFX_RMOD_TEX_COLOR_MATRIX)
      {
        float4 c;
        c.r = dot(texel, unpack_e3dcolor_to_n4f(pd.colorMatrix.x));
        c.g = dot(texel, unpack_e3dcolor_to_n4f(pd.colorMatrix.y));
        c.b = dot(texel, unpack_e3dcolor_to_n4f(pd.colorMatrix.z));
        c.a = dot(texel, unpack_e3dcolor_to_n4f(pd.colorMatrix.w));

        texel = half4(saturate(c));
      }

      if (pd.flags & BVH_MODFX_RMOD_TEX_COLOR_REMAP)
      {
        float grad_offset = 0;
        float grad_scale_rcp = 1;
        if ( pd.flags & BVH_MODFX_RMOD_TEX_COLOR_REMAP_DYNAMIC )
        {
          grad_offset = pd.lifeNorm;
          grad_scale_rcp = pd.gradScaleRcp;
        }

        float life_k = saturate( texel.r * grad_scale_rcp + grad_offset );
        ##assert(pd.colorRemapStepCnt <= MODFX_PREBAKE_GRAD_STEPS_LIMIT, "pd.colorRemapStepCnt (%f) out of bounds", pd.colorRemapStepCnt);
        pd.colorRemapStepCnt = min(pd.colorRemapStepCnt, MODFX_PREBAKE_GRAD_STEPS_LIMIT);
        float3 first = modfx_get_e3dcolor_grad_raw( pd.colorRemapArr, pd.colorRemapStepCnt, life_k ).rgb;

        if ( pd.flags & BVH_MODFX_RFLAG_TEX_COLOR_REMAP_APPLY_BASE_COLOR )
        {
          first *= hit_info.instanceColor.xyz;
        }

        emissive_part = first.xyz * pd.emission.r;
        lighting_part = saturate( 1.f - pd.emission.r ) * first.rgb;

        if ( pd.flags & BVH_MODFX_RFLAG_TEX_COLOR_REMAP_SECOND_MASK )
        {
          float3 second = texel.ggg;
          if ( pd.flags & BVH_MODFX_RFLAG_TEX_COLOR_REMAP_SECOND_MASK_APPLY_BASE_COLOR )
          {
            second *= hit_info.instanceColor.xyz;
          }

          float3 second_emissive = second.rgb * pd.emission.g;
          float3 second_lighting = saturate( 1.f - pd.emission.g ) * second.rgb;

          emissive_part = lerp( second_emissive, emissive_part, texel.b );
          lighting_part = lerp( second_lighting, lighting_part, texel.b );
        }
      }
      else
      {
        half3 c = texel.rgb * hit_info.instanceColor;
        emissive_part = c * half3(pd.emission.rgb);
        lighting_part = c;
      }

      lighting_part *= vol_alpha;
      emissive_part *= vol_alpha;

      if (pd.flags & BVH_MODFX_RMOD_LIGHTING_INIT)
      {
        half3 fwd_dir = half3(cross(pd.upDir, pd.rightDir));

        half ndl;
        half3 wnorm = 0;
        if ( pd.lighting_type == MODFX_LIGHTING_TYPE_UNIFORM )
          wnorm = half3( 0, 1, 0 );
        else if ( pd.lighting_type == MODFX_LIGHTING_TYPE_DISC || pd.lighting_type == MODFX_LIGHTING_TYPE_NORMALMAP )
          wnorm = fwd_dir;
        else if ( pd.lighting_type == MODFX_LIGHTING_TYPE_SPHERE )
        {
          float2 delta = hit_info.materialData1.zw;
          delta = float2(delta.x - 0.5, -delta.y + 0.5) * 2.f;

          half3 sphere_normal;
          sphere_normal.xy = half2(delta / pd.sphere_normal_radius);
          sphere_normal.z = sqrt( half(pd.sphere_normal_radius * pd.sphere_normal_radius) - dot( sphere_normal.xy, sphere_normal.xy ) );
          sphere_normal.y = -sphere_normal.y;
          sphere_normal = lerp( half3( 0, 0, 1 ), sphere_normal, half(pd.sphere_normal_power) );
          sphere_normal = normalize( sphere_normal );
          sphere_normal = fwd_dir * sphere_normal.z + half3(pd.rightDir) * sphere_normal.x + half3(pd.upDir) * sphere_normal.y;

          wnorm = sphere_normal;
        }

        ndl = saturate( dot( half3(-from_sun_direction.xyz), wnorm ) );

        half specular = 0;
        //if ( FLAG_ENABLED( flags, MODFX_RFLAG_LIGHTING_SPECULART_ENABLED ) )
        //{
        //  float3 h = normalize( input.view_dir - gdata.from_sun_direction );
        //  float ndh = saturate( dot( wnorm, h ) );
        //  specular = pow( ndh, pp.specular_power ) * ( pp.specular_strength / 255.f );
        //}

        ndl = ndl * ( 1.0 - half(pd.sphere_normal_softness) ) + half(pd.sphere_normal_softness);
        ndl = lerp( ndl, 1.h, saturate( dot( half3(from_sun_direction.xyz), fwd_dir ) ) * half(pd.lighting_translucency) );

        half3 lighting = ndl * half3(sun_color_0.rgb) * half(pd.shadow) + half3(pd.ambient) + half3(pd.lighting.rgb);

        lighting_part *= lighting;
        lighting_part += specular * half3(sun_color_0.rgb) * alpha;
      }

      return lighting_part + emissive_part;
    }

    struct TraceRayFxTranslucentAHSLambda AHSLambda
    {
      static const uint maxColorCount = 8;

      float primaryT;
      float rayMax;
      float alphas[maxColorCount];
      float distances[maxColorCount];
      uint cursor;

      float4 resultColor;
      float3 defaultColor;
      float resultAlpha;
      float smoothness;

      float InlineAHSImpl(AHSArgs)
      {
        // This can only be a particle
        if (ray_t >= rayMax)
          return 0;

        HitInfo hitInfo = CalcParticleHitInfo(ForwardAHSParams);

        ModfxBVHParticleData pd = structuredBufferAt(bvh_particle_data, hitInfo.perInstanceDataIndex);

        float smoothBias = get_cone_angle_from_smoothness(smoothness);
        float mipLevel = calc_mip_level(primaryT + hitInfo.t, false);
        mipLevel *= smoothBias;

        float4 texel1 = bvh_textures[NonUniformResourceIndex(bvh_textures_range_start + hitInfo.albedoTextureIndex)].SampleLevel(bvh_samplers[NonUniformResourceIndex(hitInfo.albedoSamplerIndex)], hitInfo.texcoord, mipLevel);
        float4 texel2 = bvh_textures[NonUniformResourceIndex(bvh_textures_range_start + hitInfo.albedoTextureIndex)].SampleLevel(bvh_samplers[NonUniformResourceIndex(hitInfo.albedoSamplerIndex)], hitInfo.materialData1.xy, mipLevel);
        half4 texel = half4(lerp(texel1, texel2, pd.frameBlend));
        half alpha = texel.a * (1.0 - hitInfo.translucency);
        if (pd.flags & BVH_MODFX_RFLAG_COLOR_USE_ALPHA_THRESHOLD)
          alpha = saturate(texel.a - hitInfo.translucency);

        half volAlpha = half(saturate(hitInfo.t) * saturate(rayMax - hitInfo.t));

        alpha *= volAlpha;

        if (pd.flags & BVH_MODFX_RFLAG_BLEND_ADD)
          alpha *= dot(texel.xyz, 1.0/3);

        if (alpha > 0)
        {
          half3 color = calc_particle_color(texel, hitInfo, pd, alpha, volAlpha);
          if (use_atmophere_for_fx())
            color = color * pd.atmosphereLoss + pd.atmosphereInscatter;

          // Pick the maxColorCount hits with the meanest alpha
          if (cursor < maxColorCount)
          {
            alphas[cursor] = alpha;
            distances[cursor] = hitInfo.t;
            cursor++;
          }
          else
          {
            // Find the lowest alpha value in colors and replace it
            int minAlphaIndex = 0;
            for (int i = 1; i < maxColorCount; i++)
              if (alphas[i] < alphas[minAlphaIndex])
                minAlphaIndex = i;

            if (alpha > alphas[minAlphaIndex])
            {
              alphas[minAlphaIndex] = alpha;
              distances[minAlphaIndex] = hitInfo.t;
            }
          }

          if (pd.flags & BVH_MODFX_RFLAG_BLEND_ABLEND)
            color *= alpha;

          // WBOIT borrowed from the particle system
          float t = hitInfo.t;
          resultColor.xyz += color * wboit_weight(t, alpha);
          resultColor.w *= (1.0 - alpha);
          resultAlpha += alpha * wboit_weight(t, alpha);
        }

        return alpha;
      }

      ##if hardware.scarlett
        void InlineAHS(inout XboxRayQueryProxy query)
        {
          if (InlineAHSImpl(PassAHSParams) > 0.99)
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif
    };

  ##if !hardware.ps5
    void trace_ray_fx_translucent(float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT, inout float3 color_inout, inout float translucent_t, float smoothness = 0.0, float3 defaultColor = 1)
    {
      [branch]
      if (!bvhParticlesValid)
        return;

      // Translucent tracing is done after the opaque tracing, because this is the only way to
      // ignore translucent hits that are behind opaque ones.

      const uint flags = RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES;

      GenericRayQuery(flags, TraceRayFxTranslucentAHSLambda) query;

      RayDesc ray;
      ray.Origin    = ray_origin;
      ray.Direction = ray_direction;
      ray.TMin      = ray_min;
      ray.TMax      = ray_max;

      query.TraceRayInline(bvhParticles, flags, bvhGroupAll, ray);

      TraceRayFxTranslucentAHSLambda lambda;
      lambda.primaryT = primaryT;
      lambda.rayMax = ray_max;
      lambda.cursor = 0;
      lambda.resultColor = float4(0, 0, 0, 1);
      lambda.defaultColor = defaultColor;
      lambda.resultAlpha = 0;
      lambda.smoothness = smoothness;

      ##if hardware.scarlett
        query.Proceed(lambda);
      ##else
        while (query.Proceed())
        {
          // Can only be a particle
          if (lambda.InlineAHSImpl(PassAHSParams) > 0.99)
            query.CommitNonOpaqueTriangleHit();
        }
      ##endif

      // WBOIT borrowed from the particle system
      for (uint k = 0; k < lambda.cursor; k++)
      {
        translucent_t = max(translucent_t, lambda.distances[k]);

        float3 col = lambda.resultColor.rgb / clamp(lambda.resultAlpha, 0.0000001, 1000);
        float a = 1 - lambda.resultColor.a;
        float4 blend = float4(col * a, a) * lambda.alphas[k] * a;

        color_inout.rgb = color_inout.rgb * (1 - blend.a) + blend.rgb;
      }
    }
  ##else
    void trace_ray_fx_translucent(float3 ray_origin, float3 ray_direction, float ray_min, float ray_max, float primaryT, inout float3 color_inout, inout float translucent_t, float smoothness = 0.0, float3 defaultColor = 1)
    {
      [branch]
      if (!bvhParticlesValid)
        return;

      TraceRayFxTranslucentAHSLambda lambda;
      lambda.primaryT = primaryT;
      lambda.rayMax = ray_max;
      lambda.cursor = 0;
      lambda.resultColor = float4(0, 0, 0, 1);
      lambda.defaultColor = defaultColor;
      lambda.resultAlpha = 0;
      lambda.smoothness = smoothness;

      auto inlineLambda = [&](float3 object_space_org, float3 object_space_dir, sce::Psr::Hit hit)
      {
        float m[12] = hit.m_instance->m_objectToWorld3x4; // row-major

        float3x4 to_world = {
          m[0], m[1], m[2], m[3],
          m[4], m[5], m[6], m[7],
          m[8], m[9], m[10],m[11]
        };

        float ray_t = hit.m_depth;
        uint triangleIx = hit.m_primitiveIndex;
        uint instanceId = hit.m_instanceID;
        int icthgi = hit.m_shaderTableContribution;
        uint instanceIndex = hit.m_instanceIndex;
        uint geometryIndex = hit.m_geometryIndex;
        float2 barycentrics2 = float2(hit.m_u, hit.m_v);
        bool isFrontFace = hit.m_hitKind == sce::Psr::HitKind::kTriangleFrontFace;

        lambda.InlineAHSImpl(ForwardAHSParams);

        if (lambda.cursor >= 4) // PS5 has performance issues with effects. For now tracing is limited to 4 closest effects
          return true;

        return false;
      };

      sce::Psr::Ray const ray = {
        .m_org = ray_origin,
        .m_tmin = ray_min,
        .m_dir = ray_direction,
        .m_tmax = ray_max
      };

      constexpr auto optimizedFlags = DEFAULT_TRAVERSAL_FLAFS;
      sce::Psr::RayFlags rayFlags = sce::Psr::RayFlags::kNone;
      auto const noIntersection = sce::Psr::NoIntersection{};
      auto const noAABBInstance = sce::Psr::NoAABBInstance {bvhParticles.m_bvh};

      sce::Psr::Closest<optimizedFlags>(bvhParticles.m_bvh, rayFlags, bvhGroupAll, ray, inlineLambda, noIntersection, noAABBInstance);

      // WBOIT borrowed from the particle system
      for (uint k = 0; k < lambda.cursor; k++)
      {
        translucent_t = max(translucent_t, lambda.distances[k]);

        float3 col = lambda.resultColor.rgb / clamp(lambda.resultAlpha, 0.0000001, 1000);
        float a = 1 - lambda.resultColor.a;
        float4 blend = float4(col * a, a) * lambda.alphas[k] * a;

        color_inout.rgb = color_inout.rgb * (1 - blend.a) + blend.rgb;
      }
    }
  ##endif

  }
endmacro

macro USE_BVH_FOR_RENDER(stage)
  USE_BVH(stage, 1, 1, 0, 1, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_SHADOW(stage)
  USE_MAIN_BVH(stage, 0, 0, 0, 0, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_DYNAMIC_SHADOW(stage)
  USE_MAIN_BVH(stage, 0, 0, 0, 1, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_AO(stage)
  USE_MAIN_BVH(stage, 0, 0, 0, 1, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_REFLECTION(stage)
  USE_BVH(stage, 1, 1, 0, 1, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_GI(stage)
  USE_MAIN_BVH(stage, 1, 1, 0, 1, 1, 0, 0, 0)
endmacro

macro USE_BVH_FOR_REFLECTION_PROBE(stage)
  USE_MAIN_BVH(stage, 1, 1, 0, 1, 0, 0, 0, 0)
endmacro

macro USE_ADAPTIVE_RAY_OFFSET(stage)
  hlsl (stage)
  {
    // For details see ray tracing gems, chapter 6.2
    // This function estimates the error of ray intersection testing
    // and offsets the origin along the (preferrably geometric) normal accordingly
    float3 applyAdaptiveRayOffset(const float3 rayOrigin, const float3 normal)
    {
      const float int_scale = 1U << 12;       // float32 mantissa (23bits) -> float16 mantissa (10bits)
                                              // in practice 12bits work just as well (rounding conversion perhaps?)
      const float float_scale = 1.f/65536.f;  // our minimum offset to avoid issues around 0 (that's ~0.01mm)
      const float origin = 1.f/32.f;          // with int_scale being 1 << 12 we reach float_scale at this distance

      int3 of_i = int3(int_scale * normal);
      int3 p_int = asint(rayOrigin) + select(rayOrigin < 0, -of_i, of_i);
      float3 p_i = asfloat(p_int);

      return lerp(p_i, rayOrigin + float_scale * normal, step(abs(rayOrigin), origin));
    }
  }
endmacro

macro USE_CALC_CAMERA_RELATIVE_POS(stage)
  hlsl (stage)
  {
    float3 calc_camera_relative_pos(uint2 dtid, float w, float2 inv_resolution)
    {
      float2 pixelCenter = float2(dtid) + 0.5;
      float2 uv = pixelCenter * inv_resolution;
      float3 viewVect = lerp_view_vec(uv);

      return viewVect * w;
    }
  }
endmacro

macro USE_CALC_WORLD_POS(stage)
  hlsl(stage) {
    float3 calc_world_pos(uint2 dtid, float w, float2 inv_resolution, float3 view_pos)
    {
      float2 pixelCenter = float2(dtid) + 0.5;
      float2 uv = pixelCenter * inv_resolution;
      float3 viewVect = lerp_view_vec(uv);

      float3 cameraToPoint = viewVect * w;
      float3 pointToEye = -cameraToPoint;
      return view_pos - pointToEye;
    }
  }
endmacro

macro INIT_HALF_RES_DEPTH_TEX(stage)
  BEGIN_ONCE(half_res_depth_tex_included)
  (stage) {
    half_res_depth_tex@tex2d = downsampled_close_depth_tex;
  }
  END_ONCE()
endmacro

macro USE_CALC_GEOMETRY_NORMAL_BASE(stage)
  USE_CALC_CAMERA_RELATIVE_POS(stage)

  hlsl (stage) {
    half3 calc_geometry_normal_depth(uint2 tci, float2 inv_resolution, float3 depth)
    {
      float3 wm = calc_camera_relative_pos(tci + uint2(0, 0), linearize_z(depth.x, zn_zfar.zw), inv_resolution);
      float3 wx = calc_camera_relative_pos(tci + uint2(1, 0), linearize_z(depth.y, zn_zfar.zw), inv_resolution);
      float3 wy = calc_camera_relative_pos(tci + uint2(0, 1), linearize_z(depth.z, zn_zfar.zw), inv_resolution);

      float3 dx = wx - wm;
      float3 dy = wy - wm;

      float3 worldNormal = normalize(cross(dx, dy));
      return (half3)worldNormal;
    }
  }
endmacro

macro USE_CALC_GEOMETRY_NORMAL_HALF(stage)
  USE_CALC_GEOMETRY_NORMAL_BASE(stage)

  INIT_HALF_RES_DEPTH_TEX(stage)
  hlsl (stage) {
    float3 getHalfDepth(uint2 tci)
    {
      return float3(texture2DAt(half_res_depth_tex, tci).r,
        texture2DAt(half_res_depth_tex, tci + uint2(1, 0)).r,
        texture2DAt(half_res_depth_tex, tci + uint2(0, 1)).r);
    }

    half3 calc_geometry_normal_half(uint2 tci, float2 inv_resolution, uint2 resolution)
    {
      tci = min(tci, resolution - 2); // Prevent sampling depth over the edge of the screen.
      return calc_geometry_normal_depth(tci, inv_resolution, getHalfDepth(tci));
    }
  }
endmacro

macro USE_CALC_GEOMETRY_NORMAL(stage)
  USE_CALC_GEOMETRY_NORMAL_BASE(stage)

  hlsl (stage) {
    float3 getDepth(uint2 tci)
    {
      return float3(loadGbufferDepth(tci + uint2(0, 0)),
        loadGbufferDepth(tci + uint2(1, 0)),
        loadGbufferDepth(tci + uint2(0, 1)));
    }

    half3 calc_geometry_normal(uint2 tci, float2 inv_resolution, uint2 resolution)
    {
      tci = min(tci, resolution - 2); // Prevent sampling depth over the edge of the screen.
      return calc_geometry_normal_depth(tci, inv_resolution, getDepth(tci));
    }
  }
endmacro

// For sample compatibility
define_macro_if_not_defined INIT_BVH_WATER_FADE(stage)
endmacro
define_macro_if_not_defined INIT_PS5_INLINE_RT(stage)
endmacro

define_macro_if_not_defined USE_BVH_WATER_FADE(stage)
  hlsl(stage) {
    half calc_underwater_fade(float w, uint2 dtid, float2 inv_resolution, float3 view_pos)
    {
      return 1;
    }
  }
endmacro

macro USE_COSINE_SAMPLING(stage)
  hlsl(stage) {
    float2 hash2(inout float seed)
    {
      float s1 = seed += 1;
      float s2 = seed += 1;
      return float2(frac(sin(float2(s1, s2)) * float2(43758.5453123, 22578.1459123)));
    }

    half3 cosine_sample_hemisphere(half3 n, inout float seed, half scale = 1)
    {
      half2 u = (half2) hash2(seed);
      half r = sqrt(u.x) * scale;
      half theta = 2 * PIh * u.y;
      half3 B = normalize(cross(n, half3(0.h, 1.h, 1.h)));
      half3 T = cross(B, n);
      return normalize(r * sin(theta) * B + sqrt(1.h - u.x) * n + r * cos(theta) * T);
    }
  }
endmacro
