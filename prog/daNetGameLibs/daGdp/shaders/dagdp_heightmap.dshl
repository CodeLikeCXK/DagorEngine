include "biomes.dshl"
include "dagdp_common_heightmap.dshl"
include "toroidal_grass.dshl"

texture perlin_noise3d;
texture blue_noise_tex;

buffer dagdp__instance_data;
buffer dagdp__dyn_allocs;
buffer dagdp__dyn_counters;

buffer dagdp_heightmap__draw_ranges;
buffer dagdp_heightmap__placeables;
buffer dagdp_heightmap__placeable_weights;
buffer dagdp_heightmap__renderable_indices;
buffer dagdp_heightmap__tile_positions;
buffer dagdp_heightmap__biomes;
buffer dagdp_heightmap__variants;
buffer dagdp_heightmap__indirect_args;
buffer dagdp_heightmap__visible_tile_positions;
buffer dagdp_heightmap__density_mask_channel_weights;

texture dagdp_heightmap__density_mask;
float4 dagdp_heightmap__density_mask_scale_offset;

int dagdp_heightmap__num_renderables;
int dagdp_heightmap__num_placeables;
int dagdp_heightmap__num_biomes;
int dagdp_heightmap__num_tiles;

float dagdp_heightmap__max_placeable_bounding_radius;
float dagdp_heightmap__tile_pos_delta;
float dagdp_heightmap__instance_pos_delta;
float4 dagdp_heightmap__reference_pos;
float dagdp_heightmap__debug_frustum_culling_bias;

int dagdp_heightmap__prng_seed_jitter_x;
int dagdp_heightmap__prng_seed_jitter_z;
int dagdp_heightmap__prng_seed_placeable;
int dagdp_heightmap__prng_seed_slope;
int dagdp_heightmap__prng_seed_occlusion;
int dagdp_heightmap__prng_seed_scale;
int dagdp_heightmap__prng_seed_yaw;
int dagdp_heightmap__prng_seed_pitch;
int dagdp_heightmap__prng_seed_roll;
int dagdp_heightmap__prng_seed_density;
float dagdp_heightmap__grid_jitter;
float dagdp_heightmap__displacement_noise_scale;
float dagdp_heightmap__displacement_strength;
float dagdp_heightmap__placement_noise_scale;
float dagdp_heightmap__sample_range;
int dagdp_heightmap__lower_level;
int dagdp_heightmap__use_decals;
int dagdp_heightmap__discard_on_grass_erasure;

float4 dagdp_heightmap__base_tile_pos_xz;
int4 dagdp_heightmap__base_tile_int_pos_xz;
float4 dagdp_heightmap__viewport_pos;
float dagdp_heightmap__viewport_max_distance;
int dagdp_heightmap__viewport_index;

shader dagdp_heightmap_cull_tiles
{
  ENABLE_ASSERT(cs)

  INIT_WORLD_HEIGHTMAP(cs)
  USE_HEIGHTMAP_COMMON(cs)
  INIT_AND_USE_FRUSTUM_CHECK_BASE(cs)

  (cs) {
    indirect_args@uav = dagdp_heightmap__indirect_args hlsl {
      RWByteAddressBuffer indirect_args@uav;
    }

    tile_positions@buf = dagdp_heightmap__tile_positions hlsl {
      StructuredBuffer<int2> tile_positions@buf;
    }

    visible_tile_positions@uav = dagdp_heightmap__visible_tile_positions hlsl {
      RWByteAddressBuffer visible_tile_positions@uav;
    }

    base_tile_pos_xz@f2 = dagdp_heightmap__base_tile_pos_xz;
    tile_pos_delta@f1 = dagdp_heightmap__tile_pos_delta;
    max_placeable_bounding_radius@f1 = dagdp_heightmap__max_placeable_bounding_radius;
    num_tiles@i1 = dagdp_heightmap__num_tiles;
    viewport_pos@f3 = dagdp_heightmap__viewport_pos;
    viewport_max_distance@f1 = dagdp_heightmap__viewport_max_distance;
    viewport_index@i1 = dagdp_heightmap__viewport_index;
  }

  hlsl(cs)
  {
    #define SQRT_1_2 0.70710678118
    #include "dagdp_heightmap.hlsli"
    [numthreads(TILE_COUNT_PER_GROUP, 1, 1)]
    void main(uint dtId : SV_DispatchThreadID)
    {
      BRANCH
      if (dtId == 0)
      {
        storeBuffer(indirect_args, viewport_index * DISPATCH_INDIRECT_BYTE_SIZE + 4, 1);
        storeBuffer(indirect_args, viewport_index * DISPATCH_INDIRECT_BYTE_SIZE + 8, 1);
      }

      BRANCH
      if (dtId < num_tiles)
      {
        const int2 tileIntPos = structuredBufferAt(tile_positions, dtId);
        const float2 tilePosXZ = base_tile_pos_xz + tile_pos_delta * tileIntPos;
        const float distXZ = max(0.0, distance(viewport_pos.xz, tilePosXZ + 0.5 * tile_pos_delta) - tile_pos_delta * SQRT_1_2); // Lower bound of horizontal distance to tile.
        const float yRange = sqrt(viewport_max_distance * viewport_max_distance - distXZ * distXZ); // Higher bound of Y viewport range for the tile.
        const float3 tilePos = float3(tilePosXZ.x, viewport_pos.y - yRange, tilePosXZ.y);
        const float3 tileSize = float3(tile_pos_delta, 2.0 * yRange, tile_pos_delta);

        BRANCH
        if (testBoxB(tilePos - max_placeable_bounding_radius, tilePos + tileSize + 2.0 * max_placeable_bounding_radius))
        {
          uint tileIdx;
          indirect_args.InterlockedAdd(viewport_index * DISPATCH_INDIRECT_BYTE_SIZE, 1, tileIdx);
          storeBuffer2(visible_tile_positions, tileIdx * TILE_POSITION_BYTE_SIZE, tileIntPos);
        }
      }
    }
  }
  compile("target_cs", "main");
}

shader dagdp_heightmap_place_stage0, dagdp_heightmap_place_stage1
{
  ENABLE_ASSERT(cs)

  (cs) {
    instance_data@uav = dagdp__instance_data hlsl {
      RWBuffer<float4> instance_data@uav;
    }

    dyn_counters@uav = dagdp__dyn_counters hlsl {
      RWStructuredBuffer<uint> dyn_counters@uav;
    }

    dyn_allocs@buf = dagdp__dyn_allocs hlsl {
      #include "dagdp_common.hlsli"
      StructuredBuffer<DynAlloc> dyn_allocs@buf;
    }

    draw_ranges@buf = dagdp_heightmap__draw_ranges hlsl {
      StructuredBuffer<float> draw_ranges@buf;
    }

    placeables@buf = dagdp_heightmap__placeables hlsl {
      #include "dagdp_common.hlsli"
      StructuredBuffer<PlaceableGpuData> placeables@buf;
    }

    placeable_weights@buf = dagdp_heightmap__placeable_weights hlsl {
      StructuredBuffer<float> placeable_weights@buf;
    }

    renderable_indices@buf = dagdp_heightmap__renderable_indices hlsl {
      StructuredBuffer<uint> renderable_indices@buf;
    }

    biomes@buf = dagdp_heightmap__biomes hlsl {
      StructuredBuffer<uint> biomes@buf;
    }

    variants@buf = dagdp_heightmap__variants hlsl {
      #include "dagdp_common_placer.hlsli"
      StructuredBuffer<VariantGpuData> variants@buf;
    }

    visible_tile_positions@buf = dagdp_heightmap__visible_tile_positions hlsl {
      ByteAddressBuffer visible_tile_positions@buf;
    }

    density_mask_channel_weights@buf = dagdp_heightmap__density_mask_channel_weights hlsl {
      StructuredBuffer<float4> density_mask_channel_weights@buf;
    }

    density_mask@smp2d = dagdp_heightmap__density_mask;
    density_mask_exists@i1 = (exists_tex(dagdp_heightmap__density_mask));
    density_mask_scale_offset@f4 = dagdp_heightmap__density_mask_scale_offset;

    num_renderables@i1 = dagdp_heightmap__num_renderables;
    num_placeables@i1 = dagdp_heightmap__num_placeables;
    num_biomes@i1 = dagdp_heightmap__num_biomes;

    max_placeable_bounding_radius@f1 = dagdp_heightmap__max_placeable_bounding_radius;
    tile_pos_delta@f1 = dagdp_heightmap__tile_pos_delta;
    instance_pos_delta@f1 = dagdp_heightmap__instance_pos_delta;
    debug_frustum_culling_bias@f1 = dagdp_heightmap__debug_frustum_culling_bias;
    water_level@f1 = water_level;

    prng_seed_jitter_x@i1 = dagdp_heightmap__prng_seed_jitter_x;
    prng_seed_jitter_z@i1 = dagdp_heightmap__prng_seed_jitter_z;
    prng_seed_placeable@i1 = dagdp_heightmap__prng_seed_placeable;
    prng_seed_slope@i1 = dagdp_heightmap__prng_seed_slope;
    prng_seed_occlusion@i1 = dagdp_heightmap__prng_seed_occlusion;
    prng_seed_scale@i1 = dagdp_heightmap__prng_seed_scale;
    prng_seed_yaw@i1 = dagdp_heightmap__prng_seed_yaw;
    prng_seed_pitch@i1 = dagdp_heightmap__prng_seed_pitch;
    prng_seed_roll@i1 = dagdp_heightmap__prng_seed_roll;
    prng_seed_density@i1 = dagdp_heightmap__prng_seed_density;
    grid_jitter@f1 = dagdp_heightmap__grid_jitter;
    displacement_noise_scale@f1 = 1.0 / max(dagdp_heightmap__displacement_noise_scale, 1e-8);
    displacement_strength@f1 = dagdp_heightmap__displacement_strength;
    placement_noise_scale@f1 = 1.0 / max(dagdp_heightmap__placement_noise_scale*128, 1e-8);
    sample_range@f1 = dagdp_heightmap__sample_range;
    lower_level@i1 = dagdp_heightmap__lower_level;
    use_decals@i1 = dagdp_heightmap__use_decals;
    discard_on_grass_erasure@i1 = dagdp_heightmap__discard_on_grass_erasure

    base_tile_pos_xz@f2 = dagdp_heightmap__base_tile_pos_xz;
    base_tile_int_pos_xz@i2 = dagdp_heightmap__base_tile_int_pos_xz;
    viewport_pos@f3 = dagdp_heightmap__viewport_pos;
    viewport_max_distance@f1 = dagdp_heightmap__viewport_max_distance;
    viewport_index@i1 = dagdp_heightmap__viewport_index;

    grass_color_tex@smp2d = grass_color_tex;
    perlin_noise3d@smp3d = perlin_noise3d;
    blue_noise_tex@smp2d = blue_noise_tex;
  }

  INIT_BIOMES(cs)
  USE_BIOMES(cs)
  USE_DAGDP_COMMON_HEIGHTMAP(shader == dagdp_heightmap_place_stage1)
  USE_GRASS_TC(cs)

  hlsl(cs) {
    #include <grassInstance.hlsli>

    float getDensityFromMask(float2 worldXZ, uint placeableIndex)
    {
      BRANCH
      if (!density_mask_exists)
        return 1.0;

      float2 tc = worldXZ * density_mask_scale_offset.xy + density_mask_scale_offset.zw;
      float4 densities = tex2Dlod(density_mask, float4(tc, 0, 0));
      float4 densityMaskChannelWeights = structuredBufferAt(density_mask_channel_weights, placeableIndex);

      return lerp(1.0, densities.x, densityMaskChannelWeights.x) *
             lerp(1.0, densities.y, densityMaskChannelWeights.y) *
             lerp(1.0, densities.z, densityMaskChannelWeights.z) *
             lerp(1.0, densities.w, densityMaskChannelWeights.w);
    }

    [numthreads(1, TILE_INSTANCE_COUNT, 1)]
    void main(uint3 dtId : SV_DispatchThreadID, uint3 tId : SV_GroupThreadID)
    {
      ##if shader == dagdp_heightmap_place_stage1
        const bool isEarlyExit = structuredBufferAt(dyn_counters, DYN_COUNTERS_INDEX_SKIP_PESSIMISTIC_PLACEMENT) != 0;
        ##if hardware.dx11
          // Work around compiler assuming varying flow control.
          BRANCH
          if (threadGroupAnyTrue(isEarlyExit, tId.y))
            return;
        ##else
          BRANCH
          if (isEarlyExit)
            return;
        ##endif
      ##endif

      // XZ position inside the tile.
      const uint2 instanceIntPos = uint2(dtId.y / TILE_INSTANCE_COUNT_1D, dtId.y % TILE_INSTANCE_COUNT_1D);

      // XZ position of the tile itself.
      const int2 tileIntPos = loadBuffer2(visible_tile_positions, dtId.x * TILE_POSITION_BYTE_SIZE);

      const int2 stablePos = (base_tile_int_pos_xz + tileIntPos) * TILE_INSTANCE_COUNT_1D + int2(instanceIntPos);
      float2 randPosJitter = 0.5 + grid_jitter * (float2(stableRand(stablePos, prng_seed_jitter_x), stableRand(stablePos, prng_seed_jitter_z)) - 0.5);
      // compute from integer coordinates using only tile_pos_delta, for stability:
      const float2 baseInstancePosXZ = (stablePos + randPosJitter) * (tile_pos_delta / TILE_INSTANCE_COUNT_1D);
      float2 instancePosXZ = baseInstancePosXZ;
      if (displacement_strength != 0)
        instancePosXZ += (tex3Dlod(perlin_noise3d, float4(instancePosXZ * displacement_noise_scale, 0, 0)).xy * 2 - 1)
          * (displacement_strength * instance_pos_delta);

      PlacementDetails pd;
      initPlacementDetails(instancePosXZ, pd, sample_range);

      FLATTEN
      if (!lower_level)
        pd.position.y = pd.topY;

      uint variantIndex = ~0u;
      int biomeIndex = getBiomeIndex(pd.position);

      BRANCH
      if (use_decals)
      {
        float2 grass_mask_tc = getGrassTC(pd.position);
        uint decalBiome = floor(tex2Dlod(grass_color_tex, float4(grass_mask_tc, 0, 0)).a * 255 + 0.5);
        half decalMask = tex2Dlod(grass_mask_tex, float4(grass_mask_tc, 0, 0)).a;
        FLATTEN
        if (decalBiome >= 255 || decalMask >= stableRand(stablePos, prng_seed_density))
          biomeIndex = decalBiome;
      }

      if (discard_on_grass_erasure)
      {
        float2 grass_mask_tc = getGrassTC(pd.position);
        uint grassChannel = tex2Dlod(grass_mask_tex, float4(grass_mask_tc, 0, 0)).r * 255;
        FLATTEN
        if (grassChannel >= GRASS_MAX_CHANNELS)
          biomeIndex = num_biomes; // make it invalid
      }

      FLATTEN
      if (biomeIndex < num_biomes)
        variantIndex = structuredBufferAt(biomes, biomeIndex);

      uint placeableIndex = ~0u;

      VariantGpuData variant;
      FLATTEN
      if (variantIndex != ~0u)
      {
        variant = structuredBufferAt(variants, variantIndex);

        float2 noise = tex2Dlod(blue_noise_tex, float4(baseInstancePosXZ * placement_noise_scale, 0, 0)).rg;
        // float randomSample = stableRand(stablePos, prng_seed_placeable); // old RNG for comparison
        float randomSample = noise.r + noise.g * (1.0/(1<<8)); // use more bits from the noise

        // Wrap around, so that ~0 values ("empty weight") use middle of the noise range.
        // It looks like values close to 0 and 1 are less likely in noise textures (because of interpolation?)
        randomSample = frac(randomSample + 0.5);
        placeableIndex = getPlaceableIndex(variant, randomSample);
      }

      PlaceableGpuData placeable;
      FLATTEN
      if (placeableIndex != ~0u)
      {
        placeable = structuredBufferAt(placeables, placeableIndex);

        const bool isDensityMaskOk = getDensityFromMask(pd.position.xz, placeableIndex) > stableRand(stablePos, prng_seed_density);

        FLATTEN
        if (!isDensityMaskOk)
          placeableIndex = ~0u;
      }

      adjustPlacement(placeableIndex, placeable, stablePos, pd);

      BRANCH
      if (!threadGroupAnyTrue(placeableIndex != ~0u, tId.y)) // Whole tile is culled, can safely exit.
        return;

      finishPlacement(tId.y, stablePos, pd, placeableIndex, placeable, variant);
    }
  }
  compile("target_cs", "main");
}