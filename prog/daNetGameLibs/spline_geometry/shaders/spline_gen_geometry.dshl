include "spline_gen_inc.dshl"
include "frustum.dshl"

texture spline_gen_texture_n;

int spline_gen_instance_count;
int spline_gen_active_instance_count;
int spline_gen_culled_buffer_uav_no = 0;
int spline_gen_params_buffer_uav_no = 1;

int spline_gen_obj_elem_count;
int spline_gen_attachment_data_uav_no = 0;


shader spline_gen_obj_attacher
{
  if (in_editor_assume == yes) { dont_render; }
  INIT_SPLINE_GEN_INSTANTIATION_GENERATE()
  USE_SPLINE_GEN_INSTANTIATION(cs)
  INIT_SPLINE_GEN_ATTACHMENT_BATCHES(cs)
  USE_VS_SPLINE_GEN(cs)
  ENABLE_ASSERT(cs)

  (cs)
  {
    spline_gen_active_instance_count@i1 = (spline_gen_active_instance_count);
    spline_gen_attachment_data@uav : register(spline_gen_attachment_data_uav_no) hlsl {
      #include "spline_gen_attachment.hlsl"
      RWStructuredBuffer<AttachmentData> spline_gen_attachment_data@uav;
    };

    spline_gen_texture_d@smp2d = spline_gen_texture_d;
  }

  hlsl (cs)
  {
    #include <hammersley.hlsl>

    struct CoordEx
    {
      uint2 coord;
      float lerpS; //the fraction of coordFloat.y
    };

    CoordEx get_hammersley_coord(uint obj_id, uint obj_count, float obj_stripe_mul)
    {
      float2 coordFloat = hammersley(obj_id, obj_count).yx;
      coordFloat.x *= spline_gen_slices;
      coordFloat.y *= obj_stripe_mul * spline_gen_stripes;
      CoordEx coordEx;
      coordEx.coord = uint2(coordFloat);
      coordEx.lerpS = coordFloat.y - coordEx.coord.y;
      return coordEx;
    }

    float3x3 get_rotation_matrix(InstanceId instance_id, CoordEx coord_ex, float3 normal)
    {
      float3 tangent = lerp(structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instance_id, coord_ex.coord.y + 0)).tangent,
                            structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instance_id, coord_ex.coord.y + 1)).tangent, coord_ex.lerpS);
      float3 axisX, axisY, axisZ;
      axisY = normal;
      axisX = normalize(cross(axisY, tangent));
      axisZ = cross(axisX, axisY);
      //random rotation maybe
      return float3x3(axisX, axisY, axisZ);
    }

    float get_size(float obj_size_mul, float radius, float inv_max_rad)
    {
      return obj_size_mul * radius * inv_max_rad;
    }

    [numthreads(SPLINE_GEN_ATTACHMENT_COMPUTE_X, SPLINE_GEN_ATTACHMENT_COMPUTE_Y, 1)]
    void main(uint2 dispatch_thread_id : SV_DispatchThreadID)
    {
      if (dispatch_thread_id.y >= spline_gen_active_instance_count)
        return;
      uint objectId = dispatch_thread_id.x;
      InstanceId instanceId = bufferAt(spline_gen_indirection_buffer, dispatch_thread_id.y);
      SplineGenInstance instanceData = structuredBufferAt(spline_gen_instancing_buffer, instanceId);
      if (objectId >= instanceData.objCount)
        return;

      CoordEx coordEx = get_hammersley_coord(objectId, instanceData.objCount, instanceData.objStripeMul);
      SplineGenSpline spline = structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instanceId, coordEx.coord.y));
      uint vertex_id0 = decode_shifted_coord(coordEx.coord, int2(0, 0));
      uint vertex_id1 = decode_shifted_coord(coordEx.coord, int2(0, 1));

      SplineGenSpline nextSpline = structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instanceId, coordEx.coord.y + 1));

      uint2 currCoord = coordEx.coord;
      uint2 nextCoord = get_vertex_coord(vertex_id1);

      float3 transformedPos0 = get_world_pos(spline, instanceData, currCoord);
      float3 transformedPos1 = get_world_pos(nextSpline, instanceData, nextCoord);

      float3 vertexNormal0 = calculate_normal(currCoord, vertex_id0, instanceId);
      float3 vertexNormal1 = calculate_normal(nextCoord, vertex_id1, instanceId);

      float3 interpolatedNormal = normalize(lerp(vertexNormal0, vertexNormal1, coordEx.lerpS));
      float3 interpolatedWorldPos = lerp(transformedPos0, transformedPos1, coordEx.lerpS);
      float3x3 rotScaleMat = get_rotation_matrix(instanceId, coordEx, interpolatedNormal);

      float size = get_size(instanceData.objSizeMul, spline.radius, instanceData.inverseMaxRadius);
      rotScaleMat *= size;

      AttachmentData result;
      pack_tm(rotScaleMat, interpolatedWorldPos, result);
      uint objBatchId = bufferAt(spline_gen_obj_batch_id_buffer, instanceData.batchIdsStart + objectId / spline_gen_attachment_batch_size);
      uint idInBatch = objectId % spline_gen_attachment_batch_size;
      structuredBufferAt(spline_gen_attachment_data, objBatchId * spline_gen_attachment_batch_size + idInBatch) = result;
    }
  }
  compile("target_cs", "main");
}



shader dynamic_spline_gen, dynamic_emissive_spline_gen, dynamic_skin_spline_gen
{
  if (in_editor_assume == yes) { dont_render; }
  cull_mode=none;
  ENABLE_ASSERT(ps)
  NO_ATEST()

  DYNAMIC_SPLINE_GEN_VS_COMMON()
  USE_VS_SPLINE_GEN(vs)

  (vs)
  {
    spline_gen_prev_spline_buffer@buf = spline_gen_prev_spline_buffer hlsl {
      #include "spline_gen_buffer.hlsli"
      StructuredBuffer<SplineGenSpline> spline_gen_prev_spline_buffer@buf;
    }

    spline_gen_texture_d@smp2d = spline_gen_texture_d;
  }

  hlsl (vs)
  {
    VsOutput spline_gen_vs(uint hardware_instance_id : SV_InstanceID, uint vertex_id : SV_VertexID)
    {
      InstanceId instanceId = structuredBufferAt(spline_gen_culled_buffer, hardware_instance_id);
      SplineGenInstance instanceData = structuredBufferAt(spline_gen_instancing_buffer, instanceId);

      uint2 coord = get_vertex_coord(vertex_id);
      SplineGenSpline spline = structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instanceId, coord.y));
      float2 floatCoord = convert_coord_to_float(coord);
      float2 texcoord = floatCoord * instanceData.tcMul;
      float3 transformedPos = get_world_pos(spline, instanceData, coord);

      VsOutput output;
      output.pos = mul(float4(transformedPos, 1), viewProjTm);
      output.pointToEye = world_view_pos - transformedPos;
      output.texcoord = texcoord;

    ##if (shader == dynamic_emissive_spline_gen)
      output.emissiveColor = instanceData.emissiveColor;
      output.emissiveIntensity = spline.emissiveIntensity;
    ##endif

    ##if (dyn_model_render_pass == render_pass_normal)
      // We don't care about normals for shadows
      float3 vertexNormal, vertexTangent, vertexBitangent;
      calculate_tangent_space(coord, vertex_id, instanceId, vertexTangent, vertexBitangent, vertexNormal);
      output.normal = normalize(vertexNormal);
      output.tangent = normalize(vertexTangent);
      output.bitangent = normalize(vertexBitangent);

      #ifdef MOTION_VECTORS_ENABLED
        output.out_pos =  output.pos;
        float3 prevPos = transformedPos;
        if (instanceData.flags & PREV_SB_VALID)
        {
          SplineGenSpline prevSpline = structuredBufferAt(spline_gen_spline_buffer, get_spline_index(instanceId, coord.y));
          prevPos = get_world_pos(prevSpline, instanceData, coord);
        }
        output.out_prev_pos = mul(float4(prevPos, 1), prevOrigoRelativeViewProjTm);
      #endif
    ##else
      output.normal = 0;
      output.tangent = 0;
      output.bitangent = 0;
    ##endif
      return output;
    }
  }
  compile("target_vs", "spline_gen_vs");

  (ps)
  {
    spline_gen_texture_d@smp2d = spline_gen_texture_d;
    spline_gen_texture_n@smp2d = spline_gen_texture_n;
  }

  if (dyn_model_render_pass == render_pass_normal)
  {
    DYNAMIC_SPLINE_GEN_PS_COMMON()
    hlsl (ps)
    {
      GBUFFER_OUTPUT spline_gen_ps(VsOutput input HW_USE_SCREEN_POS)
      {
        float4 packedDiffuse = tex2D(spline_gen_texture_d, input.texcoord);
        float4 packedNormalMap = tex2D(spline_gen_texture_n, input.texcoord);
        return spline_gen_ps_base_impl(input, packedDiffuse, packedNormalMap, GET_SCREEN_POS(input.pos));
      }
    }
    compile("target_ps", "spline_gen_ps");
  }
  else
  {
    compile("ps_null", "null_ps");
  }
}


shader dynamic_spline_gen_culler
{
  if (in_editor_assume == yes) { dont_render; }
  INIT_SPLINE_GEN_INSTANTIATION_GENERATE()
  INIT_AND_USE_FRUSTUM_CHECK_CS()
  ENABLE_ASSERT(cs)

  (cs)
  {
    spline_gen_instance_count@i1 = (spline_gen_instance_count);
    spline_gen_attachment_max_no@i1 = (spline_gen_attachment_max_no);
    spline_gen_obj_elem_count@i1 = (spline_gen_obj_elem_count);
    spline_gen_culled_buffer@uav : register(spline_gen_culled_buffer_uav_no) hlsl {
      RWStructuredBuffer<uint> spline_gen_culled_buffer@uav;
    };
    spline_gen_params_buffer@uav : register(spline_gen_params_buffer_uav_no) hlsl {
      RWByteAddressBuffer spline_gen_params_buffer@uav;
    };
  }
  hlsl (cs)
  {
    struct BBox3
    {
      float3 lim[2];
    };

    uint get_source_index(uint dispatch_thread_id)
    {
      if (dispatch_thread_id >= spline_gen_instance_count)
        return INVALID_INSTANCE_ID;
      return bufferAt(spline_gen_indirection_buffer, dispatch_thread_id);
    }

    BBox3 get_bbox(uint source_index)
    {
      BBox3 result;
      result.lim[0] = structuredBufferAt(spline_gen_instancing_buffer, source_index).bbox_lim0;
      result.lim[1] = structuredBufferAt(spline_gen_instancing_buffer, source_index).bbox_lim1;
      return result;
    }

    [numthreads(SPLINE_GEN_COMPUTE_DIM, 1, 1)]
    void main(uint dispatch_thread_id : SV_DispatchThreadID)
    {
      uint sourceIndex = get_source_index(dispatch_thread_id);
      if (sourceIndex == INVALID_INSTANCE_ID)
        return;
      BBox3 bbox = get_bbox(sourceIndex);
      if (testBoxB(bbox.lim[0], bbox.lim[1]))
      {
        uint culledIndex;
        spline_gen_params_buffer.InterlockedAdd(1 * 4, 1u, culledIndex);
        LOOP
        for (int i = 0; i < spline_gen_obj_elem_count; i++)
        {
          uint address = (6 + i * 5) * 4;
          spline_gen_params_buffer.InterlockedAdd(uint((CHECK_BUFFER_EXPR(spline_gen_params_buffer, address), address)), uint(spline_gen_attachment_max_no));
        }
        structuredBufferAt(spline_gen_culled_buffer, culledIndex) = sourceIndex;
      }
    }
  }
  compile("target_cs", "main");
}
