include "dynamic_trans_inc.dshl"
include "indoor_light_probes.dshl"
include "gbuffer.dshl"

include "scope/scope_lens_inc.dshl"
include "rt_glass_apply.dshl"

shader scope_lens, dynamic_crosshair
{
  if (lens_detail_level != full_night_vision && special_vision != thermal_vision)
  {
    INIT_GLASS_HOLE_MASK(ps)
    RT_GLASS_APPLY(ps)
  }
  SCOPE_LENS_SHADER()
}

float4 scope_reticle_world_tm_0;
float4 scope_reticle_world_tm_1;
float4 scope_reticle_world_tm_2;

shader scope_reticle
{
  ENABLE_ASSERT(ps)
  supports global_frame;

  blend_src = sa;
  blend_dst = isa;

  z_write = true;
  z_test = true;

  USE_ATEST_1()

  (vs)
  {
    viewProjTm@f44 = viewprojtm;
    scope_reticle_world_tm_0@f4 = scope_reticle_world_tm_0;
    scope_reticle_world_tm_1@f4 = scope_reticle_world_tm_1;
    scope_reticle_world_tm_2@f4 = scope_reticle_world_tm_2;
    scope_reticle_size@f1 = (scope_reticle_radius * scope_reticle_size_mul, 0, 0, 0);
  }

  (ps) {
    scope_reticle_tex@smp2d = scope_reticle_tex;
  }

  hlsl {
    struct VsOutput
    {
      VS_OUT_POSITION(pos)
      float2 texcoord : TEXCOORD0;
    };
    #define CROSSHAIR_DISTANCE 50.0
  }

  hlsl(vs) {
    VsOutput scope_reticle_vs(uint vertexId : SV_VertexID)
    {
      uint subVertexId = vertexId % 4;
      float2 quadUV = float2(subVertexId % 3 != 0, subVertexId / 2);
      float4 localPos = float4(0.0, -(quadUV * 2.0 - 1.0) * scope_reticle_size, 1.0);
      float3 worldPos = float3(dot(scope_reticle_world_tm_0, localPos),
                               dot(scope_reticle_world_tm_1, localPos),
                               dot(scope_reticle_world_tm_2, localPos));
      float3 eyeToLens = float3(scope_reticle_world_tm_0.w, scope_reticle_world_tm_1.w, scope_reticle_world_tm_2.w);
      float3 lensWorldNormal = float3(scope_reticle_world_tm_0.x, scope_reticle_world_tm_1.x, scope_reticle_world_tm_2.x);
      float4 collimatorPos = mulPointTm(eyeToLens + lensWorldNormal * CROSSHAIR_DISTANCE, viewProjTm);
      float4 lensPos = mulPointTm(eyeToLens, viewProjTm);

      VsOutput output;
      output.pos = mulPointTm(worldPos, viewProjTm);
      output.pos.xy /= output.pos.w;
      output.pos.xy += collimatorPos.xy / collimatorPos.w - lensPos.xy / lensPos.w;
      output.pos.xy *= output.pos.w;
      output.texcoord = quadUV;

      return output;
    }
  }

  hlsl(ps)
  {
    float4 scope_reticle_ps(VsOutput input HW_USE_SCREEN_POS) : SV_Target0
    {
      float alpha = tex2D(scope_reticle_tex, input.texcoord).a;
      return float4(0, 0, 0, alpha);
    }
  }

  compile("target_vs", "scope_reticle_vs");
  compile("target_ps", "scope_reticle_ps");
}
